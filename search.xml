<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java刷题技巧</title>
    <url>/2024/04/01/Java%E5%88%B7%E9%A2%98%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>刷题网站推荐</p>
<ul>
<li><a class="link"   href="https://leetcode.cn/" >力扣 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.luogu.com.cn/" >洛谷 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://ac.nowcoder.com/acm/problem/list" >牛客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://codeforces.com/" >CF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">明确各个不同网站之间的区别：如力扣的代码是核心代码模式，而牛客等就是ACM模式，内容推荐系统刷力扣，针对练习洛谷、牛客中的难题，最后也可以多打打cf比赛</span><br></pre></td></tr></table></figure></div>



<h3 id="1-Arrays-sort自定义排序规则"><a href="#1-Arrays-sort自定义排序规则" class="headerlink" title="1.Arrays.sort自定义排序规则"></a>1.<code>Arrays.sort</code>自定义排序规则</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> people.length;</span><br><span class="line">       List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="comment">// 自定义二维数组的排序规则： 首先按照数组的第一个元素进行从大到小排序，如果相同，按照第二元素从小到大排序</span></span><br><span class="line">       Arrays.sort(people , Comparator.comparingInt((<span class="type">int</span>[] a )-&gt; a[<span class="number">0</span>]).reversed().thenComparing(</span><br><span class="line">               (<span class="type">int</span>[] a) -&gt; a[<span class="number">1</span>]</span><br><span class="line">       ));</span><br><span class="line"></span><br><span class="line">       Arrays.sort(people, (a , b) -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])&#123;</span><br><span class="line">               <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       Arrays.sort(people , (a , b) -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])&#123;</span><br><span class="line">               <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">           System.out.println(people[i][<span class="number">0</span>] + <span class="string">&quot;:&quot;</span>+people[i][<span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 相当于此时已经按照身高排好序了，只需按照k进行插入即可</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span>[] person : people) &#123;</span><br><span class="line">           list.add(person[<span class="number">1</span>] , person);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[people.length][]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-大顶堆小顶堆的数组存储特点"><a href="#2-大顶堆小顶堆的数组存储特点" class="headerlink" title="2.大顶堆小顶堆的数组存储特点"></a>2.大顶堆小顶堆的数组存储特点</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 为简化计算，堆进行存储的时候数组下标也可从1开始，</span><br><span class="line">公式就调整为：父节点=i/2，左子节点=i*2，右子节点=i*2+1（i是当前节点对应的数组下标）</span><br></pre></td></tr></table></figure></div>

<p>例题：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-6aed45fd53b4b93a6497447f57ab4b0a_720w.webp"
                     
                ></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">代码答案如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        PriorityQueue&lt;Integer&gt; minQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a-b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] min = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            minQueue.offer(in.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 需要注意的是，优先队列来建立堆进行存储，要使用这个方法，不能进行手动赋值</span></span><br><span class="line">        Integer[] toArray = minQueue.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[n]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : toArray) &#123;</span><br><span class="line">            min[index++] = integer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 优先队列里面的元素：10</span></span><br><span class="line"><span class="comment">         * 优先队列里面的元素：23</span></span><br><span class="line"><span class="comment">         * 优先队列里面的元素：24</span></span><br><span class="line"><span class="comment">         * 优先队列里面的元素：26</span></span><br><span class="line"><span class="comment">         * 优先队列里面的元素：46</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (!minQueue.isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;优先队列里面的元素：&quot;</span>+minQueue.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 堆存储在数组中的结构为：</span></span><br><span class="line"><span class="comment">         * 堆在数组为：0</span></span><br><span class="line"><span class="comment">         * 堆在数组为：10</span></span><br><span class="line"><span class="comment">         * 堆在数组为：23</span></span><br><span class="line"><span class="comment">         * 堆在数组为：26</span></span><br><span class="line"><span class="comment">         * 堆在数组为：46</span></span><br><span class="line"><span class="comment">         * 堆在数组为：24</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : min) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;堆在数组为：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        in.nextLine();</span><br><span class="line">        <span class="keyword">while</span> (m-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 接下来的m行，需要分别对每一行进行判断</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">            String[] strings = str.split(<span class="string">&quot;\\s&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (str.contains(<span class="string">&quot;is the root&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">// 判断是不是头节点</span></span><br><span class="line">                <span class="keyword">if</span> (min[<span class="number">1</span>] == Integer.parseInt(strings[<span class="number">0</span>]))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;T&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (str.contains(<span class="string">&quot;are siblings&quot;</span>))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Integer.parseInt(strings[<span class="number">0</span>]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> Integer.parseInt(strings[<span class="number">2</span>]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (min[i] == x)&#123;</span><br><span class="line">                        a = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (min[i] == y)&#123;</span><br><span class="line">                        b = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(a/<span class="number">2</span> == b/<span class="number">2</span> ? <span class="string">&quot;T&quot;</span> : <span class="string">&quot;F&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (str.contains(<span class="string">&quot;is the parent of&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">// 判断是不是父节点  -- 判断x是y的父节点</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Integer.parseInt(strings[<span class="number">0</span>]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> Integer.parseInt(strings[<span class="number">5</span>]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n+<span class="number">1</span> ; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (min[i] == y)&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> i / <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> (min[f] == x)&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;T&quot;</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Integer.parseInt(strings[<span class="number">0</span>]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> Integer.parseInt(strings[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (min[i] == x)&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> i / <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> (min[f] == y)&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;T&quot;</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="3-Java读取文件，暴力分割矩阵"><a href="#3-Java读取文件，暴力分割矩阵" class="headerlink" title="3. Java读取文件，暴力分割矩阵"></a>3. <code>Java</code>读取文件，暴力分割矩阵</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:\\developer_tools\\idea\\java_code\\PTA\\src\\蓝桥杯\\day5\\data.txt&quot;</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path));</span><br><span class="line">        <span class="type">int</span>[][] ints = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">30</span>][<span class="number">20</span>];</span><br><span class="line">        String line;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            String[] strings = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class="line">                ints[index][i] = Integer.parseInt(strings[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">   <span class="comment">//         按行读取，读取的每一行</span></span><br><span class="line"><span class="comment">//            System.out.println(line);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 暴力破解，求出5行5列的子矩阵的最大值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= ints.length - <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= ints[<span class="number">0</span>].length - <span class="number">5</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 执行5次，从i 到后面5行</span></span><br><span class="line">                <span class="comment">// 从j 到后面 5 行</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">temp</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">5</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; <span class="number">5</span>; l++) &#123;</span><br><span class="line">                        temp += ints[k+i][l+j];</span><br><span class="line">                        System.out.print(ints[k+i][l+j] +<span class="string">&quot; &quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">                res = Math.max(res , temp);</span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span>+i + <span class="string">&quot;行,第&quot;</span> + j+<span class="string">&quot;列，构造结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="4-Java算法模板"><a href="#4-Java算法模板" class="headerlink" title="4. Java算法模板"></a>4. Java算法模板</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求最大公约数模板</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b )</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a % b;</span><br><span class="line">        <span class="keyword">while</span> (c != <span class="number">0</span>)&#123;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">            c = a % b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 求最小公倍数模板</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findLCM</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b / gcd(a , b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分解质因数模板 -- 将一个数分解成诺干质数相乘</span></span><br><span class="line"><span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">List</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(i);</span><br><span class="line">            n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转化指定格式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">factorization</span><span class="params">(<span class="type">int</span> n )</span> &#123;</span><br><span class="line">		System.out.print(n+<span class="string">&quot;=&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt;= n ; i++) &#123;</span><br><span class="line">			<span class="keyword">while</span>(n % i == <span class="number">0</span>) &#123; <span class="comment">// 表示当前的i可以被n整除，是他的倍数</span></span><br><span class="line">				System.out.print(i);</span><br><span class="line">				n /= i;</span><br><span class="line">				<span class="keyword">if</span>(n != <span class="number">1</span>) &#123;  <span class="comment">// 这个地方表示目前n不是最后一个</span></span><br><span class="line">					<span class="comment">// 表示不是最后一个</span></span><br><span class="line">					System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断一个数是不是质数模板</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(num &lt;= <span class="number">1</span>) &#123;    <span class="comment">// 小于等于1的都不是质数</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt;= Math.sqrt(num) ; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;  <span class="comment">// 表示存在了其他因数，肯定不是质数，返回即可</span></span><br><span class="line">				<span class="comment">// 质数定义是：只存在1或者他本身两个因数的数字，才属于质数</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> x , <span class="type">int</span> y )</span> &#123;</span><br><span class="line">		<span class="type">double</span> <span class="variable">res</span>  <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(y % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">				res *= x;</span><br><span class="line">			&#125;</span><br><span class="line">			y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">			x *= x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="5-回溯之切割问题"><a href="#5-回溯之切割问题" class="headerlink" title="5. 回溯之切割问题"></a>5. 回溯之切割问题</h3><p>问题1 ： 力扣<a class="link"   href="https://leetcode.cn/problems/palindrome-partitioning/" >131. 分割回文串 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">代码如下：</span><br><span class="line">	List&lt;List&lt;String&gt;&gt; res1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span> || s == <span class="literal">null</span>) <span class="keyword">return</span> res1;</span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backTracking(s , <span class="number">0</span> , path);</span><br><span class="line">        <span class="keyword">return</span> res1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String s, <span class="type">int</span> startIndex , List path )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.length())&#123;</span><br><span class="line">            res1.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始进行切割</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f(s, startIndex , i ))&#123;</span><br><span class="line">                <span class="comment">// 表示这一段是回文串</span></span><br><span class="line">                path.add(s.substring(startIndex , i+<span class="number">1</span>));</span><br><span class="line">                <span class="comment">// 下一次的切割，从i当前执行的下一个开始切割哦</span></span><br><span class="line">                backTracking(s , i + <span class="number">1</span> , path);</span><br><span class="line">                <span class="comment">// 进行回溯</span></span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">f</span><span class="params">(String s , <span class="type">int</span> start , <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="comment">// 判断是不是回文串</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(start) != s.charAt(end))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>问题2  力扣<a class="link"   href="https://leetcode.cn/problems/restore-ip-addresses/" >93. 复原 IP 地址 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">代码如下：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &gt; <span class="number">12</span> ) <span class="keyword">return</span> res;</span><br><span class="line">        backTrack(s , <span class="number">0</span> , <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//   使用了逗号的数量进行回溯的结束条件---- 这一点确实巧妙</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(String s, <span class="type">int</span> startIndex, <span class="type">int</span> pointNum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pointNum == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(s , startIndex , s.length() - <span class="number">1</span>))&#123;</span><br><span class="line">                res.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(s , startIndex , i))&#123;</span><br><span class="line">                <span class="comment">// 表示此时是一个合法的: 需要在i后面的位置添加一个.</span></span><br><span class="line">                s = s.substring(<span class="number">0</span> , i + <span class="number">1</span> ).concat(<span class="string">&quot;.&quot;</span>).concat(s.substring(i+<span class="number">1</span>));</span><br><span class="line">                pointNum++;</span><br><span class="line">                <span class="comment">// 因为这个地方插入了一个逗号，所以下一个地方的是i+2</span></span><br><span class="line">                backTrack(s , i+<span class="number">2</span>,pointNum);</span><br><span class="line">                <span class="comment">// 下面两个地方是进行回溯的地方</span></span><br><span class="line">                pointNum--;</span><br><span class="line">                s = s.substring(<span class="number">0</span> , i+<span class="number">1</span>).concat(s.substring(i+<span class="number">2</span>));<span class="comment">//回溯</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断从start - end 两个边界都可以取到，是不是可以满足条件</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(start) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end)&#123;</span><br><span class="line">            <span class="comment">// 表示此时这个字符长度不为1，但是他是零开头的，不合法，返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">//    下面这个使用了累乘，来计算最终结果的访问大小</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end ; i++) &#123;</span><br><span class="line">            <span class="comment">// 遇到非数字字符不合法，直接返回哦</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span> || s.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num * <span class="number">10</span> + (s.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">255</span>)&#123;</span><br><span class="line">                <span class="comment">// 表示超过了数字的范围，直接返回哦</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示上面的条件都不是，此时就是一个合法的ip地址的字符串，从start到end</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="6-Java中快速读写的代码"><a href="#6-Java中快速读写的代码" class="headerlink" title="6. Java中快速读写的代码"></a>6. Java中快速读写的代码</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main_StreamTokenzier</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">StreamTokenizer</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)));</span><br><span class="line">    <span class="comment">// 注意点就是，每一次读取之前都要 sc.nextToken() </span></span><br><span class="line">    <span class="comment">//  然后常用的只有两个方法，读取字符串和读取数字（默认double类型）两个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        sc.nextToken();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) sc.nval;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            set.clear();</span><br><span class="line">            sc.nextToken();</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (<span class="type">int</span>) sc.nval;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">                sc.nextToken();</span><br><span class="line">                set.add((<span class="type">int</span>)sc.nval);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(index++ , <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(set));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        for (Map.Entry&lt;Integer, HashSet&lt;Integer&gt;&gt; entry : map.entrySet()) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue().toString());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="7-指定字符数组长度转化为字符串"><a href="#7-指定字符数组长度转化为字符串" class="headerlink" title="7. 指定字符数组长度转化为字符串"></a>7. 指定字符数组长度转化为字符串</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String.valueOf(char[] chars , 0 , num) 这个方法的作用就是将chars字符数组，从chars[0]开始，取长度为num个元素，转化为字符串 	   </span></span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line">        System.out.println(String.valueOf(chars , <span class="number">0</span> , <span class="number">2</span>));</span><br><span class="line">        System.out.println(String.valueOf(chars , <span class="number">0</span> , <span class="number">1</span>));</span><br><span class="line">        System.out.println(String.valueOf(chars , <span class="number">0</span> , <span class="number">3</span>));</span><br><span class="line">        System.out.println(String.valueOf(chars , <span class="number">0</span> , <span class="number">5</span>));</span><br></pre></td></tr></table></figure></div>

<h3 id="8-KMP算法模板"><a href="#8-KMP算法模板" class="headerlink" title="8. KMP算法模板"></a>8. KMP算法模板</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 下面演示KMP算法 : 在s1中找到s2字符串首次出现的位置</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;zhuzhuzhuhehehezhuhezhuhe&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;zhuhe&quot;</span>;</span><br><span class="line">		System.out.println(f_KMP(s1, s2));  <span class="comment">// 6</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f_KMP</span><span class="params">(String s1 , String s2)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[s2.length()];</span><br><span class="line">		getNext(s2 , next);</span><br><span class="line"><span class="comment">//		System.out.println(Arrays.toString(next));</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s1.charAt(i) != s2.charAt(j)) &#123;</span><br><span class="line">				j = next[j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (j == s2.length()) &#123;</span><br><span class="line">				<span class="comment">// 这个地方表示s2已经全部匹配上了:返回下标即可</span></span><br><span class="line">				<span class="keyword">return</span> i - s2.length() + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 匹配不上返回-1</span></span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 求next数组，采用不减1的操作</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(String s , <span class="type">int</span>[] next)</span> &#123;</span><br><span class="line">		next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; next.length ; i++) &#123;</span><br><span class="line">			<span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">				<span class="comment">// 如果找到不相同的，就看他的前一个</span></span><br><span class="line">				j = next[j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			next[i] = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="9-Java中大数的基本使用"><a href="#9-Java中大数的基本使用" class="headerlink" title="9. Java中大数的基本使用"></a>9. Java中大数的基本使用</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加减乘除取模运算</span></span><br><span class="line">System.out.println(BigInteger.valueOf(<span class="number">3</span>).add(BigInteger.valueOf(<span class="number">2</span>)));</span><br><span class="line">System.out.println(BigInteger.valueOf(<span class="number">3</span>).subtract(BigInteger.valueOf(<span class="number">2</span>)));</span><br><span class="line">System.out.println(BigInteger.valueOf(<span class="number">3</span>).multiply(BigInteger.valueOf(<span class="number">2</span>)));</span><br><span class="line">System.out.println(BigInteger.valueOf(<span class="number">3</span>).divide(BigInteger.valueOf(<span class="number">3</span>)));</span><br><span class="line">System.out.println(BigInteger.valueOf(<span class="number">14</span>).mod(BigInteger.valueOf(<span class="number">3</span>)));</span><br><span class="line"><span class="comment">// 案例--大数的阶乘</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">res</span> <span class="operator">=</span> BigInteger.ONE;	 </span><br><span class="line">Scanner in=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"> <span class="comment">// 计算n的阶乘的方法     </span></span><br><span class="line"><span class="type">int</span> n=in.nextInt();</span><br><span class="line"><span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">	res = res.multiply(BigInteger.valueOf(n));</span><br><span class="line">	n--;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(res);</span><br><span class="line"><span class="comment">// 进制转化内置方法</span></span><br><span class="line"><span class="comment">// 将一个数转化为2进制，8进制，16进制</span></span><br><span class="line">System.out.println(Integer.toString(<span class="number">255</span> , <span class="number">2</span>));</span><br><span class="line">System.out.println(Integer.toString(<span class="number">255</span> , <span class="number">8</span>));</span><br><span class="line">System.out.println(Integer.toString(<span class="number">255</span> , <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将二进制，八进制 ， 16进制的字符串转化为十进制的方法</span></span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;11111111&quot;</span> , <span class="number">2</span>));</span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;11111111&quot;</span> , <span class="number">8</span>));</span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;11111111&quot;</span> , <span class="number">16</span>));</span><br></pre></td></tr></table></figure></div>

<h3 id="10-终要面对-Dijkstra算法"><a href="#10-终要面对-Dijkstra算法" class="headerlink" title="10 终要面对-Dijkstra算法"></a>10 终要面对-Dijkstra算法</h3><hr>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">必要学会版 V1.0</span><br></pre></td></tr></table></figure></div>

<p>GitHub源代码: <a class="link"   href="https://github.com/yuanjiejiahui/Dijkstra" >https://github.com/yuanjiejiahui/Dijkstra <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ol>
<li>算法常用于处理单源出发到其他所有节点的最短路径问题，适用于不含有负权重的有向和无向图</li>
<li>算法采用贪心策略，具体代码借助堆来优化算法</li>
</ol>
<p><a class="link"   href="https://leetcode.cn/problems/network-delay-time/description/" >力扣链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://acking-you.gitee.io/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/" >相关博文 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"> 	    List&lt;<span class="type">int</span>[]&gt;[] g = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            g[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建图，使用list数组来进行构建哦</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] time : times)&#123;</span><br><span class="line">            <span class="comment">// 因为times数组中的下标从1开始的哦</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> time[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> time[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> time[<span class="number">2</span>];</span><br><span class="line">            g[u].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;v , w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> Integer.MAX_VALUE / <span class="number">2</span>; <span class="comment">// 初始化dist数组需要使用哦</span></span><br><span class="line">        <span class="comment">// 一共n个节点哦</span></span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dist , INF);</span><br><span class="line">        dist[k - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 表示从当前节点到当前节点的最短路径为0，其他都为无限远</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a , b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123; <span class="number">0</span> , k -  <span class="number">1</span>&#125;); <span class="comment">//小顶堆，根据数组的第一个元素进行排序，用来记录从出发顶点，到达他所能到达的其他所有顶点的集合</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 每一次处理距离出发顶点最近的顶点哦</span></span><br><span class="line">            <span class="type">int</span>[] p = pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">currDist</span> <span class="operator">=</span> p[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> p[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (dist[x] &lt; currDist)&#123;  <span class="comment">// 表示此时不用更新dist[x]了</span></span><br><span class="line">                <span class="comment">// 表示此时dist[y] ，到达y的距离已经是最小值了，不需要进行处理</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 然后开始处理: g[y] 得到所有从y出发的顶点，能到达的下一个顶点，和他们的距离哦</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[] e : g[x])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> e[<span class="number">0</span>];<span class="comment">// x到达的下一个顶点y</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> dist[x] + e[<span class="number">1</span>];  <span class="comment">// 经过x顶点到达y的路径距离</span></span><br><span class="line"><span class="comment">// 经过x和不经过x的两端距离进行比较，取出最小值即可</span></span><br><span class="line">                <span class="keyword">if</span> (d &lt; dist[y])&#123;  </span><br><span class="line">                    dist[y] = d;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;d , y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res = Math.max(res , dist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INF ? -<span class="number">1</span> :res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="11-多次见面-并查集"><a href="#11-多次见面-并查集" class="headerlink" title="11 多次见面-并查集"></a>11 多次见面-并查集</h3><p><a class="link"   href="https://blog.csdn.net/haduwi/article/details/121350586" >附相关博文1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">我是不想见你的，奈何多次要见</span><br></pre></td></tr></table></figure></div>

<ol>
<li>题单1-<a class="link"   href="https://leetcode.cn/problems/find-if-path-exists-in-graph/" >寻找图中是否存在路径 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPath</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(source == destination) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            uf.union(edge[<span class="number">0</span>] , edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 总结： 并且集可以用来判断连通问题</span></span><br><span class="line">        <span class="keyword">return</span> uf.connected(source , destination);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] sz; <span class="comment">// 存储每个根节点所在组的数量个数</span></span><br><span class="line">    <span class="type">int</span> count ;  <span class="comment">// 记录分组个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.sz = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p , <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="comment">// 判断pq是否在同一个组内</span></span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找p的父节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p == parent[p])&#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p , <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="comment">// 将这两个数组进行在一个组里面</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pRoot</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">qRoot</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 现在不能简单的进行合并</span></span><br><span class="line"><span class="comment">//        parent[pRoot] = qRoot;</span></span><br><span class="line">        <span class="keyword">if</span> (sz[pRoot] &lt; sz[qRoot])&#123;</span><br><span class="line">            <span class="comment">// 将较小的合并到较大的上面</span></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            sz[qRoot] += sz[pRoot];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 此时qRoot较小，将较小的合并到大的上面</span></span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            sz[pRoot] += sz[qRoot];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分组数量减减</span></span><br><span class="line">        <span class="built_in">this</span>.count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>题单2-<a class="link"   href="https://leetcode.cn/problems/number-of-provinces/" >547. 省份数量 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> isConnected.length;</span><br><span class="line">        <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 表示直接连通哦</span></span><br><span class="line">                <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    uf.union(i , j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省份的数量，其实就是最后的分组数量</span></span><br><span class="line">        <span class="keyword">return</span> uf.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPath</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(source == destination) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            uf.union(edge[<span class="number">0</span>] , edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connected(source , destination);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] sz; <span class="comment">// 存储每个根节点所在组的数量个数</span></span><br><span class="line">    <span class="type">int</span> count ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.sz = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p , <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="comment">// 判断pq是否在同一个组内</span></span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找p的父节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p == parent[p])&#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p , <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="comment">// 将这两个数组进行在一个组里面</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pRoot</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">qRoot</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        parent[pRoot] = qRoot;</span></span><br><span class="line">        <span class="keyword">if</span> (sz[pRoot] &lt; sz[qRoot])&#123;</span><br><span class="line">            <span class="comment">// 将较小的合并到较大的上面</span></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            sz[qRoot] += sz[pRoot];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 此时qRoot较小，将较小的合并到大的上面</span></span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            sz[pRoot] += sz[qRoot];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分组数量减减</span></span><br><span class="line">        <span class="built_in">this</span>.count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>总结UF（并查集）模板</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] parent ;</span><br><span class="line">    <span class="type">int</span>[] rank ; <span class="comment">// 记录就是当前父节点他组内的个数</span></span><br><span class="line">    <span class="type">int</span> count ; <span class="comment">// 记录目前一共有多少个分组数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="built_in">this</span>.rank = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 初始的情况下</span></span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span>&#123;</span><br><span class="line">        <span class="comment">// 查找p节点的父节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[p] == p)&#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p , <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pRoot</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">qRoot</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">return</span> pRoot == qRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p , <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pRoot</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">qRoot</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot) <span class="keyword">return</span>;  <span class="comment">// 表示此时已经连通了，不需要在连通了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进行连通操作： 优化步骤在于，将较短的树连接到较大的树上面</span></span><br><span class="line">        <span class="keyword">if</span> (rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot] += rank[pRoot];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            rank[pRoot] += rank[qRoot];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 因为此时将两个分组合并到一个分组上面了，故分组数量需要减减</span></span><br><span class="line">        <span class="built_in">this</span>.count --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>4 . <a class="link"   href="https://leetcode.cn/problems/7LpjUW/" >LCR 118. 冗余连接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Scheme"><figure class="iseeu highlight scheme"><table><tr><td class="code"><pre><span class="line">题目：在一个数中新添加了一条边，然后给你一个边的二维数组，请你求出，去掉哪一条边之后，仍然使得：剩余部分是一个有着 n 个节点的树（这一句话表示：删除一条边之后 ， n个节点仍然是连通的）。如果有多个答案，则返回数组 edges 中最后出现的边。</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findRedundantConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edges.length;</span><br><span class="line">    <span class="comment">//  UF类模板此处进行省略</span></span><br><span class="line">        <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            <span class="comment">// 题目中节点编号从1开始到n，故不要忘记减一</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> edge[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> edge[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (uf.connected(i , j) == <span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="comment">// 表示此时已经连接了</span></span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                uf.union(i , j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="12-再见深搜"><a href="#12-再见深搜" class="headerlink" title="12 再见深搜"></a>12 再见深搜</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">最优解不是使用dfs，为复习dfs，选择dfs</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://leetcode.cn/problems/search-a-2d-matrix-ii/" >附上力扣题单 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span>[][] direction = &#123;&#123;<span class="number">0</span> , <span class="number">1</span>&#125; , &#123;<span class="number">1</span> , <span class="number">0</span>&#125; , &#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span>[][] flag = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(matrix,<span class="number">0</span>,<span class="number">0</span>,target , flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] matrix , <span class="type">int</span> i , <span class="type">int</span> j , <span class="type">int</span> target , <span class="type">boolean</span>[][] flag)</span>&#123;</span><br><span class="line"> <span class="comment">// 先判断索引不合法，和已经访问过的，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= matrix.length || j &lt; <span class="number">0</span> || j &gt;= matrix[<span class="number">0</span>].length || flag[i][j]) &#123;</span><br><span class="line">            <span class="comment">// 索引越界或已访问过，返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主要这个逻辑来进行判断，是不是存在目标值</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] cur : direction) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur[<span class="number">0</span>] + i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> cur[<span class="number">1</span>] + j;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果存在true，表示找到了，返回true即可</span></span><br><span class="line">            <span class="keyword">if</span> (dfs(matrix, x, y, target, flag)) &#123;</span><br><span class="line">                <span class="comment">// 如果在某个方向找到目标值，返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到这个地方表示所有的方向都访问过了，但是没有找到，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="13-龟兔赛跑算法–快慢指针的使用"><a href="#13-龟兔赛跑算法–快慢指针的使用" class="headerlink" title="13 龟兔赛跑算法–快慢指针的使用"></a>13 龟兔赛跑算法–快慢指针的使用</h3><p><a class="link"   href="https://zhuanlan.zhihu.com/p/496079620" >参考文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Sas"><figure class="iseeu highlight sas"><table><tr><td class="code"><pre><span class="line">Floyd判圈算法</span><br><span class="line">			- 解决是否存在环的问题</span><br><span class="line">			- 解决求环的入口的问题</span><br><span class="line">			- 解决求环的长度的问题</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://leetcode.cn/problems/linked-list-cycle/" >141. 环形链表 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 判断是否存在环</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">     <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">     <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">     <span class="keyword">while</span>(slow != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">         fast = fast.next.next;</span><br><span class="line">         slow = slow.next;</span><br><span class="line">         <span class="keyword">if</span>(fast == slow)&#123; <span class="comment">//表示相遇了</span></span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://leetcode.cn/problems/linked-list-cycle-ii/" >142. 环形链表 II <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 求环的起点</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="comment">// 此时表示存在环，并且他们相遇在环的某一位置上哦</span></span><br><span class="line">                <span class="keyword">while</span> (res != slow)&#123;</span><br><span class="line">                    res = res.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到这个地方表示不存在环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>对于求环的长度问题暂未遇到。思路是：假设存在环，快慢指针第一次相遇的位置一定在环的某个位置上，然后让快指针不动，慢指针走一圈，引入一个变量计算长度，当慢指针与快指针再次相遇的时候，刚好为环的长度。</p>
<h3 id="14-Java数学类的三个方法"><a href="#14-Java数学类的三个方法" class="headerlink" title="14 Java数学类的三个方法"></a>14 <code>Java</code>数学类的三个方法</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">一定要注意，题目中要求的数据范围：是四舍五入，还是什么</span><br></pre></td></tr></table></figure></div>

<ol>
<li>**Math.ceil(double a)**：向上取整方法。返回大于或等于参数的最小整数。如果参数是正数，则返回大于或等于该参数的最小整数；如果参数是负数，则返回小于或等于该参数的最大整数。返回值类型为<code>double</code>。</li>
<li>**Math.floor(double a)**：向下取整方法。返回小于或等于参数的最大整数。如果参数是正数，则返回不大于该参数的最大整数；如果参数是负数，则返回大于或等于该参数的最小整数。返回值类型为<code>double</code>。</li>
<li>**Math.round(float a) 和 Math.round(double a)**：四舍五入方法。返回最接近参数的整数。对于<code>float</code>类型的参数，返回<code>int</code>类型的整数；对于<code>double</code>类型的参数，返回<code>long</code>类型的整数。这是标准的四舍五入操作，即如果待舍入数的小数部分大于等于0.5，则向上取整；如果小于0.5，则向下取整。</li>
</ol>
<h3 id="15-再学完美、完全二叉树"><a href="#15-再学完美、完全二叉树" class="headerlink" title="15 再学完美、完全二叉树"></a>15 再学完美、完全二叉树</h3><p><a class="link"   href="https://blog.csdn.net/lyl123_456/article/details/102494659" >相关博文1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>								<a class="link"   href="https://blog.csdn.net/weixin_52055811/article/details/129966800" >相关博文2 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ol>
<li>二叉树的性质</li>
</ol>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">（1）若二叉树的层次从0开始，则在二叉树的第i层至多有2^i个结点(i&gt;=0)。</span><br><span class="line">（2）高度为k的二叉树最多有2^(k+1) - 1个结点(k&gt;=-1)。 (空树的高度为-1)</span><br><span class="line"><span class="code">	度：结点所拥有的子树个数称为结点的度(Degree)</span></span><br><span class="line"><span class="code">	叶子（终端结点）：没有孩子的结点(也就是度为0的结点)称为叶子(Leaf)或终端结点</span></span><br><span class="line"><span class="code">（3）对任何一棵二叉树，如果其叶子结点(度为0)数为m, 度为2的结点数为n, 则m = n + 1。</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>完美二叉树（满二叉树）</li>
</ol>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">一个深度为k(&gt;=-1)且有2^(k+1) - 1个结点的二叉树称为完美二叉树。 </span><br><span class="line">(注： 国内的数据结构教材大多翻译为&quot;满二叉树&quot;)。</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>完全二叉树</li>
</ol>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>完满二叉树</li>
</ol>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">所有非叶子结点的度都是2。（只要你有孩子，你就必然是有两个孩子。）</span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li>完满(Full)二叉树 vs 完全(Complete)二叉树 vs 完美(Perfect)二叉树</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img-blog.csdnimg.cn/20191011090955281.png"
                     
                ></p>
<p><a class="link"   href="https://pintia.cn/problem-sets/1779778307878768640/exam/problems/1779778385079140362?type=7&page=0" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码如下</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> n , index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] nums , res;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = in.nextInt();</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            nums[i] = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            ans.append(res[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans.toString().trim());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后模拟后序遍历的顺序</span></span><br><span class="line">        dfs(i * <span class="number">2</span>); <span class="comment">// 左</span></span><br><span class="line">        dfs(i * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 右</span></span><br><span class="line">        <span class="comment">// 然后处理当前节点</span></span><br><span class="line">        res[i] = nums[index++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="16-HashMap重写排序"><a href="#16-HashMap重写排序" class="headerlink" title="16 HashMap重写排序"></a>16 HashMap重写排序</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap 根据value进行排序</span></span><br><span class="line"><span class="comment">// 举例： 首先按照value进行从大到小的方式排序，然后如果value相同，则按照key从小到大排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main_</span>测试 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;b&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;a&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;c&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;d&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = hashMap.entrySet();</span><br><span class="line">        <span class="comment">// 转换为列表</span></span><br><span class="line">        List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(hashMap.entrySet());</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        list.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> &#123;</span><br><span class="line">                <span class="comment">// 先比较value，如果value相同再比较key</span></span><br><span class="line">                <span class="keyword">if</span> (o2.getValue() - o1.getValue() != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> o2.getValue() - o1.getValue();</span><br><span class="line"><span class="comment">//                    return valueComparison;</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// value相同才按照key从小到大的方式进行排序</span></span><br><span class="line">                    <span class="keyword">return</span> o1.getKey().compareTo(o2.getKey()); <span class="comment">// 从小到大排序</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 输出排序后的结果</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : list) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-f922496ecd3ef9eec758cb0767f5725d_720w.webp"
                     
                ></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Flume的开发</title>
    <url>/2024/04/01/Flume%E7%9A%84%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="大数据相关技术学习"><a href="#大数据相关技术学习" class="headerlink" title="大数据相关技术学习"></a>大数据相关技术学习</h2><h3 id="1-flume特点和主要作用"><a href="#1-flume特点和主要作用" class="headerlink" title="1.flume特点和主要作用"></a>1.flume特点和主要作用</h3><ol>
<li>动态采集，流式处理</li>
<li>只能处理log data，（视频，音频等不能处理）</li>
<li>将本地服务器日志文件上传到hdfs（不手动上传的作用就是：实时读取）</li>
</ol>
<h3 id="2-flume的使用案例1"><a href="#2-flume的使用案例1" class="headerlink" title="2.flume的使用案例1"></a>2.flume的使用案例1</h3><ul>
<li>使用flume监听端口</li>
</ul>
<ol>
<li><p>编写配置文件</p>
<div class="highlight-container" data-rel="Coffeescript"><figure class="iseeu highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example.conf: A single-node Flume configuration</span></span><br><span class="line"><span class="comment"># Name the components on this agent</span></span><br><span class="line">a1.sources = r1 </span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Describe/configure the source</span></span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = localhost</span><br><span class="line">a1.sources.r1.port = <span class="number">44444</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Describe the sink</span></span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use a channel which buffers events in memory</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = <span class="number">1000</span></span><br><span class="line">a1.channels.c1.transactionCapacity = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bind the source and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>进行启动</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一种写法：</span><br><span class="line">[atguigu@hadoop102 flume]$ bin/flume-ng agent --conf conf/ --name </span><br><span class="line">a1 --conf-file job/flume-netcat-logger.conf -Dflume.root.logger=INFO,console</span><br><span class="line"># 第二种写法：</span><br><span class="line">[atguigu@hadoop102 flume]$ bin/flume-ng agent -c conf/ -n a1 -f </span><br><span class="line">job/flume-netcat-logger.conf -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>借助nc开启客户端</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc localhost 44444</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>此时即可监控到传输信息，信息格式如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">2024-03-11 19:38:04,410 INFO sink.LoggerSink: Event: &#123; headers:&#123;&#125; body: 6E 69 68 61 6F 79 61                            nihaoya &#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>数据采集</tag>
        <tag>大数据技术</tag>
        <tag>Fluem</tag>
      </tags>
  </entry>
  <entry>
    <title>天梯赛总结</title>
    <url>/2024/04/20/%E5%A4%A9%E6%A2%AF%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ul>
<li>刚打完天梯赛，先来安慰一下自己，结果不重要，享受过程即可</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">总结一下：</span><br><span class="line">	①基础不够牢靠，一百分的基础题，扣了13分，语文还需要加强理解</span><br><span class="line">	②心态不够好，比赛期间走神了，同时虽然外部环境干扰很多，但自己的心态还需要练</span><br><span class="line">	③进阶题目写的不足，一道鸭蛋，导致肯定与国三无缘了</span><br><span class="line">唉，唉</span><br><span class="line">距离国三还有20分的差距，同时写题还是太慢</span><br><span class="line">加油吧，加油吧</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>杂文</tag>
        <tag>比赛</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark SQL</title>
    <url>/2024/04/15/Spark-SQL/</url>
    <content><![CDATA[<h2 id="Spark-SQL"><a href="#Spark-SQL" class="headerlink" title="Spark SQL"></a>Spark SQL</h2><h3 id="1-dataframe类型的详解"><a href="#1-dataframe类型的详解" class="headerlink" title="1. dataframe类型的详解"></a>1. dataframe类型的详解</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/v2-3d4646adbdc8dffdbdf5e4d5471d0065_r.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-9973137e99ffcba2e005275e7ccee435_720w.webp"
                     
                ></p>
<h3 id="2-dataframe的创建"><a href="#2-dataframe的创建" class="headerlink" title="2. dataframe的创建"></a>2. dataframe的创建</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-896a75d1c541fa7ea3e48ec796a223a2_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-d2bde66b53464be453bc0146b41e6c36_720w.webp"
                     
                ></p>
<h3 id="3-dataframe的使用"><a href="#3-dataframe的使用" class="headerlink" title="3. dataframe的使用"></a>3. dataframe的使用</h3><h4 id="3-1-使用df中的方法进行操作（dsl方法-—-df提供）"><a href="#3-1-使用df中的方法进行操作（dsl方法-—-df提供）" class="headerlink" title="3.1 使用df中的方法进行操作（dsl方法 — df提供）"></a>3.1 使用df中的方法进行操作（dsl方法 — df提供）</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">df数据的查询</span><br><span class="line"><span class="number">1.</span> 指定查询的字段数据(指定字段的字符串格式，结果会返回一个新的df，可以使用df.show()查看</span><br><span class="line">	df.select(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="number">2.</span> 指定多个字段<span class="comment">--一次查询多个字段（将字段放入列表中，注意需要使用字符串的形式）</span></span><br><span class="line">	df.select([<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="number">3.</span> 直接使用df进行查询</span><br><span class="line">	df.select(df[<span class="string">&#x27;name&#x27;</span>],df[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="number">4.</span> 展示所有数据<span class="comment">---&gt; 直接使用df.show() 即可将所有结果查询出来</span></span><br><span class="line">	df.show()   # 此时就是对所有字段进行处理</span><br><span class="line"><span class="number">5.</span> df.show(num)  可以指定展示多少条数据，默认是<span class="number">20</span>条数据，同时<span class="keyword">show</span>()方法不会返回新的df</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">df的条件过滤</span><br><span class="line"><span class="number">1.</span> df.where(<span class="string">&#x27;age &gt; 20&#x27;</span>) # 相当于将所有数据都进行过滤，返回一个新的df</span><br><span class="line"><span class="number">2.</span> df.where(<span class="string">&#x27;age &gt; 20&#x27;</span>) # 相当于将所有数据都进行过滤，返回一个新的df，并且，没有指定行</span><br><span class="line">	相当于得到年龄大于<span class="number">20</span>的全部过滤出来</span><br><span class="line"><span class="number">3.</span> 多个条件的与或非（<span class="keyword">and</span> , <span class="keyword">or</span> , ）</span><br><span class="line">	df.where(<span class="string">&#x27;age &gt;= 20 and gender = &quot;男&quot;&#x27;</span>) # 注意单双引号的嵌套使用</span><br><span class="line">	</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>（分组操作，一般结合聚合操作）的操作</span><br><span class="line"><span class="number">1.</span> df.groupby(<span class="string">&#x27;gender&#x27;</span>).<span class="built_in">sum</span>(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">	# 相当于对性别进行分组操作，同时对两个组中的年龄进行累加</span><br><span class="line">	# <span class="keyword">select</span> gender , <span class="built_in">sum</span>(<span class="string">&#x27;age&#x27;</span>) <span class="keyword">from</span> df <span class="keyword">group</span> <span class="keyword">by</span> gender</span><br><span class="line">	# 常见的聚合函数：<span class="built_in">sum</span>()，<span class="built_in">avg</span>() , <span class="built_in">min</span>() , <span class="built_in">max</span>()</span><br><span class="line"><span class="number">2.</span> 对于多个分组字段的使用，和进行查询的时候一样，使用一个列表进行</span><br><span class="line">	# 相当于先对性别进行一个分组，然后在两个性别中在对每一个科目在进行一个分组</span><br><span class="line">	df.groupby([<span class="string">&#x27;gender , cls&#x27;</span>]).<span class="built_in">avg</span>(<span class="string">&#x27;age&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">分组后的数据过滤</span><br><span class="line"><span class="number">1.</span> # 注意的点就是分组后的过滤，也不需要使用<span class="keyword">having</span>，而是同样使用<span class="keyword">where</span></span><br><span class="line">	df.groupby(<span class="string">&#x27;gender&#x27;</span>).<span class="built_in">sum</span>(<span class="string">&#x27;age&#x27;</span>).<span class="keyword">where</span>(<span class="string">&#x27;sum(age) &gt; 80&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">排序操作 orderBy()</span><br><span class="line"><span class="number">1.</span> df.orderBy(<span class="string">&#x27;age&#x27;</span>) </span><br><span class="line">	# 默认是升序排序,按照年龄进行升序排序</span><br><span class="line">	# 返回一个新的df</span><br><span class="line">	# 如果需要降序，就传入一个参数，进行降序排序</span><br><span class="line">	df.orderBy(<span class="string">&#x27;age&#x27;</span>,ascending <span class="operator">=</span> <span class="literal">False</span>)</span><br><span class="line"><span class="number">2.</span> 多字段排序</span><br><span class="line">	# 如果需要多个字段进行排序，可以使用列表</span><br><span class="line">	# 先按照age进行排序，如果年龄相同，就按照id进行从小到大进行排序</span><br><span class="line">	df.orderBy([<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line"><span class="number">3.</span> （多字段是按照一个排序规则进行操作）</span><br><span class="line">注意点就是，不能指定一个字段进行升序，一个降序。也就是说，和<span class="keyword">sql</span>里面是一样的。</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">指定返回数量 limit()</span><br><span class="line"><span class="number">1.</span> # 返回指定数量的数据</span><br><span class="line">   # 返回一个新的df</span><br><span class="line">	df.limit(<span class="number">5</span>)</span><br><span class="line">	</span><br></pre></td></tr></table></figure></div>

<h4 id="3-2-使用sql语句进行操作（sql语句—sparkSession提供）"><a href="#3-2-使用sql语句进行操作（sql语句—sparkSession提供）" class="headerlink" title="3.2 使用sql语句进行操作（sql语句—sparkSession提供）"></a>3.2 使用sql语句进行操作（sql语句—sparkSession提供）</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-8d036e7f21c29ee7acc86b9354c7b5cf_720w.webp"
                     
                ></p>
<h4 id="3-3-关联的操作"><a href="#3-3-关联的操作" class="headerlink" title="3.3 关联的操作"></a>3.3 关联的操作</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">join</span>的关联操作</span><br><span class="line"><span class="number">1.</span> 内关联 </span><br><span class="line"><span class="number">2.</span> 左关联 ： 左边的数据全部展示，如果有相同的id，右边表的数据也会展示</span><br><span class="line"><span class="number">3.</span> 右关联</span><br></pre></td></tr></table></figure></div>



<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-550a1afb4cb03613679d0e1069c26979_720w.webp"
                     
                ></p>
<h4 id="3-4-df数据的缓存和checkpoint"><a href="#3-4-df数据的缓存和checkpoint" class="headerlink" title="3.4 df数据的缓存和checkpoint"></a>3.4 df数据的缓存和checkpoint</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 缓存使用方法：</span></span><br><span class="line">	<span class="comment"># 进行缓存</span></span><br><span class="line">	df.persist()</span><br><span class="line">	<span class="comment"># 后序在进行计算时，如果计算错误就直接从缓存中读取</span></span><br><span class="line">	<span class="comment"># 缓存的级别：默认有限缓存到内存中，内存不足缓存到磁盘上</span></span><br><span class="line">    new_df = df.where(<span class="string">&#x27;id &gt; 1&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># checkpoint的作用：</span></span><br><span class="line"><span class="comment"># checkpoint的意思就是建立检查点,类似于快照,例如在spark计算里面 计算流程DAG特别长,服务器需要将整个DAG计算完成得出结果,但是如果在这很长的计算流程中突然中间算出的数据丢失了,spark又会根据RDD的依赖关系从头到尾计算一遍,这样子就很费性能,当然我们可以将中间的计算结果通过cache或者persist放到内存或者磁盘中,但是这样也不能保证数据完全不会丢失,存储的这个内存出问题了或者磁盘坏了,也会导致spark从头再根据RDD计算一遍,所以就有了checkpoint,其中checkpoint的作用就是将DAG中比较重要的中间数据做一个检查点将结果存储到一个高可用的地方(通常这个地方就是HDFS里面)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方法 首先设置checkpoint存储的位置</span></span><br><span class="line">sc.setCheckpointDir(<span class="string">&#x27;hdfs:///spark_checkpoint&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后进行checkpoint操作:如果计算错误，就可以从hdfs中进行读取</span></span><br><span class="line">df.checkpoint()</span><br></pre></td></tr></table></figure></div>

<ul>
<li>当存在缓存和checkpoint时候，优先读取缓存中的数据，因为缓存的读写速度较快</li>
</ul>
<h4 id="3-5-df中的内置函数"><a href="#3-5-df中的内置函数" class="headerlink" title="3.5 df中的内置函数"></a>3.5 df中的内置函数</h4><ol>
<li><p>spark中的内置函数和hive中的内置函数基本一致</p>
</li>
<li><p>使用之前需要导入相应的模块</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession,functions <span class="keyword">as</span> F</span><br><span class="line"><span class="comment"># functions是sparksql中的内置函数模块，里面封装了许多内置方法</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.字符串的操作  --  拼接  -- 得到一个新的df</span></span><br><span class="line">new_df = df.select(F.concat(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>)) <span class="comment"># sql:select concat(id , name) from df</span></span><br><span class="line">new_df.show()   <span class="comment"># 展示结果，这个方法拼接结果不会有分割字符</span></span><br><span class="line"><span class="comment"># 2.字符串的拼接，并且指定分割字符的方法</span></span><br><span class="line">new_df = df.select(F.concat_ws(<span class="string">&#x27;,&#x27;</span> , <span class="string">&#x27;id&#x27;</span> , <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line">new_df.show()</span><br><span class="line"><span class="comment"># 3. 字符串的截取</span></span><br><span class="line">df.select(F.substring(<span class="string">&#x27;name&#x27;</span> , <span class="number">1</span> , <span class="number">4</span>)) <span class="comment"># 表示从第一个字符开始，截取4个长度的字符</span></span><br><span class="line"><span class="comment"># 4. 字符串的切割</span></span><br><span class="line">df.select(F.split(<span class="string">&#x27;date&#x27;</span> , <span class="string">&#x27;-&#x27;</span>)) <span class="comment"># 将年份根据-进行切割，得到一个列表</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 时间操作，获取当前日期</span></span><br><span class="line">df.select(F.current_date())</span><br><span class="line"><span class="comment"># 2. 获取当前日期时间</span></span><br><span class="line">df.select(F.current_timestamp())</span><br><span class="line"><span class="comment"># 3. 获取当前的unix时间（时间戳）</span></span><br><span class="line">df.select(F.unix_timestamp())</span><br><span class="line"><span class="comment"># 4.将unix时间转化为指定格式的时间</span></span><br><span class="line">df.select(F.from_unixtime(<span class="string">&#x27;unix_t&#x27;</span> , <span class="built_in">format</span>=<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>))</span><br><span class="line"><span class="comment"># 5. 时间加减操作</span></span><br><span class="line">df.select(F.date_add(<span class="string">&#x27;date&#x27;</span> , <span class="number">1</span>)) <span class="comment"># 将字段date加一天</span></span><br><span class="line">df.select(F.date_add(<span class="string">&#x27;date&#x27;</span> , -<span class="number">1</span>)) <span class="comment"># 将字段date减一天</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 内置函数（常用于多个聚合操作） ---  需要配合agg进行使用（agg里面可以使用多个内置函数）</span></span><br><span class="line">df.groupby(<span class="string">&#x27;gender&#x27;</span>).agg(F.<span class="built_in">sum</span>(<span class="string">&#x27;age&#x27;</span>) , F.avg(<span class="string">&#x27;age&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定某个字段保留两位小数</span></span><br><span class="line">df.groupby(<span class="string">&#x27;gender&#x27;</span>).agg(F.<span class="built_in">sum</span>() , F.<span class="built_in">round</span>(F.avg(<span class="string">&#x27;age&#x27;</span>) , <span class="number">2</span>))</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 内置函数取别名的方法 ---  一般不使用中文的别名哦</span></span><br><span class="line"><span class="comment"># 取别名的操作，并且跟在内置函数后面</span></span><br><span class="line">df.groupby(<span class="string">&#x27;gender&#x27;</span>).agg(F.<span class="built_in">sum</span>().alias(<span class="string">&#x27;总和&#x27;</span>) , F.<span class="built_in">round</span>(F.avg(<span class="string">&#x27;age&#x27;</span>) , <span class="number">2</span>).alias(<span class="string">&#x27;平均值&#x27;</span>))</span><br></pre></td></tr></table></figure></div>



<h4 id="3-6-SparkSession的说明"><a href="#3-6-SparkSession的说明" class="headerlink" title="3.6 SparkSession的说明"></a>3.6 SparkSession的说明</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"><span class="comment"># 生成sparksession对象</span></span><br><span class="line"><span class="comment"># 默认是采用本地模式进行计算</span></span><br><span class="line">ss = SparkSession.builder.getOrCreate()</span><br><span class="line"><span class="comment"># 也可以指定其他资源调度方式进行计算        -----&gt;master()</span></span><br><span class="line"><span class="comment"># master(&#x27;yarn&#x27;) 采用yarn</span></span><br><span class="line"><span class="comment"># master(&#x27;spark://node1:7077&#x27;) 采用standalone</span></span><br><span class="line">ss1 = SparkSession.builder.master(<span class="string">&#x27;yarn&#x27;</span>).getOrCreate()</span><br><span class="line"><span class="comment"># 也可以指定计算程序的任务名称   -----&gt;appName()</span></span><br><span class="line">ss1 = SparkSession.builder.master(<span class="string">&#x27;yarn&#x27;</span>).appName(<span class="string">&#x27;yarn_sparkSql&#x27;</span>).getOrCreate()</span><br><span class="line"><span class="comment"># 指定配置信息 		-------&gt;config()</span></span><br><span class="line">ss1 = SparkSession.builder.master(<span class="string">&#x27;yarn&#x27;</span>).config().getOrCreate()</span><br></pre></td></tr></table></figure></div>

<h3 id="4-小案例—电影数据统计分析"><a href="#4-小案例—电影数据统计分析" class="headerlink" title="4.小案例—电影数据统计分析"></a>4.小案例—电影数据统计分析</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原数据格式，分析，以及导入原数据到hdfs中</span></span><br><span class="line"><span class="comment"># 字段： 用户id\t电影id\t评分\t时间</span></span><br><span class="line">代码流程如下：</span><br><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 生成SparkSession对象</span></span><br><span class="line">ss = SparkSession.builder.getOrCreate()</span><br><span class="line"><span class="comment"># 使用sparkcontext读取文件数据</span></span><br><span class="line">sc = ss.sparkContext</span><br><span class="line"><span class="comment"># 读取文件生成rdd数据</span></span><br><span class="line">rdd = sc.textFile(<span class="string">&#x27;hdfs:///movie&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这一步可以先进行查看一部分的数据</span></span><br><span class="line"><span class="built_in">print</span>(rdd.take(<span class="number">20</span>)) <span class="comment"># 查看20条数据</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将rdd数据转化为df数据,先将rdd转化为二位嵌套</span></span><br><span class="line">table_rdd = rdd.<span class="built_in">map</span>(</span><br><span class="line">	<span class="keyword">lambda</span> x : [<span class="built_in">int</span>(x.split(<span class="string">&#x27;\t&#x27;</span>)[<span class="number">0</span>]) , <span class="built_in">int</span>(x.split(<span class="string">&#x27;\t&#x27;</span>)[<span class="number">1</span>]) , double(x.split(<span class="string">&#x27;\t&#x27;</span>)[<span class="number">2</span>]) ,s.split(<span class="string">&#x27;\t&#x27;</span>)[<span class="number">3</span>] ] <span class="comment"># 注意时间可以使用字符串</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 定义schedule信息，指定字段名和字段类型</span></span><br><span class="line">schema_type = StructType()</span><br><span class="line">	.add(<span class="string">&#x27;userId&#x27;</span>,IntegerType())</span><br><span class="line">	.add(<span class="string">&#x27;movieId&#x27;</span>,IntegerType())</span><br><span class="line">    .add(<span class="string">&#x27;score&#x27;</span>,DoubleType())</span><br><span class="line">    .add(<span class="string">&#x27;unix_time&#x27;</span>,StringType())</span><br><span class="line"><span class="comment"># 转化为df数据</span></span><br><span class="line">df = table_rdd.toDF(schema_type)</span><br><span class="line"><span class="comment"># 查看df数据，默认20条</span></span><br><span class="line">df.show()</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.查询每个用户的平均分</span></span><br><span class="line">user_avg = df.groupBy(<span class="string">&#x27;userId&#x27;</span>).agg(F.avg(<span class="string">&#x27;score&#x27;</span>).alias(<span class="string">&#x27;avg_data&#x27;</span>))</span><br><span class="line">user_avg.show() <span class="comment"># 用户打分平均分展示</span></span><br><span class="line"><span class="comment"># 2. 查询每个电影的平均分</span></span><br><span class="line">movie_avg = df.groupBy(<span class="string">&#x27;movieId&#x27;</span>).agg(F.avg(<span class="string">&#x27;score&#x27;</span>).alias(<span class="string">&#x27;avg_data&#x27;</span>))</span><br><span class="line">	<span class="comment"># 计算结果保留两位小数</span></span><br><span class="line">movie_avg= df.groupBy(<span class="string">&#x27;movieId&#x27;</span>).agg(F.<span class="built_in">round</span>(F.avg(<span class="string">&#x27;score&#x27;</span>),<span class="number">2</span>).alias(<span class="string">&#x27;avg_data&#x27;</span>))</span><br><span class="line">movie_avg.show() <span class="comment"># 电影平均分展示</span></span><br><span class="line"><span class="comment"># 3. 查询高分电影中（评分大于3的）打分次数最多的用户，并求出此人打的平均分</span></span><br><span class="line"> <span class="number">3.1</span> : 得到不同用户打高分电影的数量 </span><br><span class="line">        df.where(<span class="string">&#x27;score &gt;3&#x27;</span>).groupBy(<span class="string">&#x27;userId&#x27;</span>)</span><br><span class="line">        .agg(F.count(<span class="string">&#x27;movieId&#x27;</span>).alias(<span class="string">&#x27;count_data&#x27;</span>))</span><br><span class="line"> <span class="number">3.2</span> ：然后根据数量进行降序排序，得到第一个就是打分次数最多的用户</span><br><span class="line">        df.where(<span class="string">&#x27;score &gt;3&#x27;</span>).groupBy(<span class="string">&#x27;userId&#x27;</span>)</span><br><span class="line">        .agg(F.count(<span class="string">&#x27;movieId&#x27;</span>).alias(<span class="string">&#x27;count_data&#x27;</span>))</span><br><span class="line">        .orderBy(<span class="string">&#x27;count_data&#x27;</span>,ascending = <span class="literal">False</span>)</span><br><span class="line"> <span class="number">3.3</span> ：first()方法，取出第一行数据</span><br><span class="line">	first()取出的是一个row对象，不在是一个df对象，不能使用show()进行展示哦</span><br><span class="line">		user_rdd = df.where(<span class="string">&#x27;score &gt;3&#x27;</span>).groupBy(<span class="string">&#x27;userId&#x27;</span>)</span><br><span class="line">        .agg(F.count(<span class="string">&#x27;movieId&#x27;</span>).alias(<span class="string">&#x27;count_data&#x27;</span>))</span><br><span class="line">        .orderBy(<span class="string">&#x27;count_data&#x27;</span>,ascending = <span class="literal">False</span>).first()</span><br><span class="line">     <span class="built_in">print</span>(user_rdd)  <span class="comment"># 直接进行打印得到一个rdd对象，我们需要的是userId</span></span><br><span class="line">     userId = user_rdd[<span class="string">&#x27;userId&#x27;</span>] <span class="comment"># 得到目标用户</span></span><br><span class="line">     <span class="built_in">print</span>(user_rdd[<span class="string">&#x27;userId&#x27;</span>])</span><br><span class="line"> <span class="number">3.4</span> ： 根据用户<span class="built_in">id</span>查找这个用户所有打分电影的平均分:</span><br><span class="line"><span class="comment"># 方法1</span></span><br><span class="line">user_movie_avg = df.groupBy(<span class="string">&#x27;userId&#x27;</span>).agg(F.avg(<span class="string">&#x27;score&#x27;</span>).alias(<span class="string">&#x27;avg_data&#x27;</span>))</span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line">user_movie_avg = movie_avg.where(movie_avg[<span class="string">&#x27;userId&#x27;</span>] == userId)</span><br><span class="line"><span class="comment"># 结果展示</span></span><br><span class="line">user_movie_avg.show()</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4. 查询每个用户的平均打分，最低打分，最高打分</span></span><br><span class="line"><span class="comment"># agg()里面可以使用多个内置函数</span></span><br><span class="line">df.groupBy(<span class="string">&#x27;userId&#x27;</span>).agg(F.avg(<span class="string">&#x27;score&#x27;</span>) , F.<span class="built_in">max</span>(<span class="string">&#x27;score&#x27;</span>) , F.<span class="built_in">min</span>(<span class="string">&#x27;score&#x27;</span>))</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 5. 查询被评分超过100次的电影的平均分，进行排名，取出Top10</span></span><br><span class="line">df.groupBy(<span class="string">&#x27;movieId&#x27;</span>)</span><br><span class="line">.agg(F.count(<span class="string">&#x27;movieId&#x27;</span>).alias(<span class="string">&#x27;count_data&#x27;</span>) , F.avg(<span class="string">&#x27;score&#x27;</span>).alias(<span class="string">&#x27;avg_data&#x27;</span>))</span><br><span class="line">.where(<span class="string">&#x27;count_data &gt; 100&#x27;</span>)</span><br><span class="line">.orderBy(<span class="string">&#x27;avg_data&#x27;</span>,ascending = <span class="literal">False</span>).limit(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="5-分区数目（了解）"><a href="#5-分区数目（了解）" class="headerlink" title="5. 分区数目（了解）"></a>5. 分区数目（了解）</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调整分区数目</span></span><br><span class="line">ss = SparkSession.builder.master(<span class="string">&#x27;yarn&#x27;</span>)</span><br><span class="line">.config(<span class="string">&#x27;spark.sql.shuffle.partitions&#x27;</span>,<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">.getOrCreate()</span><br></pre></td></tr></table></figure></div>

<h3 id="6-sparkSession读取不同类型文件"><a href="#6-sparkSession读取不同类型文件" class="headerlink" title="6. sparkSession读取不同类型文件"></a>6. sparkSession读取不同类型文件</h3><h4 id="6-1-数据读入"><a href="#6-1-数据读入" class="headerlink" title="6.1 数据读入"></a>6.1 数据读入</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-700c483397a510330ca7de2707f25655_720w.webp"
                     
                ></p>
<p>注意在读取mysql的数据时候，需要将驱动依赖放到spark&#x2F;jars&#x2F;下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-3e8dacd73984d322bed1d8413352aaca_720w.webp"
                     
                ></p>
<h4 id="6-2-数据读出"><a href="#6-2-数据读出" class="headerlink" title="6.2 数据读出"></a>6.2 数据读出</h4><ul>
<li>将df数据写入到不同的文件下</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-c8c57fd77bc297648d1b43286fe44879_720w.webp"
                     
                ></p>
<h3 id="7-自定义函数"><a href="#7-自定义函数" class="headerlink" title="7. 自定义函数"></a>7. 自定义函数</h3><h4 id="7-1-函数分类"><a href="#7-1-函数分类" class="headerlink" title="7.1 函数分类"></a>7.1 函数分类</h4><ul>
<li>udf		一进一出	可以自定义</li>
<li>udaf      多进一出    可以自定义  需要借助pandas</li>
<li>udtf       一进多出    不能自定义</li>
</ul>
<ol>
<li>自定义udf函数步骤<ul>
<li>数据是一行一行处理（传递一行处理一行）</li>
<li>自定义udf函数也可以使用sql语句的方式进行使用哦</li>
</ul>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-57e95d180036f75c974003f974c9beae_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-325b8dae62fcf9f0dd9a18e9813812be_720w.webp"
                     
                ></p>
<ul>
<li>自定义函数也可以使用装饰器的方式进行注册</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-0dba6e23b1d01568ae72d85f5a1b758a_720w.webp"
                     
                ></p>
<ul>
<li>但这种方式不能使用SQL语句的方式进行使用</li>
</ul>
<ol start="2">
<li><p>自定义udaf函数步骤</p>
<ul>
<li>自定义udaf函数的格式</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-fec57c303f7f458e06b1d5cbc852d52e_720w.webp"
                     
                ></p>
<ul>
<li>注册方法同上</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-924a9ed6806e53131145c930ce0b023e_720w.webp"
                     
                ></p>
</li>
</ol>
<h3 id="8-pandas的学习"><a href="#8-pandas的学习" class="headerlink" title="8.pandas的学习"></a>8.pandas的学习</h3><ol>
<li><p>定义方式（两种）：</p>
<ul>
<li><p>值得注意的是pandas中的df和spark中的df不相同哦，pandas中的是单机计算资源，速度较慢</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-414651540dc98062801a1fa16f4a7a4d_720w.webp"
                     
                ></p>
</li>
</ul>
</li>
<li><p>将pandas中的df转化为spark中的df进行计算</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-c4ad6c77cf47edd6c79d6f4fd2b1478f_720w.webp"
                     
                ></p>
</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-79a388b17fb470113442687d1ce7b099_720w.webp"
                      style="zoom:80%;" 
                >
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据技术</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2022/04/01/%E6%88%91%E7%9A%84%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="冬日随笔"><a href="#冬日随笔" class="headerlink" title="冬日随笔"></a>冬日随笔</h3><h4 id="小年"><a href="#小年" class="headerlink" title="小年"></a>小年</h4><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">只觉的年纪渐渐变大，一路走来，丢掉了许多东西，也放弃了很多儿时心血来潮的<span class="string">&#x27;梦想&#x27;</span>，其中一个就是成为作家；犹记得高中迷上了各种各样的小说，有雨果的，有村上春树的，还有东野圭吾的，当然也少不了鲁迅先生的，对于鲁迅先生尤其想多说两句，不仅仅是先生的文笔犀利的原因，也不仅仅是先生写小说写的有<span class="string">&#x27;趣&#x27;</span>的原因，最让我在对先生印象深刻的主要原因就是，读不懂先生写的文章，短篇小说还好，但是每次读起先生的散文时，着实令我头疼，甚至于连这篇散文的题目有几层涵义都难以明白，加之从小学便经常听起先生的大名，所以，对鲁迅先生尤其印象深刻。近日也是闲来无事，天气寒冷也懒得外出，便在家突然想写些什么，思来想去，便写下这些文字，也就算是对我已经放弃的梦想的缅怀吧。</span><br><span class="line">已然不记得，自己初中还是高中写的一篇作文，算是抒情，也算是描景，也可能是四不像。其中写道：我最喜欢四季中的冬季，冰天雪地、银装素裹的冬季。想起今年的冬季，自己还一场雪也没遇到呢，但可能是要马上过年，老天爷便实现了我的心愿，看一场雪。没错，今日小年，早醒之后，穿衣，拉开窗帘，忽然被眼前的冰天雪地、银装素裹的冬季所愣到了，然后惊喜，便不顾寒冷，打开窗，抓了一小撮窗沿上的雪，凉凉的，又赶紧用手搓了搓雪，还是那个沙沙的感觉。心中就感叹到雪没变！望向远处，村庄的高楼也好，瓦舍也罢，都被这忽然而来的雪所点缀，所覆盖，只剩下几棵光秃秃的树，没被这白雪所包裹，不过，倒也是别有一番风味。</span><br><span class="line">今日小年，吃了母亲包的饺子，东嘴八舌也吃了很多称自己心意的年货，（东嘴八舌哈哈哈，自己造的成语，就想形容自己吃了好多种）饭后心情格外愉悦，便想出门观雪，观景，想起友人，家旁边便有自己很多发小，但自己想了一下，还是决定独自去看，一来天气寒冷，马上新年，得疾却是不好;二来考虑自己，独行和同行，观雪心境总是不同。换衣，戴帽，开门，迈腿，收腿，关门，抬头一看，我的心愿仍然在下，不过小了很多，不影响出门，便在小年这天出门观雪。步行走了几十丈，竟有些喘气......</span><br></pre></td></tr></table></figure></div>

<h4 id="回忆吧，回忆吧"><a href="#回忆吧，回忆吧" class="headerlink" title="回忆吧，回忆吧"></a>回忆吧，回忆吧</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.......	</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-130d33539f8282b444835674b590b482_720w.webp"
                     
                ></p>
<h4 id="有感"><a href="#有感" class="headerlink" title="有感"></a>有感</h4><p>今天读到一段话，感觉挺有趣，便记录下来，仔细研学</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">全文如下:</span><br><span class="line">	当一个风姿绰约的女人走在街上，和她擦肩而过你会想到什么？有人想到她是一个天使，有人想到她是一个荡妇，有人会看到诱惑，有人会看到鄙夷，有人会自卑，有人会欣赏……</span><br><span class="line">女人本身没有任何变化，但不同的人却看出了截然不同的感受，没有一个人了解真实完整的她，所有人只看到了自己对她的想法、期待和判断。</span><br><span class="line">从心理学上来讲，这叫投射。</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line">	罗永浩有一段话，话糙理不糙：“妓女的眼中，这个世界上没有女人是不卖的，她们听到一个女人不卖的传闻，能理解的上限就是，是不是价格谈不拢？”</span><br><span class="line">	你怎么评价一个人，反应的其实是你自己的内心，是你对这个世界的理解和预期。你心里有什么，就会看到什么。三毛说：“你对我的百般注解，并不构成万分之一的我，却是一览无余的你。”</span><br><span class="line">很多时候，我们从未看到事物真实的本质，我们看到的只是自己的信念系统，自己对事物所贴上的标签和解释。你信念中所信奉的一切，会像手电筒一样打在别人身上。</span><br><span class="line"></span><br><span class="line">你眼中的你不是真的你，</span><br><span class="line">别人眼中的你也不是真的你，</span><br><span class="line">你眼中的别人才是真的你。</span><br><span class="line"></span><br><span class="line">	人自己看自己都是主观的，别人看你的时候是他内心的投射，而你眼中的别人才是你内心投影出来的镜子，是你的人格阴影。</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line">	怎么了解一个女人选择男人的标准？和她去看爱情电影，然后问她对男主人公的评价，她对男主人公的评价就是她对男人的评价标准。</span><br><span class="line">	借助对第三方的评价，了解一个人真实的内心世界。</span><br><span class="line">	老练的面试官会营造轻松的气氛，然后东拉西扯地闲聊，不经意间，问问你对某个人、某件事的看法，这个时候，你的防御系统松懈，回答的真实性会大大提升。用查户口的方式问，谁会真心话大冒险？</span><br><span class="line">	如果你一上班，看谁都不顺眼，张三脑袋进水了，李四脑袋被门夹了，王二麻子脑袋被驴踢了……真正的问题可能是：你的上头，投射到了别人身上。</span><br><span class="line">	你讨厌一个同事，就会给他贴上恶人的标签，面对他时，你自然特别容易动气，这其实是你刻意制造或放大了冲突。人生中<span class="number">99</span>%的烦恼都来源于人际关系，处理人际关系真正的起点，不是人和人的关系，是你自己和自己的关系。</span><br><span class="line">	网络上那么多莫名其妙的恶意攻击，其本质是当事人的生活过得不如意，混得越差，脾气越大。</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line">	心理学家波尔斯曾说：“我们以为，我们活在一个四周都是玻璃的房子，我们看到的都是全世界，其实，我们活在一个四周都是镜子的房子，我们所看到的都是自己。”</span><br><span class="line">	明白了这个投射机制之后，你就知道了，你所遇到的所有人都是你自己，这个世界的主角从来都只有你自己。只有理解自己才是一切问题的根源，你才能找到解决问题的根本方法。</span><br><span class="line">	人痛苦的根源是，总在用自己的标准去要求别人。</span><br><span class="line">	他怎么不按我说的去做？王五太蠢了！赵六不讲究！当你总在用自己的标准去要求别人时，你会发现，你就是和别人相处不来。你要改变别人，只有一个办法就是改变自己，只有你自己变得没那么多标准，没那么多框架和要求，你和任何人相处都是可以的。</span><br><span class="line">	如果你有感情方面的烦恼，送你一句话：你怎么爱自己，就是在教别人怎么爱你。你细品，这是解决感情问题的关键，别再当演唱会上的沸羊羊了。</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line">	人生的道理浓缩一下就两个字：内观。所有的圣贤书讲的都是这个道理，我是一切的根源，我的思维导致了我的选择，我的选择决定了今天的因果。</span><br><span class="line"> </span><br><span class="line">	《心经》开篇第一句就是：“观自在菩萨”；《六祖坛经》的精髓是：“心平何须持戒，身正何须坐禅”；《金刚经》的要义是：“应无所住，而生其心”；禅宗说：“明心见性，见性成佛”；王阳明龙场悟道，悟出了八个字：“吾性自足，不假外求”……</span><br><span class="line"></span><br><span class="line">	人生最大的敌人就是自己，只有把自己看清楚，才能把世界看清楚。把一切外部的事物都当自己的镜子，时刻照见自己的内心，破除执念和障碍，你才能成为更好的自己。</span><br><span class="line"></span><br><span class="line">万千法门，修心为上。</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">个人所悟、皆为所得、吾思之，想之，爱之。</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>杂文</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>杂文</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>数仓项目</title>
    <url>/2024/04/16/%E6%95%B0%E4%BB%93%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="1-数据的分类"><a href="#1-数据的分类" class="headerlink" title="1. 数据的分类"></a>1. 数据的分类</h2><p>我们主要分析两种数据</p>
<ol>
<li><p>业务数据</p>
<p>简单的来说就是开发的内容中涉及的数据（站在开发者的角度来看）</p>
</li>
<li><p>行为数据</p>
<p>通过埋点收集和客户端产品交互过程中产生的数据（比如用户的点赞、收藏，评论、停留）</p>
</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">本项目收集和分析的用户行为数据主要有页面浏览信息、动作记录（商品收藏、）、曝光记录、启动记录、错误记录</span><br></pre></td></tr></table></figure></div>

<h3 id="1-1-数据同步的方式"><a href="#1-1-数据同步的方式" class="headerlink" title="1.1 数据同步的方式"></a>1.1 数据同步的方式</h3><ol>
<li>全量数据同步（DataX）</li>
<li>增量数据同步（Maxwell）</li>
</ol>
<p><a class="link"   href="https://blog.csdn.net/Morse_Chen/article/details/135418623" >Flume <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="1-2-数据流转到kafka"><a href="#1-2-数据流转到kafka" class="headerlink" title="1.2 数据流转到kafka"></a>1.2 数据流转到kafka</h3><ul>
<li><p>主要是为了进行实时（数据的处理以毫秒为单位）的处理</p>
</li>
<li><p>什么样的数据需要流转到kafka呢？（增量数据）</p>
</li>
</ul>
<ol>
<li>Maxwell</li>
</ol>
<p><a class="link"   href="https://blog.csdn.net/cxl_shelly/article/details/122132124?ops_request_misc=&request_id=&biz_id=102&utm_term=Maxwell%E6%95%99%E7%A8%8B&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-122132124.nonecase&spm=1018.2226.3001.4187" >博文 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://maxwells-daemon.io/quickstart/" >官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ol start="2">
<li>Maxwell ,  mysql的实现原理</li>
</ol>
<ul>
<li><p>主从复制</p>
</li>
<li><p>读写分离</p>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql的数据放在文件中、从文件中查询速度肯定很慢，所有mysql把经常查询的一部分1内容放到内存中，走内存进行查询，速率肯定快。而内存中也分几部分，有写缓存、和读缓存，当进行查询的时候，优先从写缓存中进行查询、查不到在从读缓存中进行查询。（此时用户新增的一个流程是，先将新增的数据写入写缓存中，达到一定的阈值之后写入文件，但此时出现一个问题，假如在向写缓存中的时候服务器突然挂掉、缓存中的数据就会丢失，这个时候就出现了数据丢失的问题）解决问题的方法：在写入缓存中先顺写到一个文件中、然后在向缓存中进行写入即可（注意：mysql在存储的时候是随机读写，效率不高，先写入一个文件，再写入缓存中是顺写，效率高）所以提高mysql的效率的一种方式就是使用更好的磁盘。同时还可以使用集群，而使用集群大致过程就是。向主节点进行写入，主节点将数据同步给集群中的其他节点（从节点），进行查询的时候只从从节点就行查询。这样保证了每台服务器职能比较单一，效率更好。而从节点进行数据同步的方式就是读取我们刚刚顺写的日志就可以保证从节点的数据同步了。</span><br><span class="line">而maxwell的实现就是将自己伪装成从节点，读取顺写日志（binlog），将增量数据进行同步</span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-两种数据同步的方式"><a href="#1-3-两种数据同步的方式" class="headerlink" title="1.3 两种数据同步的方式"></a>1.3 两种数据同步的方式</h3><ol>
<li>全量数据–也可以使用maxwell进行同步</li>
<li>增量数据-使用maxwell进行同步</li>
</ol>
<h3 id="1-4-hive分区的目的"><a href="#1-4-hive分区的目的" class="headerlink" title="1.4 hive分区的目的"></a>1.4 hive分区的目的</h3><ul>
<li>提高查询效率  –  假如根据首字母进行分区，查找张三，只需要查找z开头的文件夹即可</li>
<li>一般分区按照天来进行统计</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>数据采集</tag>
        <tag>大数据技术</tag>
        <tag>数据仓库</tag>
        <tag>大数据实战项目</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库-SQL</title>
    <url>/2024/04/10/%E6%95%B0%E6%8D%AE%E5%BA%93-SQL/</url>
    <content><![CDATA[<h3 id="测试图片上传服务器功能"><a href="#测试图片上传服务器功能" class="headerlink" title="测试图片上传服务器功能"></a>测试图片上传服务器功能</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">老身今自由。心无疚，随意度春秋</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-c67b050921ab84a8a5188cb2559fe9ad_720w.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-626d786cd1bc9423942de0f829a8ab17_720w.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-5aac35005e06df7a489195614e4b4a23_720w.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-d15d1d5889e528fa16de49eac88cab10_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-6b96910eb06b006568a6043458c22aac_720w.webp"
                     
                ></p>
<h2 id="1-爆炸函数"><a href="#1-爆炸函数" class="headerlink" title="1.爆炸函数"></a>1.爆炸函数</h2><hr>
<ol>
<li><p>使用爆炸函数可以将数组转化为<strong>一列</strong>数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">select</span> explode(<span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sequence(<span class="number">1</span>,<span class="number">100</span>);  <span class="comment">-- 生成1到100，数组数据</span></span><br><span class="line"># 配合爆炸函数快速生成一列数据</span><br><span class="line"><span class="keyword">select</span> explode(sequence(<span class="number">1</span>,<span class="number">100</span>)) <span class="keyword">as</span> id  <span class="comment">-- 可以生成一列从1，到100的数组</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>快速生成表的数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> stack(</span><br><span class="line">	<span class="number">2</span>,   <span class="comment">-- 这个参数指定表中有几条数据</span></span><br><span class="line">	<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="number">23</span>,</span><br><span class="line">	<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">22</span>    <span class="comment">-- 这两行指定表的数据内容</span></span><br><span class="line">);</span><br><span class="line"># 也可以指定表中每一列的字段名称</span><br><span class="line"><span class="keyword">select</span> stack(</span><br><span class="line">	<span class="number">2</span>,   <span class="comment">-- 这个参数指定表中有几条数据</span></span><br><span class="line">	<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="number">23</span>,</span><br><span class="line">	<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">22</span>    <span class="comment">-- 这两行指定表的数据内容</span></span><br><span class="line">) <span class="keyword">as</span> (id , name , age);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>操作生成表的数据的方式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-96f65907b5db27165ac8a0c35ded999d_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-978c9ada3d323e31b62dc0f86cbdd2c3_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-b0c6c4532bbdbd9733312b1611ed9875_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-f957d4006d4d9ea8491601b5248e4d97_720w.webp"
                     
                ></p>
</li>
</ol>
<h2 id="2-SparkSQL的执行引擎"><a href="#2-SparkSQL的执行引擎" class="headerlink" title="2.SparkSQL的执行引擎"></a>2.SparkSQL的执行引擎</h2><ul>
<li>解析器 ： 将sql语句转化为语法树</li>
<li>分析器 ： 语法树中被查询的字段数据类型-读取元数据声明被查询的字段类型</li>
<li>优化器 ： 将语法树进行优化<ul>
<li>谓词下推 ： 比如先进行where的过滤条件，将过滤结果在进行join操作</li>
<li>列值裁减 ： 只查询需要的字段</li>
</ul>
</li>
<li>执行器 ： 将最终语法树转化为rdd，交给spark进行最终执行</li>
</ul>
<h2 id="3-电商案例"><a href="#3-电商案例" class="headerlink" title="3. 电商案例"></a>3. 电商案例</h2><ol>
<li>订单表字段说明</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-230eab3071260efdc00c1fe81eb4c71d_720w.webp"
                     
                ></p>
<ol start="2">
<li>对原数据进行数据清洗的时候假如存在int类型和string类型的空，过滤方法为：</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-82a74de1d91f0800e369bcf00f4dc736_720w.webp"
                      style="zoom:80%;" 
                >

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 注意点就是对于字符串过滤的时候，不能使用<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> 因为他不是<span class="keyword">null</span>，是空字符</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">and</span> name <span class="operator">!=</span> <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-c6075985d1d94348edd19ad555c21362_720w.webp"
                     
                ></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 然后将过滤之后的数据导入到下一层里面</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-ee58c48091a9b74721b019bb437fa1ec_720w.webp"
                      style="zoom:80%;" 
                >

<ol start="3">
<li>app层的计算指标</li>
</ol>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">1.</span>销量最高的<span class="number">10</span>个国家</span><br><span class="line"><span class="keyword">select</span> Country , <span class="built_in">sum</span>(Quantity) <span class="keyword">as</span> sum_data <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span> Country <span class="keyword">order</span> <span class="keyword">by</span> sum_data <span class="keyword">desc</span> limit(<span class="number">10</span>)</span><br><span class="line"># <span class="number">2.</span> 各个国家的总销售额分布情况</span><br><span class="line"><span class="keyword">select</span> Country , <span class="built_in">sum</span>(Quantity <span class="operator">*</span> Price)  <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span> Country</span><br><span class="line">        <span class="comment">-- 保留小数点两位使用round() 函数</span></span><br><span class="line"><span class="keyword">select</span> Country , round(<span class="built_in">sum</span>(Quantity <span class="operator">*</span> Price) , <span class="number">2</span>)  <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span> Country</span><br><span class="line"># <span class="number">3.</span> 销量最高的<span class="number">10</span>个商品</span><br><span class="line"><span class="keyword">select</span> InvoiceNo , <span class="built_in">sum</span>(Quantity) <span class="keyword">as</span> sum_data <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span> InvoiceNo </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> sum_data limit(<span class="number">10</span>)</span><br><span class="line"># <span class="number">4.</span> 商品描述的热门关键词Top300</span><br><span class="line"><span class="comment">-- 思路：首先将商品描述根据空格进行切割，然后得到sql里面的数组，借助爆炸函数，将数组中的数据转化为一列数组，并且重命名为word，然后在进行查询统计即可</span></span><br><span class="line"><span class="keyword">with</span> tb <span class="keyword">as</span>(</span><br><span class="line">	<span class="keyword">select</span> explode(split(Description , <span class="string">&#x27; &#x27;</span>)) <span class="keyword">as</span> word <span class="keyword">from</span> 表名 </span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> word , <span class="built_in">count</span>(word) <span class="keyword">as</span> count_data <span class="keyword">from</span> tb <span class="keyword">where</span> word <span class="operator">!=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> word </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> count_data <span class="keyword">desc</span> limit <span class="number">300</span></span><br><span class="line">	</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">5.</span> 退货订单数最多的<span class="number">10</span>个国家 <span class="comment">-- 求的是数量啊--使用内置函数--count()</span></span><br><span class="line"><span class="keyword">select</span> Country , <span class="built_in">count</span>(InvoiceNo)  <span class="keyword">from</span> 表名 <span class="keyword">where</span> <span class="built_in">substring</span>(InvoiceNo,<span class="number">1</span>,<span class="number">1</span>)<span class="operator">=</span><span class="operator">=</span><span class="string">&#x27;C&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> Country <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">count</span>(InvoiceNo) <span class="keyword">desc</span> limit <span class="number">10</span></span><br><span class="line"></span><br><span class="line">(答案)<span class="keyword">select</span> Country , <span class="built_in">count</span>(InvoiceNo) <span class="keyword">as</span> count_data  <span class="keyword">from</span> 表名 <span class="keyword">where</span> InvoiceNo <span class="keyword">like</span>  &quot;C%&quot; <span class="keyword">group</span> <span class="keyword">by</span> Country <span class="keyword">order</span> <span class="keyword">by</span> count_data <span class="keyword">desc</span> limit <span class="number">10</span></span><br><span class="line"># <span class="number">6.</span> 商品的平均单价和销量的关系</span><br><span class="line"><span class="keyword">select</span> StockCode round(<span class="built_in">avg</span>(price) , <span class="number">2</span>) <span class="keyword">as</span> avg_data , <span class="built_in">sum</span>(Quantity) <span class="keyword">as</span> sum_data <span class="keyword">from</span> 表名 </span><br></pre></td></tr></table></figure></div>

<h2 id="4-消息队列（MQ）"><a href="#4-消息队列（MQ）" class="headerlink" title="4. 消息队列（MQ）"></a>4. 消息队列（MQ）</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">突然有一天你会发现，你的思念不会因为长时间的不联系而消失，只会随着时间的流逝像野草般疯狂生长。</span><br></pre></td></tr></table></figure></div>



<ol>
<li>作用</li>
</ol>
<ul>
<li>进行实时计算需要</li>
<li>应用耦合  – 解耦  – 使用消息队列解耦</li>
<li>异步处理</li>
<li>限流削峰</li>
</ul>
<ol start="2">
<li>消息队列的两种模式</li>
</ol>
<ul>
<li>点对点</li>
</ul>
<p>​	</p>
<ul>
<li>发布与订阅</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据技术</tag>
        <tag>人生感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>比赛刷题总结</title>
    <url>/2024/04/18/%E6%AF%94%E8%B5%9B%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[
<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8b1ac1d17d514f2bbea8663227392439ef7283aef867a425fd5be1003f2e7601">24e63d1d63e5c42fbdae0dfe4d3664c00a497933a2e4d925461444f18fecf59dcb39d9dfa72e2b3bd7098ee1fd7aa80db953fd7e2f959e586cdb7e85a9dae3df9f5a89f176b875db83cab828ad8182bf34c7add1453e80922ab754e5a378c440ff705bc69b6fc085897eea372d093cff3453f6710c352960766d2315c5495ed879b1dac37575e16167414a669ba24e1d7d66981cdfda2ae84e397c09a8f19da1058994aa6fb36f91d49c5466cedd471381203be5b0e1f7aaeaff1643f988aafc223a64048cc70b1c0dab15e39cdb66a8abc7be2b3cb656cbb49d72a4764fb958eafd698ae0a38fc70d8092db5cca764b1125207b2742d05e6b18701055621115c36583c676db1a37c62a22512d3d0b08059d07a44ee94d8ea1cbc4785510ea331dd4bf44745b2c9e5a3ead205fc39497f12d7e4cc40260d1153ce7bb9ef4d5a9bbb9655f3332bc6c461081cc76304309e99447e97f4dbbcae4484c44c2e0d302a8efcc13f7ae274c2f695764f7ab72199ed8876546244f9fb817443c491892e4fdbf516e34ffe2b1d20882896d2b7b43c8d4c9de9035bd9030e77378a50adad255fb0204354cc43cf8d0ac3c0a5f5bf52e3fd8f9aa7838530dff9f67d695259c3b955c6f429ad958efe8cb92c945ceed0d6ddf99859f9847a3a13e9315f93fb5a758520e867d4e9adebda555711eb767c9c827eb5f891e0cd56eec5519d1301167be2af4ffcd5124c8333c4e4fe6964a6e6e8b5c509d794614650ba9f61962bd8dc5f677f4f065c7ea62dbaa23c2b6bf3dbf4b5eb689c82c05b984c5264cf37749d0c1743bed12be77ea10cb70130abbd22e4f8c5b232d12ef598da3e4cbfdcca038a4ec02655dbb4b195c6e784bae10ee15a0f9c1a8b5103ffbf51d92ed632728d34f5ddb70b0f513ec68127ced82dbda2e7aaf926927fc8baf17966f73c977706eaa23c1e6ed087f27e7e15826b6239a3fdedeffbac2e85f78e2b34e97c680badd2af838ac78c688e703def0202ad8aad291dda7812a0f4e16d5d64b6cd54bda8998c54a41a53b3dae508ea3e81274e3bce73ea50f25de0c8b6148015f95fee0a3aafb065174fcb208aa741a5b76b79185ed7e6a082ce1456b3218a4f74780f1544c5b878798e87ee78811488df044c8574666ad889d15393588d23755afe32819627b78c2141ddf73825d1aa88a7c36d9c60d5041cec46a0a8fd4999d6e525abd88b3b035943152adbcc3d5c9f81cd3660258b0d984bf08b9a1fb135a4a564bdaaadc6fd271aee5a29c85206f21f13b8cb1f23a0f32a315b665610ceacfd98d3a82b5a38e71f488f2020563748857a1d2c695240c19466f14d002c71216fbf4a27cd832dd385552cb9153f8d6920469ff9c2be8a6a43f63200611358181fe05d8a3c9c73bf7d78f5d0224964db34d3060a3bae76778bdca22c006554a6739277d7c11c66ea7088bc1c5fae3fe24d00b52b14bf807167305e56c0bda869e718952a7cfa4a9b618471202eab6db15c84684511f1722ba865205e9d34fd308b110031aef0c5cffe6d1809daf8b5fd89b0688740729bfaca63e6d8071e9e21a52b7db8bd3856846f2a498f74a404c401e85264fa17333fea4e5d0060d112ff71bc14b4658ae4b410f784348238fbc42a3d113e000636dd841576726f5570c2260e107102f9efe1805d484de42f75613239981fbcb60137fe6c38c61a75c275f89d363f5c4d2e08649d0835a91d745bde28ff95bc79dfdc709df22ea7c5f492557e09b5afc1a996e69ac88cb6906080b1dbc6858dfd14a49fa5f913f7ea04a725f264b118b6457d5e8f347a6b67218ceb4012b351212b54aeccbd9f3cb2c4f0c50df8524eaf5119a75a957fdc7404ae31af3543f42d3207f57f6914c34cfdad2c390adb3073a4aa623283ad54e194d64d5076459533fe4811392a7b50c738161131e0ad2803f67f9d0fed2c1443c14c8a88274a896a5bc89f9e4ab97c61c5c5b65057b655b06331044a4e2f8ff523a31295bad648f6a6ab99e121ce2d66247ad8ee494c71865ec2ae79e5cd5b4ac427b4d56379204ec66c153942e315e5ac88248f6a53c176e4f3ecb938bc93f01babd3850f26eb19f9847ad07d2aea0a3c1103ba32e155a71bc23cc0086d7aa1dc548611408ea069c22d91c4cd25baa00faf63eeb4967b95723d5dcd9ccc61cdb2cea9e5d860092afab1fb07931afc097bc604a1eef8f0aafe14a54577515565fb73e70bc5a401bccd8b7bfe7d95c24f51877d2df01896f30c1dc1f647952641a74ee2d69511d81ddb8d9cb6bab20696419fa85b8ffdfa11d066b5a628cf3e3137913e8de392e9a14a50811ac3d9d0e1f3730b47be8b1d8a12f24601504159b05e465895863e8010898dcc02e4d639f7b054f8fdd3e7f44681291bd23bea35a6eeb1ff0b17d7e18564300fe67d17904dee30fae894176abe9cb6e3d47c868aaae554296eba623d708eca302b8f4861a434e397d40affeb5212c7349fdec22798bb2a9f6a848afe5d58b0e2f3ce6685f1929586618ece622273ef1eb9490b29df73ff0ce062fcd54f9333f5e910d865bc4e75f0bf8bc0412b7405cdae670ea413d29e19760139852b766d33c48b3883c24ed6ed093d9ef7d3f45ef3031ec017a75da08514236f462d81e78b836ea24e12a44d71c4fc6412659421defbce9377c5e8531e77761ade4610c2308cad2a0a77647b208bf37433c0ade387dbe46220b99d51b6aae9ffedddaeac318d16ac8fe65c2525789ee87d5561e58be277d96ef9b3e285a6b3ec326515e9aef4bb775cf2741aee44192575671e6d392f1b0b10e6b7bbaf22fd77013825e020a84d799f3312f49cfb931a64ebdd5465ce80f1ba752b6d182d7fe8736c906033b7a5ba05c9f2f5aa46b0d407f3d243fae034094aadd887388e049017ca3acbd9735580355c095616da051b6f66a7c15c532ce4c1a3774eb0936370fc2e36b76fd75dfa9d4656a6fc8d5f908ca09f680fa1c1d76a1528e387142d6f0774cff56e0fa00e523de7b2ec82478c5775046ddd7c978e84d2d547852a2d4a9029905c8eb8e276b570e20333b8f645b176a657d74d236c5998b3185638855336e82a15694bb14053fe679fc9659820d73e3af771ceef38f28ce1abf1715c3873b91799fc8cd6c79e2ff506b29e100aec94dac46d851d40586acb237f6a20e1fb52ef4179a2bed1e8f8006842b707005d2a858274effb588d64090981ca863cdd5a94b17939adfbab3b8f3a80c0698139f68b4bf6a6f7d1f3daf67fc333123b2aa2e61a815c6028e2d0687f59690dd7a7060846a350c4151060519d00ead6b20638ca3bd7137e1cb8d65b1cfa0991818aba4e01fe3fe7f21cc29012bcf48e1a642d6b0fd7ee3f75f37d66501b67ac4fbc5cfe0ebf0702c18d8db8316e0605374da77f9544f8b02ff5ae66f2ecffc4ba579e46186b0c92d9afc26d72a51c83dde4bdf1e709d82286c65325322f95c19ca2fc80c42d7ec3805ff647508c7d74086b25b69b76a3e42cf0e3f9b38718e80c4f92881f23d741d99cfd3b46e9954ed99117b20fe42f9eb6f939fd4b638e76a64544bd8be9e9646eb10b7e0b67c4dc0e831d5fa57abcb9dad7adf31242946846ceeba0441c839f0a9038583d6466177986025ba9096752ad403c12f810405987a942618eca5a717574d9ce2f87c2de72516374e9a53f62c901c60ffc3b7c2cf53d6f412258f932faccd96644a2fa4de98c486c3fb120c4f875b7f93350eeb4ede3c42a0039ba6f881b9cf2a4a5eaab50212e94da71f30547d5c4d67dbb091c8a10771184090da15f51c23f4a80ff4c045e79a01a26afdbb0d0507a38192faf2c53c4c7ce0f972b3071a092922e46a63fa8780f255c112c0ee1c8adcc518717acfb59b51443419df4a8233bdf3b6fdee3e3094d2bcf2b0954cff0be0f89c48f199fd8c5a5613f243876a1779b6c8ab9e7818ebab8b7293212a92e284b5ce778ef103abbf2d6f639a7919a8d0f35e2fdb9551ce6f05fc4cfb43284d0b2574ca49fab7790d09e780d8305a3c4f9642896840a60db49d590f9b0af853f8dfe7fe1bb8f8d1fcc7674c26a6f462698ea398991cf85f1d28cea82978b77f6fd89abe9fbfc09688305950a89367e7e0acc87a5af962e0f88ab3fedbb436c0925a37d6a0e24a9d23bee872bf085626d60b2454b99113d78617222a6cbcacd877cd282d07b77442ce0f539f691894a12a28897b22870c7c8efe5869a9b8febbfdb30c702a60d0194d89297ea936269f57dfd172471623a6c3033481160533ff8ffdedbf771fdd59289fdc84ee380b465f14907bc4610f1171cf9792c522e4a84fb28f75faacf871dfd42a88e78dd8e3a0fe37b798a9dafae625970b1c2032dd451f1efbd5e4827ab354fdf9b3b036ab059b85a4aa275df8c0f27b9133237df5aa8c6d6b9c9776c5054971b7642c37ae8bc3b18fada61c56aa34dbd33e6ded206fcb1c6ba1fac59fd851a4b9d5ce5f736e08f14bfc5d43603051f4ce7154f264d55175bbc9b2ad2de8efde00d82df21d268b9f102323aa9ea606afc4aa75af5078e69298914e10acf504a26e987ffea1d026a81712717df0c9bd7bff035708cd2a1a4eb81511df8464fe165f0ac612a187e99107f5a86eee9d8910720a73c54b3555665396bfc210884e9292430e31706e8d8b93ea8706cd8b61651edb69a16f59bed0cea38d50fc2d237e0544afc236c623fedd12302df76dd726a6575a228644ebec74c43d72371ce6f540dbd46c6167314d2e61aa3a64fb30c9c1a0c9793eed0fb9df3f36eaf6a69fccf986f49ff5d6ba34bf992f35e4aa7154e8bf9be6d141d118400583af7da270d9f9b8e301b310a2098de7e4f10304f5dedf47d34ceb0a03755a8cf7240766d9a4c4bcbfa1a80887b7e2379c8b0505b99db83faf2083a0fb58a95a6d87287f513d0ee50083eda73e25b3c1063c8e1b2c042e2d2fec81d690738d66f2f9f7bc4d58e6353283d8b520cc98e414e683f21201f6bd817f3d986bc2a309fb74a9c0b44aa12076092dae130a2cd4751a80fcb75f2871f6cbf4b3bbf979ce1ca39f8035d78fe49c4101324b96d39b173a40cb3203b923b0f3c850a3b54443f5cd9c9c4ee447c8ab463f23513053983120b2aa1de351c0c51543aeba2e31de1d008d47e8b7bc2f2f8264265afcf58613e2954be66e5a34e21cb8b3110e21c2d796faca18412b645d5dd10974b1ab1dee2c61f1bed2e66853f92ff3a6d2ef71a17feed6c1d1b9787971f5d8f9dc000ae1233ff7d851b521830f68c865fe40f47c21e656d2212b855424472af1e816fbe98733539cdcabb11ce5342dbbfb076c6ca806928d99fe12e35c4f6e073fd273302d04d35ded63125e0d64f19a6871a89621498a853c20446fae2dc29c3e7c1f41acdea5999ab28e7ca9037fb51751f9e5bf032ecdb6b7691b7c245519679718d57971b4a3595f3ad6f17d531473326715e2cefabf8030b3b5590238b26317e2693ecadbcc3cfd4c8e8c65d3b46e7db256d8b3f657c5829a91f89e80c3c1dee1a9fe553e627736d07ac2fe278634ee91da015323934766e4ba07f9c687f2f8256264c0ad8b37ab27496578eb1ee0e87efe4a14b6ca48ef9fbdc989b4e394b5d7ca16a164dda124bd3df5661565b2adba17ef3e45514c127deea8f1c8cb2e301bd8e81bb05886f59a9bdc5f7e67bfdacbdac31f21c6d8219f0f80b43603c2171831ad7f63728070e6f1a3353b3c184d06037e8275c3679c814902c4957d743ce5158be5c17a44a240cbc1250e2407e96c6d56d8520bf3287259acd390f4c20095d145b0b08d125b4a26b76ec063266df56f3f651067bd6653d5b4101fd97593596c33cced4fa0ced022435690405dca579c067dca5dd6e2ac7358f04e4e3d7a82a74a18fc0d1bb2a34600a1f1b954424f91b0b24c41fd067e399b9ef066ac8d1e7a8a8d574c12444702c7acc066d06486e1c4a3ab1d12ed21e38a72969a718c1200ac43dcd904fb4b73ac591ca6213f6bf4837df69c79187f12858bfb73bf5527708b9258c607dba8f52030b0c0c8a337dd3f8428b5dcda66d8baeec0efb9c3512be2519e98abd802f1c4ea69bcdfada5ee0d546d534facf5581e3ea7b28af4b9e7dd5f0f622d4e21746c87861e860a01d53154add5911b2d188f5d7e054bda25f986d4ed462b954146ba130ec21c78deec213a3cd7f83f33aefaba40dfbdea5be608051c245265b2d7684b9446e9d5b3eaf47a2ebc38951451e669748a19006b6ce00e7d1f0d81eb649bd34ca3f4bd747075a8dfbfbe88d11cda0bc5a2b001c57f2139176914e1888e09a239000ce83e7a08a6ad051bb7ebbca54dcdda2806ffa94a3317ee0325ec1c64439db34eb86da7aecba95dc5253598968b8332cb6761e27907bd595e08e320f25401d5a0a2082a6327506432e42805cf5f761cc4fffa0f5849d526fbe844d34a5ad97cddb2cdfe0d350491721c990b295d098c64cc6c3499aa2739e1357afc35ff8c34db1c845ca6e6d42782e834ef94802227f087d4ac70c7a5d25747b5a10d9ac9d24dd7d983f38d0f0bb57aaa1e10d5aac11d64c2d8d20d53ca0612a823b00eda34c24d2876293981342e94832bdfea6ae93385490dd5418b8bd63b225406149a7cbbf129327d372bfb1a034fc41153e10ec5e208300f376a1bfe0503f769a509102f70dc30b124bd11502acdf95b6331444506694d456f62612f6efeac67d7547e8069b14f9dd62f03c6e10caf0de2cba1988bc1c4504a1fbe1d56a9897329d38b739f95eaba53aa9463e6693a668da482c2d0a07627e88df85abfb2f1788ef74519015420deca33a3eb1f2562b85b0aeee0b675d3e162be7c7c9bdcf113a6530332df7f2edcabea878f844fd6fe911639866f059c81a8a2a11de2a3e553f1c1f8b5b3544d0b84378626602466632ad410db6a16d0743c3d1901e6198822c8824e936a2263eeb553ab546d0aa1492415b45c75ae427b778e9e04aeb5b1c293921e56ca2be6d510b4d820a3170236c75e4be4fc4e2de7d6c987d93dbd38c7ff99415b50df7be2f3887ef796d4d0725b7682c5c672bf53148c938c1b438f7aeea278026d387ea61973ddd526ca44902b5cbc09a196e5d7ce6373f2411a3e64f5304129c78fe32296680967adbfb11671d5d9b6aa3b7fde301e603571b58487449c2453bf3cf3f5ac0a564656da3c2e64e8672f8db9115d2184aaab7e414627025b78b333569213179de5869070584a247dc61b18db1476f58f5e89b5d78c2be7441c5ae1393f6ca83969809020efff21b904dcad615a8ff1af50f75e4b2ba7b20cae64dcc34584c5ae5a56ea16faf0a60431981292b1245a26b1d6ff4b6d7ad5956a3422027bd91799f7f0e1a748e67a371ad5b6efbda8db38962860557a037c0fb1be2b6742f122feb2c7c5b47c66a1d776d7dacf0cf45204aa9b4e6f37e5509595f26f6f9dd5dcd9cf729b853e93e4619b97ef4565f85ab07771c95c26182b8453de0ea85be1a6886ba4ea2d24e2cf34c5b1638997517bbd74d14828b18593fdf90858c398599d3cc3218a50ed6194de75379b0803f0ed80865abb048a6de186c58f8d2616af8b9aa7e5f7dd56043fc626d7bd11a56c65b56fa7f24ebb02017c7df3fc1ef296d47e29d1787a58382a6a9cc3471bb5360cbd5bf30d199a0aa3d7267fcc8807180327160c22b5df4578d360a5136992edfbccd94143283afa62c1b300be227a2a2cc758f44168e350cd6b136cb68b0da35b01a7250966dec6b6b2242c82cb992a26bcac506809a032120a67d9d644c0eacd9b440b67c088dc295525194f12934a547ef76ac356df32884e2f154a8f2e8a6c1663c1aca0ad5a03bd7c20ed7e0eee5b9fb9efab1a13a3d97e56937deda41dafa377e6785accb8d14ef8667bd15b09395b83b6e6a49f19a47c602b49e31bc16a4587ddbb8997f4bab43c76b6dfdd8a8f996e82f83577fd767b1e66e461cad561501b44749ec06c18728a563fcfd12af564a78616d642792ff7b9b64a40c1f6d900f624475833bea408594d242ca0195de576778049b899f09170d7f4cc18db34bf0f3f3ee9a41b1caed8d9cda3a6a02a55e1b59201d287fcda98083c7a98eb9e43522c807baebe9c1c151babe5f27cefb664ad7b67aa00954042ff6647520e31079631ffb64bb798139c24be6ac2faacebfff6d9821d4b8d5d61b6a780b4c619a637badb74a9a2cb47ea1678d0ef53393563e04844b965f29de8af0c6dfb9069100774846ef4d11b7e903825d8271b0edc1f92ddfe561efeea667e6056bd497434e74edbdedc2cc9e01ba8c33e6fa8c118bcd8ae3d1de939a5758578e9713a2e50ea02fa26ab63b1f13e0750377b70dc8e5e42ced2056e5707457b7e0840444093d69638ae2265ebf0a4bf429a8a412b0be14ecb1f7a1d179794d7e71e441c17f0913d22589fc94cb1b7abc1a40651428c87697af77701945a8430de083f3ad76d291c5d7b166192ec851949e2d94b51f1646bf3aaa17de4c636557388b8014c124107bf452747774d7319a49854d810f4c2ee2a8f4711cb042857656703801365aee475a6fa931d252be3f6773fc95af0cb15161a129f607be3da55b6e9d38f6b40ec46c61ab3aebded27fde959848488406ac761e25f340095173a0f248880c844f71499a130e1f14f058523456abf2d7e46295bb02200b5c0b302d9f91c94ddbc05fc03995b57b03deb0d001ffb16c4a0f0c59be6db6f35f60f14e80f3f124850a8fcde94f84faf6c58ac909b41f0f77e7003bccf7af37936eef9d3148770df64e020734fba3d66d90484dea8a85b200001f0323874ed3c3f61c9a993322d400b8b091dcd1f291705362ca6603c7ce4b0f1401b99e445a2be38e0fb0c1586b09642d0bec8b8013329354a4b2a7ef4eeb5d612d35f025176ca7b4875563e56441af22bedc2a3a5f85556f9e968dbe175d078607a59078313a6830b02d3a8a82954be0b55c0d2170e7eda55b8e44cd517f3bbd86cb545f8c9d51f88bc93d051306d3eec395b90eac73e2a3b33b82d60dc6c8aa26c1e803af4de069ebf9d549429eb3009a03495bd3d2bf15d29b7dc87da5b3a61c9a6481d0fb401e9e807a7c596eb78f5faa0c790a8812dffabb6474c96a6cf6fc26f3cab265e6e4c7124d5a541aeffde81dc521b54764ec8f06db1d17395ec28f488372fb267a1e1490ab70b5a8d9cea07d46b36614774f5837f7673dc6ae8c225c37e0bcf85f989a588c59218849c23e6c0709bb4de2687ef17273d54ec99159b682db34aff20ba131f01399fa922e502152ace14db0b73ff23a71535b00e8ce12b83d321110997cf66afaf3d271f2b1d81c8b99c2950a6418eb01a8f3c8e4e844f9f88bcd552fd61c9bcf142cd34a4b154673d9a0e53c1e7f77440b82e627c9ad1710bc21035f195ab877ed424ffc4c256c40cf2f138d5cf38b17303ea6320777853049e362bc0ed8b9578b3f0dd85721bd5ce3619f4bd04837fed60e8bfb0c3f3ee565d434d655f69c2da2109bd88209c6ff7f8d7613299beb9423216fd4a81da687a67b8a3630061469cfcd9ee06457e021b8cf1c6488d0173ab8a34274d65fa4d49b33112fee4f58b2b70eb1aeed183a4b2b7e8f94e13e9745922dcaa0ad39bbb14a79e4a9b44c0417fb0bb9abaa8f5114b909b0a702eb3df22830be345bac747db63636b5443973305e75180db82d16c4210a3dac2246d4902adc98d7228cb997c650436bc6f0f43a1d73b483aa936ae6686f773105b12b9f88ea333418d92d5f390d8cf56d9f419b9ac67e35bc9de6dca913c8201613e1f0cb15af1739678066c667341f909cd5e19e8a9d2f7455006074e083b9929b54bdc2be816e5f61374ea480e0a927bb44413f5d730c6439ba342edf7932fe3f26370f7b6c37eb24f136fde8bf2a3ca7cd69dfb25e3120451fed06c053c903d5b2aaf0ab23e06498779b9446cd670eda5ef70c5d2cf7e6508df2a3309284d6a47e988ffd52327346a0329209b125bdf806cf026406733f3c0a257a9bcbcdb4ef47ac86babf71f77ed7416207757921603f2d86b06c019673abb4529c9fcf2a628a7555dacc5bd4b9e8053956230bd7f7ef9bc40cb5a9fbee71f82e951c6dd81a7549e105a63e00a546530d815dbc41e1654c72954e171a048de7bb9ea7fdbe5f635e7bef742c24b9bdd13437e09756ad477735d4868383578f5c47230c51f486b5fab0e8a22e22e7cb5e730a87998ec29b3773c2109e54b8c3b14ea47474a679d8a12954c65c57789dc56b74980a9b3b018f267206c34c230e10d9e28d52a7d8837f992b663bec0c6a6ad4a5895b0869127bc7028723d95c82bfc815c89539f9cbcdf0c9de677532fd44f86a5c07898f8ef88ca7021c31234d704be293b8fa7a4689a784670fa2877267d9ad03a516b9b392c9604306cbc9a661e5b7b9538aa7f91cd1e48142b5324ccf0050cd2bd10004bc493c56ca66fcd5122249b99f7ec00e3a832da97b946e225055333cdac7b519fc7abff7f709a843bfdf3ea5accf75044f0bffb66bb0f485218f7b1fb0e851c622b0d9d56a9f59cc55349508df9f926900d4e4ef716cd02f33454705d6263431fde20164497decc622639be2a4c60eb86a225e7afd8a074aa7afed78bf061da50a503203a9ca5f52afb6409634f585ef6e59c645aad16dc4999855a40d6e5bebada1bc65334b66501bee2fa6afc5f638272e6008a596cc77caa51afaed2d550d986d4256e8293d7bb705bab5be4aa51d53eaa53bed40166b2bf678c7c3b84cd40821365283b9b696e149052de9540a65d528d289da63079b3b2d4a9c3ac4ca99f1f9d97f59c9bc8205c64f3391a3a75381ecb68a7ba59a49b900dc9c20f2e9ceec6a14b5ff0a4a4c2250e5e119c5ca29b86a6c15da6d047a8de4153cda97e2571b1cdfcd339f41229c0a89b7574d4c3cd884c9c8a5b0a11db92800d4e2bdde41536aabef7c963d155ad2fcbdad1b8876ad5f6ee9eda84ec55256210675322c273413ba07edd5ef5cb424903bdfe9adbaf0c34b55844d8436db5e29889cfae3bf98f1bd42a98b319774bdeee355c3937c752353c33c2b0fe4a35309859597cfe4fc0463caba80ca44714501073801a045f6945d4e0f7a31eaa92a377fbdeebe380e2f15aa3d0e2e828e16776a5f276ea98e31f8a6eac9281d1c9e2d384732c961daed72bd9be906012ab4215a37e57b11c63b89bdd8eb9283e883ba688a1853c7a185054730fde670d98bb989f9027c6aa49fa9da1c4858a1ef87e904decbfbf67852e0b9ef68f548e6879d630a040741b5b6d18104591fb73bd56a1d0d6c4e824942257881b6eba437e500607e261d74509543085e426ad5451ef6ee4452679029b1a9346806fe40e02ec9cd8903cb4e700c4b4168c4a6f434a2d9ddd983f09d56b72ce93233d77929ab4f85f0b041c4c994b960664ee46db2d1d85c822f32a0e0456b47fd4a323fffaf4735f78cad8958d53213de33f68c890f84f279a1ae91761f0beb9ab4fa92acc9cd76d9d77c65a76858019b1d8670e7cc8f088f6e447e6f6028cff63d4d1dcc1ee2e2e036c29297a4b6a7b877830965177d600b483c08d26a65e7c4522b5651b4061fc8e0821677d767e69d49db6addcee8f2e88c66805aa326b16ce758ea843af3264eff39a19cdb5b1c38bb8a90aea4b7adc5f4a5596ec2ae31328cb3f18fe0ee7e4decaedb292ddfa0a8a99e352e31544b3e1c141e8f9b18e43f16482b117e8af17c19722cdf12ef279aeb56028e7f0841b97bdcaa60103a01ab908fad811f21648a857db2a909b08e0c6347d475bba2d3f60706aa1c245a068a48fccf400556d8288cd5e0d9e18fc483364038e9a61e68a5e43553b508276262bd26df691131b9c8a6847dc6496257cf90fb43ddc5208ca6c7d53af152f8dbc4e7d6fa71807ed98277dab075c8461a3630c0f9270a7b8911c1e1612ca0be2704bd95e01e14adaa79dfe849afe1b9e5f7392914eaa8da101b354e96a34c97b24623e3065fa257bd70ba35f7db335c15fd38f955d3aaaf1d80883269519aef7f4aa2b7b504570e79bce11e1ad236960ce1f8bc3cb8009255f9e3561303fcf475ba9c5be27d4a4b84980d98a421c77a890c038efb1c9fabeeb4edc7eb406dcf209f6c91ea9a7e90bf4762a1d432fb779a95490ab023e51e67c3ebf2726d67bc0f241bb9f586eaac523dec0ee52aecf3133b9cbafeb01c896a3b77440f1788aebfa2de050bdbd38057c34016e782b2b182373df6b611e62fe63f349f6175eb855984d91f1b97a3537b87cb15e7fb0f277264e2ab02e964bd894e4743521fe00867fbcc0c1977b8f81dea04a7f6c6481cf325ef7a94b3d20c3b3cc5097bf1603b56ac17b41233e3b0a46d5327f92b4c6ad8d1610ee925968149410c99c8f56c0269892dd822417efeb4e5d6a1571b245c25235d324fbcb3a77e61b4e7c07fd3f689cab00eb6b289938c85cbb65dacb549f64faa42e0b0bcf49f10c5a8bd6264a59ff613557e0dbb32ba198ebd1d380f71f54ad6fdb1f8e4949b4a1a37fbc39867f79aedb0b7432a45f45d50e76e15d754892dfe836889836a64662c1f361b205fa91849b3dbcf75ace537551f5850b97aae14e4045e866f6e9c3fe67238a2b898d64db4ddcf5485d30fa918f7b7920a7578308cbf3ad06b8c267eaa9186c05efa409e23ca5cd97ce210f8d3d1e0e4b5b7b5d74558f32fb98e83573caa054d8c7e2847823bf59412217cd785f70b5d8a8cd4f6aea0d00bfe13d7fa603c04abc1553bb36ae9c2e03f7a8abf64e6e60fdff2d087fd3ef1fff8488dc1484e486e456e8d1486f7f0c5eaa1af7d939efcc01dc928a6206bf1e6816350ae2a9a38eef9ed794a9407093a94130fc75945ad5b175648e9295271cfcca4663af4567de94a2511f7134fbd6af477a899edf1ae027c833536f4f7e2cfb23478e6ab9eb1c415cb482dfc97ad4f950538982cd80e05a86cc383c3eb682816feb4a0f3c6a889aca28d52a35b1540fc0d21a7c4aa0aef92daf2dc774b4b51d4466f4549c1c76917b8475c4b72d33150181a942f96abb186b57a12e3d59d4b2184f4b797f08890d0d80e810b293eb52e563ed343171158d35ca06d0869e91e3ffafb814d55ca290139dff472e6bb32156c6a4e5819c019d573bc6833c30dce41ca26fa00977291ccf31255fa827a5fafb87ccd2189596a2fd04cd649bf192761779759fc2ec182bb495157f9abefa079f950fd2fec0eb23cff129aa0178a290a0e11d3859a0db0ad59fd6d898bf7c87cadad33be3925e34b290b8e66dc7dcd5b01a5dc771b25bd1d85d3c22944abb347c0e4fceef44905e68cd475c5cb3d57a3a0f0ba3340d9c3bfc0478b9106814f40e7e911cf8acf1d4785b9c8c19ac7b286fe215d1f444df30061fb8ccfd48afa6275e54ed577f53d50d4e301e0802aad4621e7a16fb86e93f0adab8f4c8d9b5776854f028a733cc8dfcfb9dbd9ae99e112d79f8b26e159c5755e7597942cd2c6ed75e4ccb2b6a257b5361eda52ec503ff0f3c3e7d016681a648a0034d1bf850df87214a9fb78de9b840555c49094097325ab5389a1dc25e03735443c56df0aebd33c5b1b4e5de776812a30761353c3993e4b226ca1f43855146ee71d600e618e68a553a5a87319fa58868ef3a53547779fb698b123f74b3264b8cc9a7bbff506898bde6af4a3de859e7d598a5657f36b296242ebb07cce1181eb633d128e09cdbb63dcb7e36c5ec03d3e2ab1a3f5ddc9a9914ae730a577901ef5bc05af227bce11c49e9f9f4bee4b327801c6ae4bc1bd6728099154b9422e80d0a0bd0a509fb3431bcac3e66e19617ed21e917495d9c4c20e7e543c06bc93b455da3cddbcb61e75cd27b52ba7f851aada20e430ff69e8ca63e3f7e72217a7f676052d2f49ec7ef4819d53bc10116a93cddcc591cc03a46d372795f424554eaa90761c03096393611ccb230206fb953e8705c7a520b17a1c61cf7542aa53c3d4d2242308a14da12336175f28ae7d24d1f343d7adf995c49a10277b6d07510fde72341964da758da5aafc7311ad75e5b786a449ca4eeecb52c78377a4904f91f3a927d2093cfaf4f35c202e012d161555671e097186505d62b7a0f090069ca903872f6e3a5e420e10da21c1e288ae5fb49e3ccf7470ceb4a22d28153bccddc787b0051934888f1605fa5c2ca989cb11e28eee03af5224ff111c938f8124da30ee7f5b68bebe88cf598b5ac85cc75131eecfdc9abce6525838332cbf72cb9b4b1e9749a2976900ddb477694f9af7692ccf595e8fe1738eb732daca8a4597d07d3300a851beb2db9d7a25e4588c13d567b4cd5b8a68c50096dfbde9b1508801b0eac28cf3b6ac2a8891b318d5fe83cd654caeba62498bdd9aea2a23b77e94db2d39be44315ed8393c952ffdba18286bd08a1ece6e961cf98494b4aae0b12a28230d0e88ec21a415b728a26e9cdd386a01f668c92c454b65212a761e1ffce39ef8df8197b9dcf03e8ae1da5788c2bca3eb9cd631725915be7ef9ccf3f29665b7545b1635223b5d1974bd87471d46795b4d119fa4577f682fba763c61854068f40b53b268544074a63c34434caa726737bbe23cacd4afe1fb9da7391e01ecf967c9bb293e0897c49b16ee567720bf63cbb5e7f61c658637ee0a425350dc7b07fee8d876a258e736e0976ec6a65b9d4c978403c8a63b4d6a8e415b3a8d30d818782270404a5f765206d0de0bafca23ca047a4c185355787a5a189c9726fffd76b9926dcc539a460cab4440cf0206062c208edc34e9e81218d7fb3e5030b9384810a576705a5cc8d19b6bb97f033cc4f12cde851ce02f3a65eefadef22a41ed552d201d2d8939ecec6ea956b9a2f1adcadc3e2879d2564122bb77099af708f9f84dcc7b638dc9b99985ee1cd3faf6c20b5f16e59061803b2b4bb5d448dca941955be09bfbad1af2ba3249f15e91dda075fc80f0f6ae010d197e1333c37a3a14d75c8a51a155c4e62659d7349551a0e41599748059fabd738317fbba25cb754b589e5c699f4d74f2156d3c3907c36102fd0ea16076b701713b12f03939737999f7d04a17dfe1202386b4edef419eb415008c5d7d5b4dd9d6514babd7349f504f65f56cea9811bdc819350af379c2c9f684905662ae9de56c2e84b460e2840d8ecf43e1208a1fde0ba22c5e908d49f19112ce5300cf30844eebe621e538faa12cda5000da6fe9b7515fafc009e8338ebf951cc7abfbbafa78a22c4c3293261ec7912774128d743abaf3abf45e19341022a9ba9f0bc0c0d8c5046132cd19e29ce04f5953bd06cc1a08cad3b72e964c9b5130a546b8eb2b110b773b20c618b1aba3e9ea164b520a5bf017d9bd8125fe1bc8820fd38b22f6188d83b0a24044543113cd2bfc30c5ee60542695da737e0f87dcf8ae7b801e698771bacb664089411c432c172fded235fa34a0a9f64335da2efb10786db715eaf3a88bcc0b9c9de5b08ecdcc307a34852ab3f2352e71d9ce1ee85639f9a1c0fc27deabcda764db9966302a299a4362f4bb0923e9fffb1695629439716ef7c8d3ad2ea7f414c37d05c760598bc46e3f762b535457107c9b8e00a9e428094408acd6d5c52dcc7dab6b09fe48115a2bd088fd8ec1e2a9ac597c10626ec880aa1b76ba0f702321f7ff9a0160341141e412f4a2e2998c9b4fdb9e2c6e903d97c19da9fb3e1ba4cd104f8ed2a4bc5fd679a7ec04e4dfada27c5db0698bc31e858fa071fa44ba0b03ea280b4213beaa5712078f018f92a6144ad7aec2c7f2fe0b4344bb09161eee5ced6a27cb1ee1f4d8931a85a687f5e0d5717cc722748aef0835a5588fc9c81a899be2240042eb3000525ef2bb967be0192f89946015be96d647b8fa32f1f4619e1da41c4f5e7f25dd9363bf3a6d285abe4a549fb03c9e9dc0fdf9feda1247520742fbfddb17dc1f7bb63fa9795e90d7dd576c01c9d27397729a9dde17fd355283fc8c53687b7d0fd4ec62c136d61a647f007b07685e0e396fb2d16820365323cbda49788398d32ec38e8a30a1696148fac0abcac17be4d1552c95d50d6defdeb4134d1b58d29300f9a8955639414fda6a4ebc60cf7fa3c19d5fccbcc65eb7afd580763bde98ea6f521bb213295acd88d22b0217cc4ffe9dc9a666ed1bf8fab9e75181fd6894922e9af3f3ec88bc04c4b003e62fa8ba421d06ddfcb514790981e5bd339f7f92da1b67a9f7ed402cf286c473e919a6a27197103f96183dd0cee1871109b1d9e18150081bee17692fdce57658c9986f6418fe34d5984ebea8cc3ac74acaa05efea058a1f52d860735944dd0b45755ee6db400965a753357d9b46487d65fcdb05797591e2fba103a86ba67f559f163058195d3ae6486d6e9889023baa780c6a23fd704e8ce54284d688cbe2e1239ab47c2986ee1f6b423433124db33747be221b601465e3e58ca0eaf90441ecb2a54ec507bd82cb153e8bb43dc0e6af0263f14d250de9be6484dd1ced75c04f5b71db589105e590bd504a0bc38e77c5d700d76d12bfe5526fd15b854f21f9e41d667534563ce50bae27aefc89897f69cdf98a35912d01856506c5a38c6ab5f29cc3fba9d7de4da157589c6424dc1b8d52abf05c64e723afcae6d5eb5413a3f01dbe52da5cbc317a3e2ea75e095f4eae615821a02ab3d845ca46107151133c098808b7e0b8f794e8b9df23cc4085f5b6d40d86831aa053ee77e525f56e908d8367d4164e69d317fbbe84d29270e0136bd996515a8e48ee0ef05f4764f0628a7049b264c8d0a9eb11b43daf2097127cbdeb62772b0897374e6857c9ba9b4dbc06be0c126027b06c972ed25450577d3f5ad2cd6b674d860d89c9f9bb9733bef175df052463327b56526191e5f08b47b80aae46f411934115f791632f5d0cd9b90a935959bb744465487b26388022dbf89a55783ec9f58c5e088b1d3d13978e3941dacba3ba38a99a1653c124c12133ebc35c403ee3f2b085ec5d32966f746403e017f19f187504493250b2994b01acad2b5975cebf96ccb0721a086916590f0b85d89511212d7f80713ac8ece129422d76ecf2bad19f6ca5633d766d1d2f08b178f2d083b0ddb44f1d199ec34240e013d645f08788d0e0ed0d4af4d904e3239e1367ab43799ad479743e57fb924b48eb8b53c1ac5084ff52cf575ba465ea6ffa5bc1af014ae92e228d7a1c5e37ba619e949adcca8d576393715768e6eb36a0d7c401dc87f74472e1b24f048f21d5eff243be4c04bf662759dabd8a1e21d60cddaf2e1e582246e4be41d361a5b0cb040dea88d67de1606393910c3f9c726c0bc0e2603f04d66f3b96a67e2967b6c383d181a856fb87d633853c8a88ed76daa5eb7dc7d963eb5ede8fa49745f28af826a6e6cfb6acb2d3a5424c7e3a85a595440cbe22cca3b2ddcfa983c79b4a7252fd885b05ae927d3a0a2c52d4425ba07b635e975d7f793c24763883b31cde431fbe680d627e07777e05387e65a981d81a4fdf0a20d8ecaf4fe5f995cc8a4dd07404a5763d876c40bb07ce6a5fb62ee5d5d944684bda6a3d8b4024a36c375924a2af14fcb3bd109c221a3be4fc7eeaf9cc540be0bf534bc3f3316359366d10dd70792f812ccefd569947de86fd2965ffb3f6ffdd8f4c741fcf1e4d7428e9ff90029c8fe8ef82c1777c1199ce8f873b0f5f08c252ef60ff19de9d451316ed6708c1bcb43e1b280de1e6b862eaa7228a263f80f50c59e48939bc2b7baa1d4daed604a5c04fe36f532d622c6143e41cbb36006045d87e8126f71ea94b3bbebdbbcc2d5c6fe301b8e7987560a3f91af70e5eab5191d58ce74cc7ed8d198b9ef777346c33e93585b328eabe4abcf93e024f2af83a805d124f9e58f199c6a62a051631dc1ad367ecb89ad3cd08964651313588a6887a10cf8dcd14e25f0e8df9a8aafce89985d26a9f0b464ebd27759b882a07d0fe8a6ff1d85008507692b1eaa144ff642aeb10a2f1835f010a37f1a9ab7e3e163f76e41c346db537a31f4d7362256bb26c1f98833d9254618d0886334226edf3d1b289e34295fa68ce2c0bdefaae9e4e28cfca7989139ab3f5024967a0f47c5d4d1eb983d4cc2942f17317346baed2ca531dbe09f48f6fe33b87a80ce818dcde3e78f9b9fe7e5d235e0194846168f616afbeede3cd1655ff55c23a6999f578febb7d603d759c58395303aa751cd6d0b731300b8e6bbf62bf33d23ede4803e9c264f89594838cd44befc0ca40b13e52d22e062119353605e08a427cf4be9849b170a4d9dbc063ccac2669963a7a19c8950f97b0b23898ba7144f7c3412fb00c02e64f1cbc581a38b32849a2083c3de58c96ab196a098740ecf8c34a6d2497465c3bf3a83d0bcea8e017695a2dbebb7b4ecc0aa15f5a8ec5ac7a7f200726f7005b52537cce0b975daa9611afd291828ebad7b90bd795fb87eb2217df0489099a2554f751508946ee91cacfc019190dd9cfc55b4d13a2cdf136c998de4a48bfc3cc13135b89cf3f316a569ab7617d66b03ad0ce7192fafc200f4329d926aa632e60ef29d660c8a7fe2db9fcfb4540372c1bb87a9acc6bb529000e03639ae328f529573581e3f4e80b4e3d226e4b6568ec56f410477d914cebfc853c41b50f4a24c11fa839aed116a4a356fdf4be793d682b46281e570c569e467629b73cedea20bd1b706dae93fe553c43caa5ec5f9e6e7b73e07b811a6a75bdfef7d83754c68541dacb34a5f14ed0d6cd0aefcf9b5bf2163754ceac57545a6a515f172f42562278bce2b74a11711cdd6bc7dbc6b571e86fb66451b6061106cec44d53565245953b81968273d31a7af3e9aedaed8bea9c94c5b979cbbb3f9490707da018ba1278b029b03e166241124d1479c4e2bfd403e82919b0163b083276ec6970cedd584b42230c5b67140e44350edb8299ecbb24bdedd00886a11502d246ebac9686618d3ef1ef21b18b7a92abf22dcf97eb452b9f61aff88a2a9bb122488ee7c200717ed64543cb90b5776e25470aff32897ceb55343fd312879c6b8a13399e2a719106678ac36787684c2e3bf32bdbb1fc6452b4b83db80785e9f814c64f9e260956f271b3155f7d88f5275843ce8bfdb785fc09a0100ab964d803d614f2e9523501174daba39cafd818c1ee3b1daa69af393ca20cb655878c0ffc26e5cfe1809f360e82f2874c10a69e686365fa783d477a83b6635b9379da869e7bb21fc499fa269552206503fee3434336f96ad1ea6de73cd5dd487c4f9b1e7af8ca70da770c9a6e192e75184a34dba3a272ef2f92d8eb37e70b13db597bce05617ab0ed2ddb75a94e03920607f792ede8cefe49235945e136e1ed19c97e3935628f1c49ab19a6f3065f9f5bc6262fe3799bfd8ce43b846a1f3f79ab1291142b1e39e7cffa6b34d6a812540b8849eacf5d6b2b0bffb93fe594a31b761da211ca9d37526e4c7105ee7b8feeacd47f0d5c6e6ec3525837f801db764145f8bd9d11f87459698701e52e51da8b642faac251cb9e66d007fe0427ed201fe1294a0fcc49eb1e784440e7083ed8ba26330412eceb95d60a7ede4a19722a792ccc8089e846392632bbf8416a33971008191c1441c8dece26f490e0fb2aeb24ab48c9ad0a7aec4b561d5219078bc14cfe6162c9cc40de6ca6017188b39d6c69c04851bbb3a726c3fcf7682f23d9639d384aa781a26236c4d41557f456ac49bc334a929f9adb1d2dd924ade79464966e4f6a0ce8d64573daeda1f92c9280c5c0abecc5a8c5d6fb9969386042ad2ae84626b3039d9e304b378999d12f2830c65ee30825751f285d1645bb0208ab709a17fe1c0854c3b6510a7f10f3d9a9cba78a86e8655c64b758e0577077bd688d46d8764e9f2b2d524452a14dbb782341778c98636558032beb40e5d580adb0c63eaaf0a8e85e39c989c0de1258c0d5db23854c8c268ebdde50e5779c4c1faeab90c6033386824eedf9575d4e273f6e4b2c33796c54bb6e7da38d8b57d268a973b7b7c2af21e2361e1c57c5836b68d5793f1624dcdb08f1f928a1aeebc22cd0e210d6dab7afcd99d521284be317bddc25df09bf44762fe6b930658b5ec7435712352663d433e096ba868aeeb56e242f647836b27d2090f82ef39d9e32c534de0a1a4940308d9044c6920e9bf9e6d2322e90ca02da0d79759ec527ac214d815a6493e2af470a8059d05a7fbc8da48b751b582b0c4b42c823f0f851f17c7e53fc9be2c23b5dd3d8927dc7bb35dbc974ae6b0372aeea20cb245e2d86464dfde4214a040622a3787573f5e50a18fd9eb9dd28a487cb2562c16ff1c55d17190a32cd0c7ff491c1bf7997888fda6545d773a8c4a0bf3eebecce78db6fc0433db782a1ec0821cf4a15d8da374935f1cee7f03950d79e72d300923dc75a41cc6d4fccfdd05a5e894ee35ec32f0e3efb5cdf587861e58c975b284580262c0aca7bbb4044918fcb52c362cee995c4eb578b3d53d304d537bfcbda6e877fbf2c5419e210833f61065060503b03cfa8f4b944165608424de69cddeb0a14ee9bc747407d0a6014278450a810f8dae60d799b0c0242ffcf7d4797d13f7f6ed1d977c3e232aecc395aaeb15e5bf6bce1d1db23c380724e9259e13112703843b5e55f5af6f947f18e873b9383f094bf501cd8503498cba820589bea289d6cae7a1588ea81b8349d2a4bb05741d4592a71260390728747f51a2988c05b246b3726c425a9a6654288ae8b31c38cc289ae0897d60504f377098c9e5cd31f57c0f2eaca024350f8175d4d188f35f63897d30740357d814c71f65fe61e7ef849c7a5309b8a4c8bb4216340635d1714a20af6421847b4f507a64a0fa189d6625bf907f956bdec77a64debf21a9b861da4fc9f7ef72fdf02c0b021c8275e9cc8778365d4c5d7a4afab84bce0e941897c3800d9ba5030a61465bbcb158ae54b49dd699d0c893b9d2a13474630e7c53535c1bc7703c96257229774af8a3e947c19f55285bca48484680cd355a98aea716dd4b8416d36d7911e52813a71e81fc83145114567dbeaa2f6e3d0a722e1254c1820f730eb6b49c614c012671099475c2780382e03867f32a43eb5b371794b68b96bb2af4e23218103b32384b40bdde44b7f6fd7b183bf19daf57531f949a40f504d930670802b438a9236b75baca040f0e49d87e32589fdf75d6b42060390193b771699baa0e94f2bf385ea777cfb602b897e0f67e46923867341a1e21622f1deb8210514392667e83d84c5e09aec1841cbe7e2574a906138a2ff6f2019bc07a3ceca7dc0b21c98d02c27fb1d260eea775e1dcbaf724de0654f8f7e03c36535c2c04e9e6ba6f853bf786a9be4348b101da61c5dec43be4d051d036ef1176e6c740c305ad772d7b79506e476183d9516a4cbcc7c3da94c69cfe1880ab418fadd07d61a2429c873bdcd414a6fe55ffef4fa1d43c874e4f7fa9fa9e53e30266950a27a27609ec154ff043d2367f37440633d9ffff2286ce4ed298cb7fc339440df54689f91b02a23b46e46b6e0015b9d39103d0ae1cee2a5d8b84d6f8b7daf9447439da96ccd1d64727361046816a65167563127e80b1e863826360973c70b51e5ba2eeea267029d579265f2d02808f0172a0b3092780cfb3424d6ee6044a13e3368c256b57bbf8e08b00e6b462a9b88d8301b1b6a3cf0a55348b7c900e0c84909dfa3732b37272195eaf2c05bb2d415494dbdc808f1c2c66b643c73f02e6c0bfecfa254bbb820ba42b5fee617ef62a173284e7748bab9f271282e45d7087302d5f42f6cad071c8333d758383abecf15468dfc4e6418d565642e88a91679c44758f67595893eadb6db89af9651ca8932226596758bcd70e4a09af16bc164f313e4e621f7a47a4387aed7ec7da45fd83fb4d10edf8f37398466a224d03a43d17ca406666cb4f412746c45b0bbef2417dcfae8d621f24a5cb554a0e48d03f60192c2e0cf4f1d986ab8a9e0774249f86637af871ede17ff995fd59084ccb1fa3420a1080956ffd1755c9fd7282ed965ff1e37565e72e94c8e5a514d8d1d8eb72c77b15d81e31f7379a53f2f4c0ba3ffe16a6e14b6212396a53b1595b17e59589168e20cc368152e763fb50f605cec53927418f5aeda462f66c2939583f9a1d272ae28cf4ef1b1553a5bfcb9565dff4ac86f7b010c91c11cbfcd06e98b79ad1d6132f8608638bcae1d9c5fd48292e720f99f657f2cc100b9b19a87ca79cb91f9790e211a97c2e5027b91a5595ca0fba956f11f996344160c0f788c50684ecde7393d5d6751544f1514ca6de8a61bc5b1efcc90e9114947a1cfa2b80af9cd4b98e73a05bc60abf6dcdbdcdae055bb8a832878796bad1aaa79c90d5b61d106d73490383ba9eeaa3d10773837636bdd22aeb710b6540482456d47e3348305c4a2aad8d7be8660936433544f4347ecd6222a370577ee871a298f747276e4fb2d3bd7f17562b7241666ae7bf28f4bf483ddb4ba619de1a2651ac856bb37f71fc5ed909fcbbc96ae166ffbb8210be70b33f0696aacd136ed96b5c6cff3a4ad6ae1d46b36dd169ee5c912842fb8f3bd0ca4d1b91f67381de78a194722d3bd67bd022c17eb3c226b87f5214e4476ff794a45068fe074c9b207aa2dfed8759b8ff692b1a84981f8020a9067dc5c8342a594f6c39f6708675c310367137157017123f07fff05184b1767fb3e1d314a657229edd856293e569f26a62e403e049947910339d2acea659fc6582c6622fb49d5de9f6ed770b83e0edabba06b011457f713472a4411867a4857c34c22a510b63624fa55b5c1f67fef8e1f43f560cffe27f2fd77f9ba07e08f7f6cafe64040d84fceaec77be1e026a33170fb7a3f8a75945083c029f8b5c16decab961942fd479e98a1b9cd64c5cc6484fbaa12c21959f413a241f9f1850dc8e325d5ee7799f88db97315dd2daa2950f8e1e52b389aff110ac9160ec06ccfc129cafcef7fc2207e2b6807edfe480be00487eac3d4b3573a89cfc0474b090116883d2836bad013e95398d7533a7284310128c862e1f74e9b69d22fb51334a6cf0ce9407064c21e7ecb403a0d0d5323c43a1bb2f774e18f8d4a2b1e42dc615eeb0ca27f1ca24d608561ac193726e1647d7a4edafb5fbfdc1d37ec542d9d856290991a4e25af92bbecfae5956e636d090cbfea664b5598bda8f29328582c501cd8ae52cd5cd8aee4e14a8ae439c32930737e6883a29bf896757d13760e5a4a896a38ac35a8a29244ba5e68c06b97e6af967bed5de8c56e3e5632487c15c0750853fd5c833a797bbb52f6db27731b943ff5a4f1224817336b4eb386ff902de0e02094c16f6c2a1ce82b5c1fdc09be2fd9ca2caf5f3757179727c395422a0228e10abe6fbe03adb7c1eb8ea6bfbfeaab4c416f5f2296f092e1645216e13dd60a6d97e0dfcb6f61ada7210845760336c6150d6ea09313ecaa8b00a7d6ed29c11df0fc7c45e41ddec514f5563c6a870491c464e0c4c5b62a27dd644055700a69ccd450616f94f09a2a1811d1d6a5f9aee55c195213a263f1cd740d4c874ec402ae721b364b7c273c91d1bbe29806dc2749ba1582f64642002385555594e1bb81dd4fc87062cae740b0f0b6e726a098b1414515fbb1f84688e55b1283694af23b228c5520bec001889014adcf43a14298ab9a0fded8c2f14f11a8160b04548a9a3721640b327457d82abe57018aa2b96c4c69c1862676f530cfd158cc53ac996c946d6d77526b40c075c2c08b36ee29a0418c5843f522282b9e5f3bd53888159c85106cb060b5be4cd94cdfc77e1dbdd434e32056baf1e121ef8de2a395bb630ee32bf50beb00413adea9527a6b7ef975061dec5008882c34e58256ac70e4431d633746861470545773c35ec92cfed2889712c44281d55bcd982fe3b3bc7ff1071b5bb10bb900533a8c5a6547dbf2319b42940849e1e32907e0fa8aedb9ca7685f18dcc2f5cbf21f26efb1caa5d6694e9fd0c9c75c4e1f3c0ebf25b63b673479ff60793640d91d0c2364a8d28920210491c246b647a6a4c74aa7a1d6be72aa2c1073dd109b96ba332cf56283bb2c31a50d5e3f87f1feaa336912383a7ebfd06b7528ced717f23494f1ddd6e8caf527960e0d7cea0dda42f8c2ffa8c559b4d8f7484197c1f83e892678fed5eb1eb929a9931a029c3c263add96ca1550e6adcde4d37cc265d69fd003fc255b0f3f8ee511633cc9919c863edae4348e8b7f88732265f2ce140a88576126d6786df71725758e4adee3efe0d35731f434ee75d22be9920b7b520690560fc70240a0d0544a897a371b77bbc8e0d0b92806b75f5d64f7ab9001f5887e496d1c9363ea66dab420d7bc698dcdf312950ba637fbb7491c93cb8157c6978389b14883d6a831cbe2b87de081370f11061d7a05c3c084d47b5996a1f26157b425d6c7c01c949858c908e17c5aadebb063de4d8e7ca924b4fabfd7efcd3a1056fac4410e3265617031380b1bbf2a3fd9401dc4f4ddaf40f7723b7b6918f2c2fe3e78d7082fdc00c8a88ecb04a69de8ff9d196aa880f7811488b79a6fec42c24e0950f06d9ad20036387c6859c3fc736763aaa0c3c138efdd7612b0bbcb7ee6331c754a8d60f09d201d9f75a9e1a611e7b5c60daa7c32fa4818498c41704380877a7b9386b50ff4b0ce614e8914e45ac1d34cb62b5de173b431aad66e57e5791799dd0eeab115b15c7f0f36ffd222656573637a487f9c4cdc610cd28335b25651e60117dba26651c59f975d9fc5f9086ca6cd577bab44c62b5780a1660b45ceb38e6dfda31aabc8c5b4605597711fccd8c6eedfc2ad058865300f8a02ad321665b2f7bc97894bb92845ea4578ba33f74786a317481a038807c6c3d16321c9c100c85260d694a3c78527dec2b8d90af97d9b10dd80dc88870f5f1a1135e65621777e630b0276061c0434a30c3bb9dc36c19478bcb4fe62ee8038977a1fe5a0066ff9f3f29e532c64e665552b5a2ec5cb5aad486efcf74896861ab7a2adee9ee674c8212c9f43bcff5a81eade19b84fbb4528673b462fd36c4ff6ca6c0aa7d0133cfcd227ce988563699285d3868c5caa1595c3b73d1fd32eff73f5d0e61f1a0b110f19ccb68fb7e49833f68478c96123aa35e2ed57e757cb4c9daa41eab5a9592c97c91d697c30c18f91cb59eb8976a68d8bcbd8b7a844df96ce0a6fb661e3c502c577b1f0e241ff8e1b3b75bfeba65a87ae80304067dfd9fc689dcc01e41c1e0bcb8be34ee5f43bb83abbecc39f5c0d5e5613fcec083a99f6b673e89082d15421c934c6f9956541ea8ed3c793139924a520af20eb88747340cbaff3cd20773f7bfa68b8dffee62329532ef1a45a638e7ac3d9e9092f80e803de511ccc6845d6b39536ea8adc92cfd050694348565fd5f8ef425928f85d0a1c6ea71fe264a7f5afe08936cd6838258863ad94479759405fc75e1b878462cf2818baf48e71bd0285ac9149ce06fbe1bed29edf0bdc39052c019d0bef14f8f5b6e18a081fdadb9b1d3477010a684522e55a682361df9c48e0ddfa4e106198258362786dc2bff8e1278e12445be050a31d18bbeda71bf59be9b0713687403acd5c0cd51ba46015e3efa2cef9f106a0220d88a4bc31c906797cbaad7e70e07d2bd53d7ed9628abd899f268960f5f97053a4a44b1bb0e24fb6a8c61ddd661d8fd20e031ca338ad33ccbeb0acdb74c8c63687474b582d59fa7c69f4932e81fbec12bd4e25815b8b2344682e6dea657a99efc74cbfe645837d7f1d972cde73461127c43d32a5030e916b9e5bcf4e1a15a34a19527ab72c78ac05b7cf5273dd9f8f48130275013a31dee708ae2446689e755cb90227b2949db030113bb31d0fcbd78709edfe515b2a0fe8a21e9e08e1c077b46e3dcf90a0e08bf93af5fb2ca09380cea06c2f53ef86af77f604a32df4303eeb462d285674c9771c586fb726525c163a0011815e3aec892418d4d1c6f3149ff3f8806510dbe4484e62fbaa6d863da3566081860e3463340b19830deb877519181bc4c3104702d57be57436321c5931167051c3ba1897976d4c97b4d77eb15e7182a77e13d024a1cd753b2f1b7220f2957ef6a89e4b1bd985452f6da2452a5fc960b60243f1ddae2f63778a395ff0b161fc3a5b26a4ebe5449394fb2b14b8a7931f372c95848a70075a0c1042f195b29e9672d6760bd6094e784523e1e578e081850583c3e97e6b6f6b538ae5078618d5cd6c1f475dbe9a58dec176f0988b1b624e1c77b9b43f63064e1d77dabff5d9eff01fd841685d3827b5764df49937cc2cef07da87f1453c9416b95b2db4fc67461787f5fd8715984ad1c1f2704d5123b66dee791620f160831e9f331220676895afe56145dfed6e4915000d710d4d27292c23f5a7414f15028d5ecab3887dd964fb617919b78992f53d579ba362be47e27ac35f04792694d6dcde43aceed9f3bd74b38c0c958d902d693913dc952d3564f7dfcce0831f17a432a06d2e8fa5054f31f06b3f1628191e7fcc8af8debd6ce1914ac425c6792b4dea105e64b2cb3a3f15326de7c724a6d3bcfaa7e5f8e5988c6b9a6d16c5b73329110765ab99a420d034469840be823187f83d27c42e192fec85e797d85c36ecd7533fda64013d95e50e1823a2553cf6c9d55c656cf8ff272cb11e975b7816e9ea119a3eef4ba41d1796dddbe0e23dfa200c86c769e5cb8d545352d2e96e6da0ac1fe9589b3322d696cda4a8433c5144dcef3dad432ddf327dc8af01015d2c92e12f0294c956e154317e7213a3d22fdc23a1bbf744f203a3f7727efb47c013b2b461b66c48a29e505f9b7a3e838ea5b45d0cb89d7300966912bf67790ac9c0bde5b16fd8d7c23bc930550a994f18524682d6cae8457a9a1d8d8c1b31a168ae2c9cebe1148f7e43cb9e8b6f9e12c6510fb4eec37685c1efb635711702e4f348e77c6b1a2dd3d00da23ced97a2dbff6d8321448d56025a6074b4086b33f5083e3da33d8774aedbf01220cc131073135c99daf4538b2e3ceb0f07e226b2441b829d55e88597639a87446300fc1e772bf74f8e317a10d6e47d08ca48f069f5f210b9cf41e4a71eaa399029d8e3c46b1c5bf95689e340ae548976ed7f800b519bd348b13f70cf85ed69270686af5b130247d2b6fa312cced4b6ade5b7c6e398b43ff1b73498c32ec1531435a622282898e7a9be4904f2cbb6356231d3933b92ca1bab2cda06716d67373c02bb7ea44e26ef9bea7783577be0ef415e4aabe39d14621adf6bd3ea7a6707a29c6133276b7a11bfdff9cb4266cc9139266413faf55eb17f5f6fc72aa7439c509a0a7f7c474041df2fbffdca02a1f18d5785aa92fafab2c6b75af9c552bdf7ff9c997afb07fa7b84f4f53eb40ae25b84b62d78702a6f4dab72d8b606026430f96dae3c658dacf90fcc5f4c94b9131be859cc08bff6760b85aa648d21a8347d73738d0a1bc2e06b35bc6856103411b85ded7d20f7555a7349acc37eef534c5fd9d6c25df54ea119f98fc6c04456657bb0ed10f5f8f204b721c3db10636f59f624314753e6a4dc59d08294356e3a3ca540022762fd1027ae68f3ea26b1a48e72eed5c89d52dc4dd9bfb1b0f35e9573c14d1c48b6a5f90f492feab2bc56dc3742615a539f1e9aa01100558af33361ae7254ba438ac236eb2a897790a5d5f319ff55e635f86d580bc0568b8aacef0a3cceff3a412106a25ddab166fd390ff6bab39ca5e18b4d8fda2a6340ba7803bf8a326d6ed768d6de6b51593377a2e3e323e3836f95d9a87286ec348d6c3deedffd388dff505ebc08947ebc63abddd176ec526a2ffc84281b29d3ee05869192020fc9a789e814d0093dd15fb5e58ce353d188d4f0509f0894ed8e3f3fb440e4e1d3c9be5ed7891fac61252e562cd660baf4eb4dc0f81f89f7730f2633e3cfe9b1034c91c18f5be1869ff9fc1a0edc1fcf6e302dd86d9bc932792b600452c96f35d7a3f1dd38092da787b5fe8cbec7177b9d6f1ffc49344439431353f72869bb32776434a4de659944f2510db496138fd0bb52dd9f8e84d8ef8183aa9dcea5bc4e7d9e66bad22ce4aaaff19eb0bbfbec770952ed161d605b22d2357b37c44f1f481a5c24f5f2d411ec03749a871ce51623aacc04527104df64ce97f1bd87478956866b8250617a48d51e6977d8d4238dbc910c805d92e6b27666690e3c06e759ca504baccc1f4700228dca1c8ead21a29ed2ec7648782ea5c33f8da5bdd7b15e1427d8cf9868bae2d51e3b31b8a517c476b6a77fb5cdcf9ac372daa9fd41a8cd81b8fc7e25067a63ffb6d2ba9199ceb97780271873d368b698a5949a366d3558a7a0016ece502a8cc7d59d4e0b27f118f9bd1d5edca7df41445d579ab30c30d4566a592d6bcd095f20ec1069e7d2564cf42830f658ebdb24cfa29075849afbe4a043ab391b4aa234111dd8b9631ecf24b9b1f9ef81ec3f4cf084795e66c69a540e3eae31e9cc3824581b2e1cfa8aadfabcb857ef77c1be15837f5d0058af213f601151979722b78be9fe88d1189d0ce4659b15e4f11f2b1becbb344a25651bd12e05f3ca37c848b290dc606bae13ce1a0454424f2459252115f5c43789ba7c089f611a33d44cb00a74a6c7ecd85c0fe25f157977f24e955896eb9e50fc4e535ad7e94572672d9d85b621c1ed24d6cd56a35a4994200d943aa9ed04c50b9926cee9ffa31091761f8ae9cf415ae97a5cd731d0fc776aa8d0159cfc34462fe707d79483ac3d2666b64b74f4367c579ed769acebcff59ae7e156b99eb68fb716bd0dcbb961c588f294ad2e11c1c596ffda30d51486694f858a61ba1fb467ec0c3372f6d98bfd0f349da2684b485894a83f130c076adb66d2bb7a68af05884faa53e40f7da17a2c387276120fe1ba4754d34d78e21d9ff573872aab88a22a22c3cac748c819f1881219b29daa290a8d13c0a375a90900af41a1bad14f0c69ba039ac593d59c03982b43673697534dc95c76dbe69fbc99ba956a988c3c99793dd1442e5bb8957316fe5046205a87022b911a5987a661ed595b08ef072f94b842f367e4e120810ee629c0ce2380728127becd89619823179d2f2b8fae5544147680967b9ea435c2b586c3bf4d7997029fd977b75fb6bcc8d8db46ce49ce1383d58ddb7541e486451dda6e893f8009dfdc73e50fe50769417449f1aa87ba823aaba84e3c225c4d1e7f2163e6af845e40fc0eff7c7e38f2097847387afb552f2be3bdc3fa9a9c64f710f80cac903b734f964b429ae17b32c282b31948a85870e730ec1f391e997ab24dcd11565885e6b75b051229bd4b0192a31163b1d23946428a2cbc231ea16aa7e1e59ee2c2432e2f1779eb6a4ae6c9707afb48d9712cf547bde8ef4ef0704f94fbd1499bc80ba26dced3b8d1defd9a0bd67d46d1f267fd71bc7e79260f54340a297b4f9778a81835e51a87a4fe055d9f95b52b0a37562cf7d56a50b6405411e85cb39171aa8a247eb2a1358d7911ba8731b91d1e747e7e0c454e5590e86b94a6ce85f2a330ea4150ac81b61a1bc8a32a37c94ce609f9b2cb1a3801eba97b16f653caa6278ed39f67141673b14a37350226863975b5f01515ab3e6ce83f3b8ec272a895c69de71ec054017c854ec5afb44d8856da9adff6a86620c71a271aad16ba3f0b8bad14bc5971d327b8907c9ef615f9c90e938158a0de5026d1a7b2303e435fcc2b050f8529b62eb48ac8171705d1f64f301e86e45dfede9763d149461220d3d1f7d7ba6b6d4ca44311849f77cd93a9ebad2351211e4bb285988f20d4b69d59344c6936c2244913bf229756e2a2eb2312230204a9a75c1cdbdee6d71b022c6f7ec77c4102364af65a71f4b8836ae8b04b010b5a95be6f3f95f38520d659e7ff7f8dc7602b3798d826236cd6bd25790b8cef5268dce8ad7549b2f0da81bcc4afb4048b3433501e5a6965155cc13c00e11ebdf54c5b98f7cac0b5ee620ed8c078298a47a57893294838a654e237fe375448dfe55cb1bb55b0f90006815259bc75b9875f3acab5b12e4b0450aa9e5418297ae67ad2b44ef813d9f70830cd13b8cf7e64be2938449e21ca7cc82775695932c793602f3730e2b0e9ca888e3c00868fa837ada9dcbad78a44734151dbb8891ec780110491698ffe0ae6a4cb5971c4bba4161a38028d6e7025ea3e7029ff4446df4f29742e62a7992c7bc3878c78f374255bf21db476f1706ac066723ecde9a187b70bc98b0631da085e47d2f446158e06ffd37ef4a41a868cf5509744b92a8c7021cc1e893406ef1354cb8dfa9c65df9f68eafc35606d3d61636ea64acee271c20e54f40cfe84f7a888a693992bd524a8490d4d1ec7e30a193cb6b52001bf2ba1bf97fadc801dadb9551ca294f2fc4b005c42e8d205ab59004265e9f520fc5b08e1d296efecc4db5674cd957eb6f266f929ce225308d679fc6313f48fbe2ea3bdad95b4bd56bef3482af750cf9dc83889f43f076329a9579bcc7a145f49f072fce434ca03609465a9eb47982e93a0d6495a2ebd709597061422786e9a8e8569dc9bea788ecaa8b06a3d03c26734238317d242b457784b5cbed2ab9761ef5ce60b9cd3cd5429cdc0d04393cb24674ccad416dba9e5bbc4c9d15be1cc1a83ee1435441626d726778ee2d446da761542af38683d993d00c4f896c9d0d33187f76f8d34778ec4bf0cd3cb4b946f3f3a429dc6b09b1ccccbb069fc3d13e52eabfb49f2096e1bbcf8837e5d707068b6b1555fe34a2297685469a218130152bbe4e6e4ff360f9eb1e9e30ac3afc2e13b94678254a7570ac40b317b67299f44e3071a89e7c68b5050782bedc25d7a18b15f2291b09c3a728eabfe4c2176bee9a9f8f192d6c50a3de4e582049650481e8ab1ac6be9db0dd8182f4fafba2fb9367448dd0d861060948d8ec2daad3c55f28014481c2b8cfc45a0618979cb7360e2dd7ce78f4c22d1992d44bc0408a3f5e72d4e9d36781c11441557fe4ce37b308bb2ae0251f28917a798980ddbf57328178d95ea683016213661816872235b9bf0b0d457826f8def5723a4193892bded70a9e84b3e82d98ae375fea457533892d3879287a3b4531ab77d0970c004ca297564e02f93deeb52571accbfc7b1bf52a619bac81c0a614449d733952be5d8712f8afded567d8e255d6cfceeb62324533a2812476d6875169d30ded4b2df29f853e4eb288833eda37dfd325bb0b3d50d4df7a33daf34395c1d5d09af3be7743000b4464575336d97b2d8e91ad23fb2779a347f522e9fdbab3fa45c3afdbc3805cb8f9fe9166ded70c5a1292d1a526b9565a8ea3007de11d231a465dae322aff848a470cffeaad8ec9f14c6701e80b9998a2ab3f5f0ae5335a450269e84bd9cc9cf7437139b2b6cbc03a0fc6b5f1ae449c31aafd6dddcd968b4ae0c7c017cdd8bb400f671fbe35505be1329d0340476ae90d21ac989f4797de05fd29516083dd40a68b7455f18fa4a6490f366f54ff48275b782d560a2ae1142a69049d83aecfc599f5c7cad67d8aa1a0b9f3738ba26260fba85977a7f82cab89153a6bb85f7f6ab72e42e576526cdf0b7a17ac6594b685abe62c2cabc0899151a41b5e245326144d5368cffbad57ab4696cd3b0c57fbc2702317ed07f877f2d782f548d0c071469a1d0fafb0a18d7b1293196bd6c4da372a6cce2b356281c01778bd907b15b97470429750a15b4f5c67b4196af23c6e853243b83d16a24890b751680886dafe4da9d25b6f373ffc89b26e982151d79d9291ece0187a920db93c13992617169632aad39c7c1c5a9114b0ba7f238040531819a78b72d11485eaca49603f5c5319f12d84ee93db71451dee6714dbbe4188937a7e2231882b2f9b40e839bc7b6621863ad614c491d6ec529ed6c7c591a53a4de8890835ed21484e3d98864ccc53f47f40d9a18a093f68335f6fe762ae88f85d30ffac9074af479b54bea2da117710611d03fd729f9eb3e55b47bc90242d7fff737f614cae6f2208b2aca6b1ed490682acbc934a912eb472be7ba565d4c56be377dda0ebcc923a7bedf67362d2a19a7f1c4f43256fcbddb1acd129ed4cbeeb224479a164e1c24996aaa0b8e679c2639d0e09e026e119f11858edf29be4db3a814207d7db38dc97e426e2a91e8a26c7b277dc86b7de85c57572991b7c6d589e6dac5cd90a593cac9fb77516d02be76970c628c2a525f86e9c5fe8c3819166b2a9403cefac59c5c604211a7443c9a1aa2070741743118437e5bdaf237c8c45cc48a9676df01d7d01d1f062a8f29476ee1b5639dabd4bb0d079e3fbe7d61a1c6ecf9079d2929f0a002b8fd9744da0dde894d89ef97072388d363d28976fa3acf7637cba633e65a2bbab7faa7f0098aea8cfeac374ee366116a6aa98ee52fb1d33ffc1096abe59a773d13f64be4f727feed3b285d692953a1fd6f7ca4969d730a584b11e0fa98c341df022606ece129d5786759c50d5fea0d839a5c509f57a4e26dfa65d581198a9c3bbaaf561717520bc88084a8a03991627b1cdb9f2c673258f20cdce65f5eec36fd9de81909a52e7896f1a8f2487a69862f09715e4f048b57959ccd34c8ccfbf82c629ffc1b4f6d1247679970d0bfb6c87e843d862e87b84ddfdbddfe2c6a5e68eec81cc2b67</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-swup-reload-script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>算法</category>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>比赛</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题总结</title>
    <url>/2024/04/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="面试题目总结"><a href="#面试题目总结" class="headerlink" title="面试题目总结"></a>面试题目总结</h2><h3 id="1-Java-算法"><a href="#1-Java-算法" class="headerlink" title="1. Java-算法"></a>1. Java-算法</h3><h4 id="1-1-运算符"><a href="#1-1-运算符" class="headerlink" title="1.1 &amp; 运算符"></a>1.1 &amp; 运算符</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="comment">// &amp;是是针对二进制的二目运算符。需要注意的是&amp;&amp;是java中判断条件之间表示“和”的标识符，&amp;是一个二目运算符，</span></span><br><span class="line"><span class="comment">// 两个二进制数值如果在同一位上都是1，则结果中该位为1，否则为0，可以认为两个都是true(1)，结果也为true(1)，比如1011 &amp; 0110 = 0010。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;还有一个比较重要的地方，也是面试中经常出现的问题，即该运算符可以计算余数。我们知道四则运算中速度最慢的就是除，而取余操作更加慢，因此可以通过&amp;来快速的求两个数的余数，来看例子：</span></span><br><span class="line"><span class="comment">// 想求45和12（45和8）的余数，只要求45 &amp; 11（45 &amp; 7）</span></span><br><span class="line"><span class="keyword">public</span> ModTest&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="number">45</span> &amp; <span class="number">11</span>);</span><br><span class="line">        System.out.println(<span class="number">45</span> &amp; <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="2-mysql底层索引存储原理"><a href="#2-mysql底层索引存储原理" class="headerlink" title="2. mysql底层索引存储原理"></a>2. mysql底层索引存储原理</h3>]]></content>
      <categories>
        <category>算法</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>鲁迅杂文片段一</title>
    <url>/2024/04/01/%E9%B2%81%E8%BF%85%E6%9D%82%E6%96%87%E7%89%87%E6%AE%B5%E4%B8%80/</url>
    <content><![CDATA[<p>“中国现在的人心中，不平和愤恨的分子太多了。不平还是改造的引线，但必须先改造了自己，再改造社会，改造世界；万万不可单是不平，至于愤恨，却几乎全无用处。”“我们不要借了 ‘天下无公理，无人道’ 这些话，遮盖自暴自弃的行为，自称恨人。”  “父子之间没有什么恩，这一断语，实是招致圣人之徒面红耳赤的一大原因。他们的误点，便在长者本位与利己思想，权利思想很重，义务思想和责任心却轻。“本位应在幼者，却反在长者；置重应在将来，却反在过去。”</p>
<p>“穷人的孩子蓬头垢面的在街上转，阔人的孩子妖形妖势娇声娇气的在家里转。转得了，都混天黑地的在社会上转，同他们的父辈一样，或者还不如。虽然人口众多这一句化很多人可以闭了眼睛自负，然而这许多人口便只在尘土中辗转，小的时候，不把人当人，大了以后，也做不了人。”</p>
<p>“的确的，谁也没有发见过苍蝇们的缺点和创伤。然而，有缺点的战士终竟是战士，完美的苍蝇也终究不过是苍蝇。”</p>
]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
</search>
