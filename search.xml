<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DataX使用基础案例</title>
    <url>/2024/06/04/DataX%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="1-从stream-流读取数据并打印到控制台"><a href="#1-从stream-流读取数据并打印到控制台" class="headerlink" title="1. 从stream 流读取数据并打印到控制台"></a>1. 从stream 流读取数据并打印到控制台</h2><ul>
<li>进入DataX的安装目录，执行以下命令，查看流读取的配置模板</li>
</ul>
<div class="highlight-container" data-rel="Ruby"><figure class="iseeu highlight ruby"><table><tr><td class="code"><pre><span class="line">[whybigdata<span class="variable">@node01</span> datax]<span class="variable">$ </span>./bin/datax.py -r streamreader -w streamwriter</span><br><span class="line">[whybigdata<span class="variable">@node01</span> bin]<span class="variable">$ </span>python datax.py -r streamreader -w streamwriter <span class="title class_">Data</span>X (<span class="variable constant_">DATAX</span>-<span class="variable constant_">OPENSOURCE</span>-<span class="number">3.0</span>), <span class="title class_">From</span> <span class="title class_">Alibaba</span> !</span><br><span class="line"><span class="title class_">Copyright</span> (C) <span class="number">2010</span>-<span class="number">2017</span>, <span class="title class_">Alibaba</span> <span class="title class_">Group</span>. <span class="title class_">All</span> <span class="title class_">Rights</span> <span class="title class_">Reserved</span>.</span><br><span class="line"></span><br><span class="line"><span class="title class_">Please</span> refer to the streamreader <span class="symbol">document:</span> <span class="symbol">https:</span>/<span class="regexp">/github.com/alibaba</span><span class="regexp">/DataX/blob</span><span class="regexp">/master/streamreader</span><span class="regexp">/doc/streamreader</span>.md</span><br><span class="line"></span><br><span class="line"><span class="title class_">Please</span> refer to the streamwriter <span class="symbol">document:</span> <span class="symbol">https:</span>/<span class="regexp">/github.com/alibaba</span><span class="regexp">/DataX/blob</span><span class="regexp">/master/streamwriter</span><span class="regexp">/doc/streamwriter</span>.md</span><br><span class="line"></span><br><span class="line"><span class="title class_">Please</span> save the following configuration as a json file <span class="keyword">and</span> use</span><br><span class="line">python &#123;<span class="variable constant_">DATAX_HOME</span>&#125;/bin/datax.py &#123;<span class="variable constant_">JSON_FILE_NAME</span>&#125;.json to run the job.</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;job&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;content&quot;</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;reader&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;streamreader&quot;</span>, </span><br><span class="line">    <span class="string">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">     <span class="string">&quot;column&quot;</span>: [], </span><br><span class="line">     <span class="string">&quot;sliceRecordCount&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">&quot;writer&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;streamwriter&quot;</span>, </span><br><span class="line">    <span class="string">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">     <span class="string">&quot;encoding&quot;</span>: <span class="string">&quot;&quot;</span>, </span><br><span class="line">     <span class="string">&quot;print&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;setting&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;speed&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;channel&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>根据模板编写配置文件：进入DataX安装目录下的job目录</li>
</ul>
<div class="highlight-container" data-rel="Ruby"><figure class="iseeu highlight ruby"><table><tr><td class="code"><pre><span class="line">ruby</span><br><span class="line">[whybigdata<span class="variable">@node01</span> job]<span class="variable">$ </span>vim stream2stream.json</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>添加以下内容</p>
</blockquote>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;reader&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;streamreader&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;parameter&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;long&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;18&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">     <span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">     <span class="attr">&quot;sliceRecordCount&quot;</span><span class="punctuation">:</span> <span class="number">10</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;writer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;streamwriter&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;parameter&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UTF-8&quot;</span><span class="punctuation">,</span> </span><br><span class="line">     <span class="attr">&quot;print&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;setting&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;speed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;channel&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>column表示读取的数据字段，需要编写出每个字段的数据类型和相对应的值，数值类型的字段值也需要通过引号<code>“”</code>引起来，直接使用数字会报错。</p>
</blockquote>
<ul>
<li>运行Job</li>
</ul>
<div class="highlight-container" data-rel="Ruby"><figure class="iseeu highlight ruby"><table><tr><td class="code"><pre><span class="line">ruby</span><br><span class="line">[whybigdata<span class="variable">@node01</span> job]<span class="variable">$ </span>/opt/<span class="keyword">module</span>/datax/bin/datax.py /opt/<span class="keyword">module</span>/datax/job/stream2stream.json</span><br></pre></td></tr></table></figure></div>

<ul>
<li>运行结果</li>
</ul>
<blockquote>
<p>根据<code>sliceRecordCount</code>参数值，流输出到控制台有10条数据</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c29b6243f174483a2ea64e9ed163de5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="1.jpg"
                ></p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e746d80f553449d3af4759970a70281d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="2.jpg"
                ></p>
<h2 id="2-读取-MySQL-中的数据存放到-HDFS"><a href="#2-读取-MySQL-中的数据存放到-HDFS" class="headerlink" title="2. 读取 MySQL 中的数据存放到 HDFS"></a>2. 读取 MySQL 中的数据存放到 HDFS</h2><h3 id="2-1-查看官方模板"><a href="#2-1-查看官方模板" class="headerlink" title="2.1 查看官方模板"></a>2.1 查看官方模板</h3><blockquote>
<p>执行以下命令，查看MySQL读取以及hdfs写出的配置模板</p>
</blockquote>
<div class="highlight-container" data-rel="Ruby"><figure class="iseeu highlight ruby"><table><tr><td class="code"><pre><span class="line">ruby</span><br><span class="line">[whybigdata<span class="variable">@node01</span> datax]<span class="variable">$ </span>./bin/datax.py -r mysqlreader -w hdfswriter</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>模板如下：</p>
</blockquote>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;job&quot;: &#123;</span><br><span class="line">        &quot;<span class="attribute">content</span>&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;reader&quot;: &#123;</span><br><span class="line">     &quot;name&quot;: <span class="string">&quot;mysqlreader&quot;</span>, </span><br><span class="line">     <span class="string">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">      &quot;column&quot;: [], </span><br><span class="line">      <span class="string">&quot;connection&quot;</span>: [</span><br><span class="line">       &#123;</span><br><span class="line">       &quot;jdbcUrl&quot;: [],</span><br><span class="line">       <span class="string">&quot;table&quot;</span>: []</span><br><span class="line">       &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;password&quot;: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;username&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;where&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;writer&quot;: &#123;</span><br><span class="line">     &quot;name&quot;: <span class="string">&quot;hdfswriter&quot;</span>,</span><br><span class="line">     <span class="string">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">      &quot;column&quot;: [],</span><br><span class="line">      <span class="string">&quot;compress&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;defaultFS&quot;</span>: <span class="string">&quot;&quot;</span>, </span><br><span class="line">      <span class="string">&quot;fieldDelimiter&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;fileName&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;fileType&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;path&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;writeMode&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;setting&quot;: &#123;</span><br><span class="line">            &quot;speed&quot;: &#123;</span><br><span class="line">    &quot;channel&quot;: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-1-1-mysqlreader-参数解析："><a href="#2-1-1-mysqlreader-参数解析：" class="headerlink" title="2.1.1 mysqlreader 参数解析："></a>2.1.1 mysqlreader 参数解析：</h4><div class="highlight-container" data-rel="Ruby"><figure class="iseeu highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;reader&quot;</span><span class="symbol">:</span>&#123;</span><br><span class="line"> <span class="string">&quot;name&quot;</span><span class="symbol">:<span class="string">&quot;mysqlreader&quot;</span></span>,</span><br><span class="line"> <span class="string">&quot;parameter&quot;</span><span class="symbol">:</span>&#123;</span><br><span class="line">  <span class="string">&quot;column&quot;</span><span class="symbol">:[]</span>,</span><br><span class="line">  <span class="string">&quot;connection&quot;</span><span class="symbol">:</span>[</span><br><span class="line">    &#123;</span><br><span class="line">   <span class="string">&quot;jdbcUrl&quot;</span><span class="symbol">:[]</span>,</span><br><span class="line">   <span class="string">&quot;table&quot;</span><span class="symbol">:[]</span>,</span><br><span class="line">   【“<span class="symbol">querySql:</span>[]】</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;password:&quot;</span><span class="string">&quot;,</span></span><br><span class="line"><span class="string">  &quot;</span>usemname<span class="string">&quot;:&quot;</span><span class="string">&quot;,</span></span><br><span class="line"><span class="string">  【&quot;</span>where<span class="string">&quot;:&quot;</span><span class="string">&quot;】</span></span><br><span class="line"><span class="string">  【&quot;</span>splitPk<span class="string">&quot;:&quot;</span><span class="string">&quot;】</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>参数解释如下：</p>
</blockquote>
<ul>
<li><code>name</code>:reader名</li>
<li><code>column</code>:需要同步的列名集合，使用JSON数组描述自带信息，*代表所有列</li>
<li><code>jdbcUrl</code>:对数据库的DBC连接信息，使用JSON数组描述，支持多个连接地址</li>
<li><code>table</code>:需要同步的表，支持多个</li>
<li><code>querySql</code>:自定义SQL,配置它后，mysglreader直接忽略table、column、where</li>
<li><code>password</code>:数据库用户名对应的密码</li>
<li><code>usemame</code>:数据库用户名</li>
<li><code>where</code>:筛选条件</li>
<li><code>splitPK</code>:数据分片字段，一般是主键，仅支持整型</li>
</ul>
<blockquote>
<p>注意：【】中的参数为可选参数</p>
</blockquote>
<h4 id="2-1-2-hdfswriter-参数解析："><a href="#2-1-2-hdfswriter-参数解析：" class="headerlink" title="2.1.2 hdfswriter 参数解析："></a>2.1.2 hdfswriter 参数解析：</h4><div class="highlight-container" data-rel="Ruby"><figure class="iseeu highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;writer&quot;</span><span class="symbol">:</span>&#123;</span><br><span class="line"> <span class="string">&quot;name&quot;</span><span class="symbol">:<span class="string">&quot;hdfswriter&quot;</span></span>,</span><br><span class="line"> <span class="string">&quot;parameter&quot;</span><span class="symbol">:</span>&#123;</span><br><span class="line">  <span class="string">&quot;column&quot;</span><span class="symbol">:[]</span>,</span><br><span class="line">  <span class="string">&quot;compress&quot;</span><span class="symbol">:<span class="string">&quot;&quot;</span></span></span><br><span class="line">  <span class="string">&quot;defaultFS&quot;</span><span class="symbol">:<span class="string">&quot;&quot;</span></span>,</span><br><span class="line">  <span class="string">&quot;fieldDelimiter&quot;</span><span class="symbol">:<span class="string">&quot;&quot;</span></span>,</span><br><span class="line">  <span class="string">&quot;fileName&quot;</span><span class="symbol">:<span class="string">&quot;&quot;</span></span>,</span><br><span class="line">  <span class="string">&quot;fileType&quot;</span><span class="symbol">:<span class="string">&quot;&quot;</span></span>,</span><br><span class="line">  <span class="string">&quot;path&quot;</span><span class="symbol">:<span class="string">&quot;&quot;</span></span>,</span><br><span class="line">  <span class="string">&quot;writeMode&quot;</span><span class="symbol">:<span class="string">&quot;&quot;</span></span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>参数解释如下：</p>
</blockquote>
<ul>
<li><code>name</code>：writer名</li>
<li><code>column</code>：写入数据的字段，其中name指定字段名，type指定类型</li>
<li><code>compress</code>：hdfs文件压缩类型，默认不填写意味着没有压缩。</li>
<li><code>defaultFS</code>：hdfs文件系统namenode节点地址，格式：hds&#x2F;p:端口</li>
<li><code>fieldDelimiter</code>：字段分隔符</li>
<li><code>fileName</code>：写入文件名</li>
<li><code>fileType</code>：文件的类型，目前只支持用户配置为 <code>tet</code>或 <code>orc</code></li>
<li><code>path</code>：存储到Hadoophdfs文件系统的路径信息</li>
<li><code>writeMode</code>：hdfswriter写入前数据清理处理模式：<ul>
<li><code>append</code>：写入前不做任何处理，DataX hdfswriter直接使用filename写入，并保证文件名不冲突。</li>
<li><code>nonConflict</code>：如果目录下有fileName前的文件，直接报错。</li>
</ul>
</li>
</ul>
<h3 id="2-2-准备数据"><a href="#2-2-准备数据" class="headerlink" title="2.2 准备数据"></a>2.2 准备数据</h3><ul>
<li>创建 student 表</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> database datax;</span><br><span class="line">mysql<span class="operator">&gt;</span> use datax;     </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> student(id <span class="type">int</span>,name <span class="type">varchar</span>(<span class="number">20</span>));  </span><br></pre></td></tr></table></figure></div>

<ul>
<li>插入数据</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sql</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1001</span>,<span class="string">&#x27;zhangsan&#x27;</span>),(<span class="number">1002</span>,<span class="string">&#x27;lisi&#x27;</span>),(<span class="number">1003</span>,<span class="string">&#x27;wangwu&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-编写配置文件"><a href="#2-3-编写配置文件" class="headerlink" title="2.3 编写配置文件"></a>2.3 编写配置文件</h3><div class="highlight-container" data-rel="Ruby"><figure class="iseeu highlight ruby"><table><tr><td class="code"><pre><span class="line">[whybigdata<span class="variable">@node01</span> datax]<span class="variable">$ </span>vim /opt/<span class="keyword">module</span>/datax/job/mysql2hdfs.json</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;job&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;content&quot;</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;reader&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;mysqlreader&quot;</span>, </span><br><span class="line">    <span class="string">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">     <span class="string">&quot;column&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;id&quot;</span>, </span><br><span class="line">      <span class="string">&quot;name&quot;</span></span><br><span class="line">     ],</span><br><span class="line">     <span class="string">&quot;connection&quot;</span>: [</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="string">&quot;jdbcUrl&quot;</span>: [</span><br><span class="line">       <span class="string">&quot;jdbc:mysql://node01:3306/datax&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;table&quot;</span>: [</span><br><span class="line">       <span class="string">&quot;student&quot;</span></span><br><span class="line">      ]</span><br><span class="line">     &#125;</span><br><span class="line">     ],</span><br><span class="line">     <span class="string">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>, </span><br><span class="line">     <span class="string">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">&quot;writer&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;hdfswriter&quot;</span>, </span><br><span class="line">    <span class="string">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">     <span class="string">&quot;column&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="string">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">       <span class="string">&quot;type&quot;</span>: <span class="string">&quot;int&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="string">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">       <span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">     ],</span><br><span class="line">     <span class="string">&quot;defaultFS&quot;</span>: <span class="string">&quot;hdfs://node01:9000&quot;</span>, </span><br><span class="line">     <span class="string">&quot;fieldDelimiter&quot;</span>: <span class="string">&quot;\t&quot;</span>,</span><br><span class="line">     <span class="string">&quot;fileName&quot;</span>: <span class="string">&quot;student.txt&quot;</span>, </span><br><span class="line">     <span class="string">&quot;fileType&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">     <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/datax-out&quot;</span>, </span><br><span class="line">     <span class="string">&quot;writeMode&quot;</span>: <span class="string">&quot;append&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;setting&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;speed&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;channel&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-4-执行任务"><a href="#2-4-执行任务" class="headerlink" title="2.4 执行任务"></a>2.4 执行任务</h3><ul>
<li>执行结果：失败总数为0，成功读出记录3条</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">bash复制代码[whybigdata@node01 datax]$ bin/datax.py job/mysql2hdfs.json</span><br><span class="line">2023-01-10 15:54:16.581 [job-0] INFO JobContainer -</span><br><span class="line">任务启动时刻 : 2023-01-10 15:54:04</span><br><span class="line">任务结束时刻 : 2023-01-10 15:54:16</span><br><span class="line">任务总计耗时 : 12s</span><br><span class="line">任务平均流量 : 3B/s</span><br><span class="line">记录写入速度 : 0rec/s</span><br><span class="line">读出记录总数 : 3</span><br><span class="line">读写失败总数 : 0</span><br></pre></td></tr></table></figure></div>

<ul>
<li>过程分析</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80155aee51fa48bf99d141b39885e9a7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="3.jpg"
                ></p>
<blockquote>
<p>DataX保证数据一致性的原理：⭐⭐⭐⭐⭐</p>
</blockquote>
<p>DataX读取MySQL表的数据写入到hdfs过程中，若是并发执行的操作，只有全部成功写入搭配hdfs就算最终成功（此过程中一开始会生成一个临时文件，全部成功之后才会修改临时文件名字、路径）；如果有个别失败，那job就直接宣告失败，相对应的并发操作中其他成功的操作也会将对应的临时路径删除掉。</p>
<h3 id="2-5-查看-HDFS"><a href="#2-5-查看-HDFS" class="headerlink" title="2.5 查看 HDFS"></a>2.5 查看 HDFS</h3><blockquote>
<p>注意：HdfsWriter 实际执行时会在该文件名后添加随机的后缀作为每个线程写入实际文件名。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03e1809d9bb0422890c35c4c5a479163~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="4.jpg"
                ></p>
<h3 id="2-6-关于-HA-的支持"><a href="#2-6-关于-HA-的支持" class="headerlink" title="2.6 关于 HA 的支持"></a>2.6 关于 HA 的支持</h3><blockquote>
<p>将以下参数写入到<code>writer【parameter】</code>中即可</p>
</blockquote>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;hadoopConfig&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span> </span><br><span class="line">   <span class="attr">&quot;dfs.nameservices&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ns&quot;</span><span class="punctuation">,</span> </span><br><span class="line">   <span class="attr">&quot;dfs.ha.namenodes.ns&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nn1,nn2&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;dfs.namenode.rpc-address.ns.nn1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;主机名:端口&quot;</span><span class="punctuation">,</span> </span><br><span class="line">   <span class="attr">&quot;dfs.namenode.rpc-address.ns.nn2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;主机名:端口&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dfs.client.failover.proxy.provider.ns&quot;</span><span class="punctuation">:</span><span class="string">&quot;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-7-导入到Hive"><a href="#2-7-导入到Hive" class="headerlink" title="2.7 导入到Hive"></a>2.7 导入到Hive</h3><blockquote>
<p>本质上也是通过HDFS来实现的</p>
</blockquote>
<p>过程：导入到Hive —&gt; hdfswriter配置文件 —&gt; load data 进入Hive对应的表 | 直接写入到Hive表对应的路径</p>
<h2 id="3-读取-HDFS-数据写入-MySQL"><a href="#3-读取-HDFS-数据写入-MySQL" class="headerlink" title="3. 读取 HDFS 数据写入 MySQL"></a>3. 读取 HDFS 数据写入 MySQL</h2><h3 id="3-1-将上个案例上传的文件改名"><a href="#3-1-将上个案例上传的文件改名" class="headerlink" title="3. 1 将上个案例上传的文件改名"></a>3. 1 将上个案例上传的文件改名</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line">[whybigdata@node01 datax]$ hadoop fs -<span class="built_in">mv</span> /student.txt* /student.txt</span><br></pre></td></tr></table></figure></div>

<h3 id="3-2-查看官方模板"><a href="#3-2-查看官方模板" class="headerlink" title="3.2 查看官方模板"></a>3.2 查看官方模板</h3><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[whybigdata@node01 datax]</span>$ python bin/datax<span class="selector-class">.py</span> -r hdfsreader -w mysqlwriter</span><br><span class="line">&#123;</span><br><span class="line"> &quot;job&quot;: &#123;</span><br><span class="line">  &quot;<span class="attribute">content</span>&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">   &quot;reader&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: <span class="string">&quot;hdfsreader&quot;</span>, </span><br><span class="line">    <span class="string">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">     &quot;column&quot;: [],</span><br><span class="line">     <span class="string">&quot;defaultFS&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">     <span class="string">&quot;encoding&quot;</span>: <span class="string">&quot;UTF-8&quot;</span>,</span><br><span class="line">     <span class="string">&quot;fieldDelimiter&quot;</span>: <span class="string">&quot;,&quot;</span>,</span><br><span class="line">     <span class="string">&quot;fileType&quot;</span>: <span class="string">&quot;orc&quot;</span>,</span><br><span class="line">     <span class="string">&quot;path&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;writer&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: <span class="string">&quot;mysqlwriter&quot;</span>, </span><br><span class="line">    <span class="string">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">     &quot;column&quot;: [], </span><br><span class="line">     <span class="string">&quot;connection&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">       &quot;jdbcUrl&quot;: <span class="string">&quot;&quot;</span>,</span><br><span class="line">       <span class="string">&quot;table&quot;</span>: []</span><br><span class="line">      &#125;</span><br><span class="line">     ],</span><br><span class="line">     &quot;passwoard&quot;: <span class="string">&quot;&quot;</span>,</span><br><span class="line">     <span class="string">&quot;preSql&quot;</span>: [],</span><br><span class="line">     <span class="string">&quot;session&quot;</span>: [],</span><br><span class="line">     <span class="string">&quot;username&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">     <span class="string">&quot;writeMode&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;setting&quot;: &#123;</span><br><span class="line">   &quot;speed&quot;: &#123;</span><br><span class="line">    &quot;channel&quot;: <span class="string">&quot;&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-3-创建配置文件"><a href="#3-3-创建配置文件" class="headerlink" title="3.3 创建配置文件"></a>3.3 创建配置文件</h3><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[whybigdata@node01 datax]</span>$ vim job/hdfs2mysql<span class="selector-class">.json</span></span><br><span class="line">&#123;</span><br><span class="line"> &quot;job&quot;: &#123;</span><br><span class="line">  &quot;<span class="attribute">content</span>&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">   &quot;reader&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: <span class="string">&quot;hdfsreader&quot;</span>, </span><br><span class="line">    <span class="string">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">     &quot;column&quot;: [<span class="string">&quot;*&quot;</span>],</span><br><span class="line">     <span class="string">&quot;defaultFS&quot;</span>: <span class="string">&quot;hdfs://node01:9000&quot;</span>, </span><br><span class="line">     <span class="string">&quot;encoding&quot;</span>: <span class="string">&quot;UTF-8&quot;</span>, </span><br><span class="line">     <span class="string">&quot;fieldDelimiter&quot;</span>: <span class="string">&quot;\t&quot;</span>,</span><br><span class="line">     <span class="string">&quot;fileType&quot;</span>: <span class="string">&quot;text&quot;</span>, </span><br><span class="line">     <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/student.txt&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;writer&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: <span class="string">&quot;mysqlwriter&quot;</span>, </span><br><span class="line">    <span class="string">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">     &quot;column&quot;: [</span><br><span class="line">      <span class="string">&quot;id&quot;</span>, </span><br><span class="line">      <span class="string">&quot;name&quot;</span></span><br><span class="line">     ], </span><br><span class="line">     <span class="string">&quot;connection&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">       &quot;jdbcUrl&quot;: <span class="string">&quot;jdbc:mysql://node01:3306/datax&quot;</span>, </span><br><span class="line">       <span class="string">&quot;table&quot;</span>: [<span class="string">&quot;student2&quot;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">     ],</span><br><span class="line">     &quot;password&quot;: <span class="string">&quot;123456&quot;</span>, </span><br><span class="line">     <span class="string">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>, </span><br><span class="line">     <span class="string">&quot;writeMode&quot;</span>: <span class="string">&quot;insert&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;setting&quot;: &#123;</span><br><span class="line">   &quot;speed&quot;: &#123;</span><br><span class="line">    &quot;channel&quot;: <span class="string">&quot;1&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-4-在-MySQL-的-datax-数据库中创建-student2"><a href="#3-4-在-MySQL-的-datax-数据库中创建-student2" class="headerlink" title="3.4 在 MySQL 的 datax 数据库中创建 student2"></a>3.4 在 MySQL 的 datax 数据库中创建 student2</h3><ul>
<li>建表</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sql</span>复制代码mysql<span class="operator">&gt;</span> use datax; </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> student2(id <span class="type">int</span>,name <span class="type">varchar</span>(<span class="number">20</span>));         </span><br></pre></td></tr></table></figure></div>

<h3 id="3-5-执行任务"><a href="#3-5-执行任务" class="headerlink" title="3.5 执行任务"></a>3.5 执行任务</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">bash复制代码[whybigdata@node01 datax]$ bin/datax.py job/hdfs2mysql.json </span><br><span class="line">2023-01-10 16:21:53.616 [job-0] INFO  JobContainer -      </span><br><span class="line">任务启动时刻          : 2023-01-10 16:21:41      </span><br><span class="line">任务结束时刻          : 2023-01-10 16:21:53            </span><br><span class="line">任务总计耗时          :  11s </span><br><span class="line">任务平均流量     :  3B/s   </span><br><span class="line">记录写入速度     :  0rec/s   </span><br><span class="line">读出记录总数        :   3  </span><br><span class="line">读写失败总数          :    0                </span><br></pre></td></tr></table></figure></div>

<h3 id="3-6-查看-student2-表"><a href="#3-6-查看-student2-表" class="headerlink" title="3.6 查看 student2 表"></a>3.6 查看 student2 表</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sql</span>复制代码mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student2;</span><br><span class="line"><span class="operator">+</span> <span class="operator">+</span> <span class="operator">+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span> <span class="operator">+</span> <span class="operator">+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1001</span> <span class="operator">|</span> zhangsan <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1002</span> <span class="operator">|</span> lisi <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1003</span> <span class="operator">|</span> wangwu <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span> <span class="operator">+</span> <span class="operator">+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>结束！</p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>DataX</tag>
        <tag>大数据技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Flume的开发</title>
    <url>/2024/04/01/Flume%E7%9A%84%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="大数据相关技术学习"><a href="#大数据相关技术学习" class="headerlink" title="大数据相关技术学习"></a>大数据相关技术学习</h2><h3 id="1-flume特点和主要作用"><a href="#1-flume特点和主要作用" class="headerlink" title="1.flume特点和主要作用"></a>1.flume特点和主要作用</h3><ol>
<li>动态采集，流式处理</li>
<li>只能处理log data，（视频，音频等不能处理）</li>
<li>将本地服务器日志文件上传到hdfs（不手动上传的作用就是：实时读取）</li>
</ol>
<h3 id="2-flume的使用案例1"><a href="#2-flume的使用案例1" class="headerlink" title="2.flume的使用案例1"></a>2.flume的使用案例1</h3><ul>
<li>使用flume监听端口</li>
</ul>
<ol>
<li><p>编写配置文件</p>
<div class="highlight-container" data-rel="Coffeescript"><figure class="iseeu highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example.conf: A single-node Flume configuration</span></span><br><span class="line"><span class="comment"># Name the components on this agent</span></span><br><span class="line">a1.sources = r1 </span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Describe/configure the source</span></span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = localhost</span><br><span class="line">a1.sources.r1.port = <span class="number">44444</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Describe the sink</span></span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use a channel which buffers events in memory</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = <span class="number">1000</span></span><br><span class="line">a1.channels.c1.transactionCapacity = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bind the source and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>进行启动</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一种写法：</span><br><span class="line">[atguigu@hadoop102 flume]$ bin/flume-ng agent --conf conf/ --name </span><br><span class="line">a1 --conf-file job/flume-netcat-logger.conf -Dflume.root.logger=INFO,console</span><br><span class="line"># 第二种写法：</span><br><span class="line">[atguigu@hadoop102 flume]$ bin/flume-ng agent -c conf/ -n a1 -f </span><br><span class="line">job/flume-netcat-logger.conf -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>借助nc开启客户端</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc localhost 44444</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>此时即可监控到传输信息，信息格式如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">2024-03-11 19:38:04,410 INFO sink.LoggerSink: Event: &#123; headers:&#123;&#125; body: 6E 69 68 61 6F 79 61                            nihaoya &#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据技术</tag>
        <tag>数据采集</tag>
        <tag>Fluem</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的使用</title>
    <url>/2024/04/29/Git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">今天花了一上午的时间又系统的复习了一下git，午觉之后，趁着记忆还在，便想着记录一下，方便日后复习。</span><br></pre></td></tr></table></figure></div>

<h2 id="一、Git-的基本操作"><a href="#一、Git-的基本操作" class="headerlink" title="一、Git 的基本操作"></a>一、<code>Git</code> 的基本操作</h2><h3 id="1-获取-Git-仓库的两种方式"><a href="#1-获取-Git-仓库的两种方式" class="headerlink" title="1. 获取 Git 仓库的两种方式"></a>1. 获取 <code>Git</code> 仓库的两种方式</h3><p>① 将尚未进行版本控制的本地目录<strong>转换</strong>为 <code>Git</code> 仓库</p>
<p>② 从其它服务器<strong>克隆</strong>一个已存在的 <code>Git</code> 仓库</p>
<p>以上两种方式都能够在自己的电脑上得到一个可用的 Git 仓库</p>
<h3 id="2-在现有目录中初始化仓库-⭐⭐⭐"><a href="#2-在现有目录中初始化仓库-⭐⭐⭐" class="headerlink" title="2. 在现有目录中初始化仓库(⭐⭐⭐)"></a>2. 在现有目录中初始化仓库(⭐⭐⭐)</h3><p>如果自己有一个尚未进行版本控制的项目目录，想要用 <code>Git</code> 来控制它，需要执行如下两个步骤：</p>
<p>① 在项目目录中，通过鼠标右键打开“<code>Git Bash</code>” </p>
<p>② 执行 <code>git init</code> 命令将当前的目录转化为 <code>Git</code> 仓库</p>
<p><code>git init</code> 命令会创建一个名为 .git 的隐藏目录，<strong>这个 .git 目录就是当前项目的 Git 仓库</strong>，里面包含了<strong>初始的必要文件</strong>，这些文件是 Git 仓库的<strong>必要组成部分</strong></p>
<h3 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3. 常用命令"></a>3. 常用命令</h3><div class="highlight-container" data-rel="Handlebars"><figure class="iseeu highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">1. git status 查看当前文件处于什么状态</span></span><br><span class="line"><span class="language-xml">        # 以精简的方式显示文件状态</span></span><br><span class="line"><span class="language-xml">        git status -s</span></span><br><span class="line"><span class="language-xml">        git status --short</span></span><br><span class="line"><span class="language-xml">2. git add 文件名           开始跟踪一个文件</span></span><br><span class="line"><span class="language-xml">3. git commit -m &quot;备注&quot;     将暂存区记录提交到本地仓库</span></span><br><span class="line"><span class="language-xml">4. git push origin master  将本地仓库的代码上传到远程仓库</span></span><br><span class="line"><span class="language-xml">5. git pull orgin master  将远程仓库代码拉取到本地</span></span><br></pre></td></tr></table></figure></div>

<h2 id="二、Git分支的基本使用"><a href="#二、Git分支的基本使用" class="headerlink" title="二、Git分支的基本使用"></a>二、<code>Git</code>分支的基本使用</h2><h3 id="1-master-主分支"><a href="#1-master-主分支" class="headerlink" title="1. master 主分支"></a>1. master 主分支</h3><p>在初始化本地 <code>Git</code> 仓库的时候，<code>Git</code> 默认已经帮我们创建了一个名字叫做 <code>master</code> 的分支。通常我们把这个</p>
<p><code>master</code> 分支叫做主分支。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-72650ca791f34dd57097ec7975b88dc2_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-fbebf185ac0c35a641a8e4227dcb175a_720w.webp"
                     
                ></p>
<p>在实际工作中，<code>master</code> 主分支的作用是：<strong>用来保存和记录整个项目已完成的功能代码</strong>。</p>
<p>因此，<strong>不允许程序员直接在 <code>master</code> 分支上修改代码</strong>，因为这样做的风险太高，容易导致整个项目崩溃。</p>
<h3 id="2-创建新分支"><a href="#2-创建新分支" class="headerlink" title="2. 创建新分支"></a>2. 创建新分支</h3><p>使用如下的命令，可以查看当前 Git 仓库中所有的分支列表：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：</strong>分支名字前面的 ***** 号表示当前所处的分支。</p>
<p>使用如下的命令，可以<strong>基于当前分支</strong>，<strong>创建一个新的分支</strong>，此时，新分支中的代码和当前分支完全一样：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch 分支名称</span><br></pre></td></tr></table></figure></div>

<p>使用如下的命令，可以<strong>切换到指定的分支上</strong>进行开发：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout login</span><br></pre></td></tr></table></figure></div>

<h3 id="3-分支的快速创建和切换-⭐⭐⭐"><a href="#3-分支的快速创建和切换-⭐⭐⭐" class="headerlink" title="3. 分支的快速创建和切换(⭐⭐⭐)"></a>3. 分支的快速创建和切换(⭐⭐⭐)</h3><p>使用如下的命令，可以<strong>创建指定名称的新分支</strong>，并<strong>立即切换到新分支上</strong>：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-b 表示创建一个新分支</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">checkout 表示切换到刚才新建的分支上</span></span><br><span class="line">git checkout -b 分支名称</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：</strong></p>
<p>“<code>git checkout -b 分支名称</code>“ 是下面</p>
<p>两条命令的简写形式：</p>
<p>① <code>git branch</code> 分支名称</p>
<p>② <code>git checkout</code> 分支名称</p>
<p>功能分支的代码开发测试完毕之后，可以使用如下的命令，将完成后的代码合并到 <code>master</code> 主分支上：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 切换到 master 分支</span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 在master 分支上运行 git merge 命令，将 login 分支的代码合班到 master 分支</span></span><br><span class="line">git merge login</span><br></pre></td></tr></table></figure></div>

<p><strong>合并分支时的注意点</strong>：</p>
<p>假设要把 C 分支的代码合并到 A 分支，</p>
<p>则必须<strong>先切换到 A 分支</strong>上，<strong>再运行 git merge 命令</strong>，来合并 C 分支！</p>
<p>当把功能分支的代码合并到 <code>master</code> 主分支上以后，就可以使用如下的命令，删除对应的功能分支：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -d 分支名称</span><br></pre></td></tr></table></figure></div>

<h2 id="三、远程分支操作"><a href="#三、远程分支操作" class="headerlink" title="三、远程分支操作"></a>三、远程分支操作</h2><h3 id="1-将本地分支推送到远程仓库-⭐⭐⭐"><a href="#1-将本地分支推送到远程仓库-⭐⭐⭐" class="headerlink" title="1. 将本地分支推送到远程仓库(⭐⭐⭐)"></a>1. 将本地分支推送到远程仓库(⭐⭐⭐)</h3><p>如果是<strong>第一次</strong>将本地分支推送到远程仓库，需要运行如下的命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-u 表示把本地分支和远程分支进行关联，只在第一次推送的时候需要带 -u 参数</span></span><br><span class="line">git push -u 远程仓库的别名 本地分支名称:远程分支名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实际案例</span></span><br><span class="line">git push -u origin payment:pay</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果希望远程分支的名称和本地分支名称保持一致，可以对命令进行简化</span></span><br><span class="line">git push -u origin payment</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：</strong>第一次推送分支需要带 <strong>-u 参数</strong>，此后可以直接使用 <code>git push</code> 推送代码到远程分支。</p>
<h3 id="2-查看远程仓库中所有的分支列表"><a href="#2-查看远程仓库中所有的分支列表" class="headerlink" title="2. 查看远程仓库中所有的分支列表"></a>2. 查看远程仓库中所有的分支列表</h3><p>通过如下的命令，可以查看远程仓库中，所有的分支列表的信息：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git remote show 远程仓库名称</span><br></pre></td></tr></table></figure></div>

<h3 id="3-跟踪分支-⭐⭐⭐"><a href="#3-跟踪分支-⭐⭐⭐" class="headerlink" title="3. 跟踪分支(⭐⭐⭐)"></a>3. 跟踪分支(⭐⭐⭐)</h3><p>跟踪分支指的是：从远程仓库中，把远程分支下载到本地仓库中。需要运行的命令如下：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line">git checkout pay</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从远程仓库中，把对应的远程分支下载到本地仓库，并把下载的本地分支进行重命名</span></span><br><span class="line">git checkout -b 本地分支名称 远程仓库名称/远程分支名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line">git checkout -b payment origin/pay</span><br></pre></td></tr></table></figure></div>

<h3 id="4-拉取远程分支的最新的代码"><a href="#4-拉取远程分支的最新的代码" class="headerlink" title="4. 拉取远程分支的最新的代码"></a>4. 拉取远程分支的最新的代码</h3><p>可以使用如下的命令，把远程分支最新的代码下载到本地对应的分支中:</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从远程仓库，拉取当前分支最新的代码，保持当前分支的代码和远程分支代码一致</span></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure></div>

<h3 id="5-删除远程分支"><a href="#5-删除远程分支" class="headerlink" title="5. 删除远程分支"></a>5. 删除远程分支</h3><p>可以使用如下的命令，删除远程仓库中指定的分支：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程仓库中，制定名称的远程分支</span></span><br><span class="line">git push 远程仓库名称 --delete 远程分支名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line">git push origin --delete pay</span><br></pre></td></tr></table></figure></div>

<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ul>
<li>能够掌握 <code>Git</code> 中基本命令的使用<ul>
<li><code>git init</code></li>
<li><code>git add .</code></li>
<li><code>git commit –m &quot;提交消息&quot;</code> </li>
<li><code>git status</code> 和 <code>git status -s</code></li>
</ul>
</li>
<li>能够使用 <code>Github</code> 创建和维护远程仓库<ul>
<li>能够配置 <code>Github</code> 的 <code>SSH</code> 访问</li>
<li>能够将本地仓库上传到 <code>Github</code></li>
</ul>
</li>
<li>能够掌握 <code>Git</code> 分支的基本使用<ul>
<li><code>git checkout -b 新分支名称</code></li>
<li><code>git push -u origin 新分支名称</code></li>
<li><code>git checkout 分支名称</code></li>
<li>&#96;git branch</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java刷题技巧</title>
    <url>/2024/04/01/Java%E5%88%B7%E9%A2%98%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>刷题网站推荐</p>
<ul>
<li><a class="link"   href="https://leetcode.cn/" >力扣 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.luogu.com.cn/" >洛谷 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://ac.nowcoder.com/acm/problem/list" >牛客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://codeforces.com/" >CF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">明确各个不同网站之间的区别：如力扣的代码是核心代码模式，而牛客等就是ACM模式，内容推荐系统刷力扣，针对练习洛谷、牛客中的难题，最后也可以多打打cf比赛</span><br></pre></td></tr></table></figure></div>



<h3 id="1-Arrays-sort自定义排序规则"><a href="#1-Arrays-sort自定义排序规则" class="headerlink" title="1.Arrays.sort自定义排序规则"></a>1.<code>Arrays.sort</code>自定义排序规则</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> people.length;</span><br><span class="line">       List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="comment">// 自定义二维数组的排序规则： 首先按照数组的第一个元素进行从大到小排序，如果相同，按照第二元素从小到大排序</span></span><br><span class="line">       Arrays.sort(people , Comparator.comparingInt((<span class="type">int</span>[] a )-&gt; a[<span class="number">0</span>]).reversed().thenComparing(</span><br><span class="line">               (<span class="type">int</span>[] a) -&gt; a[<span class="number">1</span>]</span><br><span class="line">       ));</span><br><span class="line"></span><br><span class="line">       Arrays.sort(people, (a , b) -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])&#123;</span><br><span class="line">               <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       Arrays.sort(people , (a , b) -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])&#123;</span><br><span class="line">               <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">           System.out.println(people[i][<span class="number">0</span>] + <span class="string">&quot;:&quot;</span>+people[i][<span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 相当于此时已经按照身高排好序了，只需按照k进行插入即可</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span>[] person : people) &#123;</span><br><span class="line">           list.add(person[<span class="number">1</span>] , person);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[people.length][]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-大顶堆小顶堆的数组存储特点"><a href="#2-大顶堆小顶堆的数组存储特点" class="headerlink" title="2.大顶堆小顶堆的数组存储特点"></a>2.大顶堆小顶堆的数组存储特点</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 为简化计算，堆进行存储的时候数组下标也可从1开始，</span><br><span class="line">公式就调整为：父节点=i/2，左子节点=i*2，右子节点=i*2+1（i是当前节点对应的数组下标）</span><br></pre></td></tr></table></figure></div>

<p>例题：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-6aed45fd53b4b93a6497447f57ab4b0a_720w.webp"
                     
                ></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">代码答案如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        PriorityQueue&lt;Integer&gt; minQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a-b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] min = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            minQueue.offer(in.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 需要注意的是，优先队列来建立堆进行存储，要使用这个方法，不能进行手动赋值</span></span><br><span class="line">        Integer[] toArray = minQueue.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[n]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : toArray) &#123;</span><br><span class="line">            min[index++] = integer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 优先队列里面的元素：10</span></span><br><span class="line"><span class="comment">         * 优先队列里面的元素：23</span></span><br><span class="line"><span class="comment">         * 优先队列里面的元素：24</span></span><br><span class="line"><span class="comment">         * 优先队列里面的元素：26</span></span><br><span class="line"><span class="comment">         * 优先队列里面的元素：46</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (!minQueue.isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;优先队列里面的元素：&quot;</span>+minQueue.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 堆存储在数组中的结构为：</span></span><br><span class="line"><span class="comment">         * 堆在数组为：0</span></span><br><span class="line"><span class="comment">         * 堆在数组为：10</span></span><br><span class="line"><span class="comment">         * 堆在数组为：23</span></span><br><span class="line"><span class="comment">         * 堆在数组为：26</span></span><br><span class="line"><span class="comment">         * 堆在数组为：46</span></span><br><span class="line"><span class="comment">         * 堆在数组为：24</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : min) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;堆在数组为：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        in.nextLine();</span><br><span class="line">        <span class="keyword">while</span> (m-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 接下来的m行，需要分别对每一行进行判断</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">            String[] strings = str.split(<span class="string">&quot;\\s&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (str.contains(<span class="string">&quot;is the root&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">// 判断是不是头节点</span></span><br><span class="line">                <span class="keyword">if</span> (min[<span class="number">1</span>] == Integer.parseInt(strings[<span class="number">0</span>]))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;T&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (str.contains(<span class="string">&quot;are siblings&quot;</span>))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Integer.parseInt(strings[<span class="number">0</span>]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> Integer.parseInt(strings[<span class="number">2</span>]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (min[i] == x)&#123;</span><br><span class="line">                        a = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (min[i] == y)&#123;</span><br><span class="line">                        b = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(a/<span class="number">2</span> == b/<span class="number">2</span> ? <span class="string">&quot;T&quot;</span> : <span class="string">&quot;F&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (str.contains(<span class="string">&quot;is the parent of&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">// 判断是不是父节点  -- 判断x是y的父节点</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Integer.parseInt(strings[<span class="number">0</span>]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> Integer.parseInt(strings[<span class="number">5</span>]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n+<span class="number">1</span> ; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (min[i] == y)&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> i / <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> (min[f] == x)&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;T&quot;</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Integer.parseInt(strings[<span class="number">0</span>]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> Integer.parseInt(strings[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (min[i] == x)&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> i / <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> (min[f] == y)&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;T&quot;</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="3-Java读取文件，暴力分割矩阵"><a href="#3-Java读取文件，暴力分割矩阵" class="headerlink" title="3. Java读取文件，暴力分割矩阵"></a>3. <code>Java</code>读取文件，暴力分割矩阵</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:\\developer_tools\\idea\\java_code\\PTA\\src\\蓝桥杯\\day5\\data.txt&quot;</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path));</span><br><span class="line">        <span class="type">int</span>[][] ints = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">30</span>][<span class="number">20</span>];</span><br><span class="line">        String line;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            String[] strings = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class="line">                ints[index][i] = Integer.parseInt(strings[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">   <span class="comment">//         按行读取，读取的每一行</span></span><br><span class="line"><span class="comment">//            System.out.println(line);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 暴力破解，求出5行5列的子矩阵的最大值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= ints.length - <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= ints[<span class="number">0</span>].length - <span class="number">5</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 执行5次，从i 到后面5行</span></span><br><span class="line">                <span class="comment">// 从j 到后面 5 行</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">temp</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">5</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; <span class="number">5</span>; l++) &#123;</span><br><span class="line">                        temp += ints[k+i][l+j];</span><br><span class="line">                        System.out.print(ints[k+i][l+j] +<span class="string">&quot; &quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">                res = Math.max(res , temp);</span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span>+i + <span class="string">&quot;行,第&quot;</span> + j+<span class="string">&quot;列，构造结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="4-Java算法模板"><a href="#4-Java算法模板" class="headerlink" title="4. Java算法模板"></a>4. Java算法模板</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求最大公约数模板</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b )</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a % b;</span><br><span class="line">        <span class="keyword">while</span> (c != <span class="number">0</span>)&#123;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">            c = a % b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 求最小公倍数模板</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findLCM</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b / gcd(a , b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分解质因数模板 -- 将一个数分解成诺干质数相乘</span></span><br><span class="line"><span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">List</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(i);</span><br><span class="line">            n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转化指定格式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">factorization</span><span class="params">(<span class="type">int</span> n )</span> &#123;</span><br><span class="line">		System.out.print(n+<span class="string">&quot;=&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt;= n ; i++) &#123;</span><br><span class="line">			<span class="keyword">while</span>(n % i == <span class="number">0</span>) &#123; <span class="comment">// 表示当前的i可以被n整除，是他的倍数</span></span><br><span class="line">				System.out.print(i);</span><br><span class="line">				n /= i;</span><br><span class="line">				<span class="keyword">if</span>(n != <span class="number">1</span>) &#123;  <span class="comment">// 这个地方表示目前n不是最后一个</span></span><br><span class="line">					<span class="comment">// 表示不是最后一个</span></span><br><span class="line">					System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断一个数是不是质数模板</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(num &lt;= <span class="number">1</span>) &#123;    <span class="comment">// 小于等于1的都不是质数</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt;= Math.sqrt(num) ; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;  <span class="comment">// 表示存在了其他因数，肯定不是质数，返回即可</span></span><br><span class="line">				<span class="comment">// 质数定义是：只存在1或者他本身两个因数的数字，才属于质数</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> x , <span class="type">int</span> y )</span> &#123;</span><br><span class="line">		<span class="type">double</span> <span class="variable">res</span>  <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(y % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">				res *= x;</span><br><span class="line">			&#125;</span><br><span class="line">			y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">			x *= x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="5-回溯之切割问题"><a href="#5-回溯之切割问题" class="headerlink" title="5. 回溯之切割问题"></a>5. 回溯之切割问题</h3><p>问题1 ： 力扣<a class="link"   href="https://leetcode.cn/problems/palindrome-partitioning/" >131. 分割回文串 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">代码如下：</span><br><span class="line">	List&lt;List&lt;String&gt;&gt; res1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span> || s == <span class="literal">null</span>) <span class="keyword">return</span> res1;</span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backTracking(s , <span class="number">0</span> , path);</span><br><span class="line">        <span class="keyword">return</span> res1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String s, <span class="type">int</span> startIndex , List path )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.length())&#123;</span><br><span class="line">            res1.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始进行切割</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f(s, startIndex , i ))&#123;</span><br><span class="line">                <span class="comment">// 表示这一段是回文串</span></span><br><span class="line">                path.add(s.substring(startIndex , i+<span class="number">1</span>));</span><br><span class="line">                <span class="comment">// 下一次的切割，从i当前执行的下一个开始切割哦</span></span><br><span class="line">                backTracking(s , i + <span class="number">1</span> , path);</span><br><span class="line">                <span class="comment">// 进行回溯</span></span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">f</span><span class="params">(String s , <span class="type">int</span> start , <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="comment">// 判断是不是回文串</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(start) != s.charAt(end))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>问题2  力扣<a class="link"   href="https://leetcode.cn/problems/restore-ip-addresses/" >93. 复原 IP 地址 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">代码如下：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &gt; <span class="number">12</span> ) <span class="keyword">return</span> res;</span><br><span class="line">        backTrack(s , <span class="number">0</span> , <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//   使用了逗号的数量进行回溯的结束条件---- 这一点确实巧妙</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(String s, <span class="type">int</span> startIndex, <span class="type">int</span> pointNum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pointNum == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(s , startIndex , s.length() - <span class="number">1</span>))&#123;</span><br><span class="line">                res.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(s , startIndex , i))&#123;</span><br><span class="line">                <span class="comment">// 表示此时是一个合法的: 需要在i后面的位置添加一个.</span></span><br><span class="line">                s = s.substring(<span class="number">0</span> , i + <span class="number">1</span> ).concat(<span class="string">&quot;.&quot;</span>).concat(s.substring(i+<span class="number">1</span>));</span><br><span class="line">                pointNum++;</span><br><span class="line">                <span class="comment">// 因为这个地方插入了一个逗号，所以下一个地方的是i+2</span></span><br><span class="line">                backTrack(s , i+<span class="number">2</span>,pointNum);</span><br><span class="line">                <span class="comment">// 下面两个地方是进行回溯的地方</span></span><br><span class="line">                pointNum--;</span><br><span class="line">                s = s.substring(<span class="number">0</span> , i+<span class="number">1</span>).concat(s.substring(i+<span class="number">2</span>));<span class="comment">//回溯</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断从start - end 两个边界都可以取到，是不是可以满足条件</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(start) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end)&#123;</span><br><span class="line">            <span class="comment">// 表示此时这个字符长度不为1，但是他是零开头的，不合法，返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">//    下面这个使用了累乘，来计算最终结果的访问大小</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end ; i++) &#123;</span><br><span class="line">            <span class="comment">// 遇到非数字字符不合法，直接返回哦</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span> || s.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num * <span class="number">10</span> + (s.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">255</span>)&#123;</span><br><span class="line">                <span class="comment">// 表示超过了数字的范围，直接返回哦</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示上面的条件都不是，此时就是一个合法的ip地址的字符串，从start到end</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="6-Java中快速读写的代码"><a href="#6-Java中快速读写的代码" class="headerlink" title="6. Java中快速读写的代码"></a>6. Java中快速读写的代码</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main_StreamTokenzier</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">StreamTokenizer</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)));</span><br><span class="line">    <span class="comment">// 注意点就是，每一次读取之前都要 sc.nextToken() </span></span><br><span class="line">    <span class="comment">//  然后常用的只有两个方法，读取字符串和读取数字（默认double类型）两个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        sc.nextToken();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) sc.nval;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            set.clear();</span><br><span class="line">            sc.nextToken();</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (<span class="type">int</span>) sc.nval;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">                sc.nextToken();</span><br><span class="line">                set.add((<span class="type">int</span>)sc.nval);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(index++ , <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(set));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        for (Map.Entry&lt;Integer, HashSet&lt;Integer&gt;&gt; entry : map.entrySet()) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue().toString());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="7-指定字符数组长度转化为字符串"><a href="#7-指定字符数组长度转化为字符串" class="headerlink" title="7. 指定字符数组长度转化为字符串"></a>7. 指定字符数组长度转化为字符串</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String.valueOf(char[] chars , 0 , num) 这个方法的作用就是将chars字符数组，从chars[0]开始，取长度为num个元素，转化为字符串 	   </span></span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line">        System.out.println(String.valueOf(chars , <span class="number">0</span> , <span class="number">2</span>));</span><br><span class="line">        System.out.println(String.valueOf(chars , <span class="number">0</span> , <span class="number">1</span>));</span><br><span class="line">        System.out.println(String.valueOf(chars , <span class="number">0</span> , <span class="number">3</span>));</span><br><span class="line">        System.out.println(String.valueOf(chars , <span class="number">0</span> , <span class="number">5</span>));</span><br></pre></td></tr></table></figure></div>

<h3 id="8-KMP算法模板"><a href="#8-KMP算法模板" class="headerlink" title="8. KMP算法模板"></a>8. KMP算法模板</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 下面演示KMP算法 : 在s1中找到s2字符串首次出现的位置</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;zhuzhuzhuhehehezhuhezhuhe&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;zhuhe&quot;</span>;</span><br><span class="line">		System.out.println(f_KMP(s1, s2));  <span class="comment">// 6</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f_KMP</span><span class="params">(String s1 , String s2)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[s2.length()];</span><br><span class="line">		getNext(s2 , next);</span><br><span class="line"><span class="comment">//		System.out.println(Arrays.toString(next));</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s1.charAt(i) != s2.charAt(j)) &#123;</span><br><span class="line">				j = next[j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (j == s2.length()) &#123;</span><br><span class="line">				<span class="comment">// 这个地方表示s2已经全部匹配上了:返回下标即可</span></span><br><span class="line">				<span class="keyword">return</span> i - s2.length() + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 匹配不上返回-1</span></span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 求next数组，采用不减1的操作</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(String s , <span class="type">int</span>[] next)</span> &#123;</span><br><span class="line">		next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; next.length ; i++) &#123;</span><br><span class="line">			<span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">				<span class="comment">// 如果找到不相同的，就看他的前一个</span></span><br><span class="line">				j = next[j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			next[i] = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="9-Java中大数的基本使用"><a href="#9-Java中大数的基本使用" class="headerlink" title="9. Java中大数的基本使用"></a>9. Java中大数的基本使用</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加减乘除取模运算</span></span><br><span class="line">System.out.println(BigInteger.valueOf(<span class="number">3</span>).add(BigInteger.valueOf(<span class="number">2</span>)));</span><br><span class="line">System.out.println(BigInteger.valueOf(<span class="number">3</span>).subtract(BigInteger.valueOf(<span class="number">2</span>)));</span><br><span class="line">System.out.println(BigInteger.valueOf(<span class="number">3</span>).multiply(BigInteger.valueOf(<span class="number">2</span>)));</span><br><span class="line">System.out.println(BigInteger.valueOf(<span class="number">3</span>).divide(BigInteger.valueOf(<span class="number">3</span>)));</span><br><span class="line">System.out.println(BigInteger.valueOf(<span class="number">14</span>).mod(BigInteger.valueOf(<span class="number">3</span>)));</span><br><span class="line"><span class="comment">// 案例--大数的阶乘</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">res</span> <span class="operator">=</span> BigInteger.ONE;	 </span><br><span class="line">Scanner in=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"> <span class="comment">// 计算n的阶乘的方法     </span></span><br><span class="line"><span class="type">int</span> n=in.nextInt();</span><br><span class="line"><span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">	res = res.multiply(BigInteger.valueOf(n));</span><br><span class="line">	n--;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(res);</span><br><span class="line"><span class="comment">// 进制转化内置方法</span></span><br><span class="line"><span class="comment">// 将一个数转化为2进制，8进制，16进制</span></span><br><span class="line">System.out.println(Integer.toString(<span class="number">255</span> , <span class="number">2</span>));</span><br><span class="line">System.out.println(Integer.toString(<span class="number">255</span> , <span class="number">8</span>));</span><br><span class="line">System.out.println(Integer.toString(<span class="number">255</span> , <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将二进制，八进制 ， 16进制的字符串转化为十进制的方法</span></span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;11111111&quot;</span> , <span class="number">2</span>));</span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;11111111&quot;</span> , <span class="number">8</span>));</span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;11111111&quot;</span> , <span class="number">16</span>));</span><br></pre></td></tr></table></figure></div>

<h3 id="10-终要面对-Dijkstra算法"><a href="#10-终要面对-Dijkstra算法" class="headerlink" title="10 终要面对-Dijkstra算法"></a>10 终要面对-Dijkstra算法</h3><hr>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">必要学会版 V1.0</span><br></pre></td></tr></table></figure></div>

<p>GitHub源代码: <a class="link"   href="https://github.com/yuanjiejiahui/Dijkstra" >https://github.com/yuanjiejiahui/Dijkstra <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ol>
<li>算法常用于处理单源出发到其他所有节点的最短路径问题，适用于不含有负权重的有向和无向图</li>
<li>算法采用贪心策略，具体代码借助堆来优化算法</li>
</ol>
<p><a class="link"   href="https://leetcode.cn/problems/network-delay-time/description/" >力扣链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://acking-you.gitee.io/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/" >相关博文 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"> 	    List&lt;<span class="type">int</span>[]&gt;[] g = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            g[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建图，使用list数组来进行构建哦</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] time : times)&#123;</span><br><span class="line">            <span class="comment">// 因为times数组中的下标从1开始的哦</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> time[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> time[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> time[<span class="number">2</span>];</span><br><span class="line">            g[u].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;v , w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> Integer.MAX_VALUE / <span class="number">2</span>; <span class="comment">// 初始化dist数组需要使用哦</span></span><br><span class="line">        <span class="comment">// 一共n个节点哦</span></span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dist , INF);</span><br><span class="line">        dist[k - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 表示从当前节点到当前节点的最短路径为0，其他都为无限远</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a , b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123; <span class="number">0</span> , k -  <span class="number">1</span>&#125;); <span class="comment">//小顶堆，根据数组的第一个元素进行排序，用来记录从出发顶点，到达他所能到达的其他所有顶点的集合</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 每一次处理距离出发顶点最近的顶点哦</span></span><br><span class="line">            <span class="type">int</span>[] p = pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">currDist</span> <span class="operator">=</span> p[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> p[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (dist[x] &lt; currDist)&#123;  <span class="comment">// 表示此时不用更新dist[x]了</span></span><br><span class="line">                <span class="comment">// 表示此时dist[y] ，到达y的距离已经是最小值了，不需要进行处理</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 然后开始处理: g[y] 得到所有从y出发的顶点，能到达的下一个顶点，和他们的距离哦</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[] e : g[x])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> e[<span class="number">0</span>];<span class="comment">// x到达的下一个顶点y</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> dist[x] + e[<span class="number">1</span>];  <span class="comment">// 经过x顶点到达y的路径距离</span></span><br><span class="line"><span class="comment">// 经过x和不经过x的两端距离进行比较，取出最小值即可</span></span><br><span class="line">                <span class="keyword">if</span> (d &lt; dist[y])&#123;  </span><br><span class="line">                    dist[y] = d;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;d , y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res = Math.max(res , dist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INF ? -<span class="number">1</span> :res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="11-多次见面-并查集"><a href="#11-多次见面-并查集" class="headerlink" title="11 多次见面-并查集"></a>11 多次见面-并查集</h3><p><a class="link"   href="https://blog.csdn.net/haduwi/article/details/121350586" >附相关博文1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">我是不想见你的，奈何多次要见</span><br></pre></td></tr></table></figure></div>

<ol>
<li>题单1-<a class="link"   href="https://leetcode.cn/problems/find-if-path-exists-in-graph/" >寻找图中是否存在路径 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPath</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(source == destination) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            uf.union(edge[<span class="number">0</span>] , edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 总结： 并且集可以用来判断连通问题</span></span><br><span class="line">        <span class="keyword">return</span> uf.connected(source , destination);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] sz; <span class="comment">// 存储每个根节点所在组的数量个数</span></span><br><span class="line">    <span class="type">int</span> count ;  <span class="comment">// 记录分组个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.sz = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p , <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="comment">// 判断pq是否在同一个组内</span></span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找p的父节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p == parent[p])&#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p , <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="comment">// 将这两个数组进行在一个组里面</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pRoot</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">qRoot</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 现在不能简单的进行合并</span></span><br><span class="line"><span class="comment">//        parent[pRoot] = qRoot;</span></span><br><span class="line">        <span class="keyword">if</span> (sz[pRoot] &lt; sz[qRoot])&#123;</span><br><span class="line">            <span class="comment">// 将较小的合并到较大的上面</span></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            sz[qRoot] += sz[pRoot];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 此时qRoot较小，将较小的合并到大的上面</span></span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            sz[pRoot] += sz[qRoot];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分组数量减减</span></span><br><span class="line">        <span class="built_in">this</span>.count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>题单2-<a class="link"   href="https://leetcode.cn/problems/number-of-provinces/" >547. 省份数量 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> isConnected.length;</span><br><span class="line">        <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 表示直接连通哦</span></span><br><span class="line">                <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    uf.union(i , j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省份的数量，其实就是最后的分组数量</span></span><br><span class="line">        <span class="keyword">return</span> uf.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPath</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(source == destination) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            uf.union(edge[<span class="number">0</span>] , edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connected(source , destination);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] sz; <span class="comment">// 存储每个根节点所在组的数量个数</span></span><br><span class="line">    <span class="type">int</span> count ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.sz = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p , <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="comment">// 判断pq是否在同一个组内</span></span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找p的父节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p == parent[p])&#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p , <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="comment">// 将这两个数组进行在一个组里面</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pRoot</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">qRoot</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        parent[pRoot] = qRoot;</span></span><br><span class="line">        <span class="keyword">if</span> (sz[pRoot] &lt; sz[qRoot])&#123;</span><br><span class="line">            <span class="comment">// 将较小的合并到较大的上面</span></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            sz[qRoot] += sz[pRoot];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 此时qRoot较小，将较小的合并到大的上面</span></span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            sz[pRoot] += sz[qRoot];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分组数量减减</span></span><br><span class="line">        <span class="built_in">this</span>.count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>总结UF（并查集）模板</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] parent ;</span><br><span class="line">    <span class="type">int</span>[] rank ; <span class="comment">// 记录就是当前父节点他组内的个数</span></span><br><span class="line">    <span class="type">int</span> count ; <span class="comment">// 记录目前一共有多少个分组数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="built_in">this</span>.rank = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 初始的情况下</span></span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span>&#123;</span><br><span class="line">        <span class="comment">// 查找p节点的父节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[p] == p)&#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p , <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pRoot</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">qRoot</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">return</span> pRoot == qRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p , <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pRoot</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">qRoot</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot) <span class="keyword">return</span>;  <span class="comment">// 表示此时已经连通了，不需要在连通了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进行连通操作： 优化步骤在于，将较短的树连接到较大的树上面</span></span><br><span class="line">        <span class="keyword">if</span> (rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot] += rank[pRoot];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            rank[pRoot] += rank[qRoot];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 因为此时将两个分组合并到一个分组上面了，故分组数量需要减减</span></span><br><span class="line">        <span class="built_in">this</span>.count --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>4 . <a class="link"   href="https://leetcode.cn/problems/7LpjUW/" >LCR 118. 冗余连接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Scheme"><figure class="iseeu highlight scheme"><table><tr><td class="code"><pre><span class="line">题目：在一个数中新添加了一条边，然后给你一个边的二维数组，请你求出，去掉哪一条边之后，仍然使得：剩余部分是一个有着 n 个节点的树（这一句话表示：删除一条边之后 ， n个节点仍然是连通的）。如果有多个答案，则返回数组 edges 中最后出现的边。</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findRedundantConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edges.length;</span><br><span class="line">    <span class="comment">//  UF类模板此处进行省略</span></span><br><span class="line">        <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            <span class="comment">// 题目中节点编号从1开始到n，故不要忘记减一</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> edge[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> edge[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (uf.connected(i , j) == <span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="comment">// 表示此时已经连接了</span></span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                uf.union(i , j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="12-再见深搜"><a href="#12-再见深搜" class="headerlink" title="12 再见深搜"></a>12 再见深搜</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">最优解不是使用dfs，为复习dfs，选择dfs</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://leetcode.cn/problems/search-a-2d-matrix-ii/" >附上力扣题单 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span>[][] direction = &#123;&#123;<span class="number">0</span> , <span class="number">1</span>&#125; , &#123;<span class="number">1</span> , <span class="number">0</span>&#125; , &#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span>[][] flag = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(matrix,<span class="number">0</span>,<span class="number">0</span>,target , flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] matrix , <span class="type">int</span> i , <span class="type">int</span> j , <span class="type">int</span> target , <span class="type">boolean</span>[][] flag)</span>&#123;</span><br><span class="line"> <span class="comment">// 先判断索引不合法，和已经访问过的，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= matrix.length || j &lt; <span class="number">0</span> || j &gt;= matrix[<span class="number">0</span>].length || flag[i][j]) &#123;</span><br><span class="line">            <span class="comment">// 索引越界或已访问过，返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主要这个逻辑来进行判断，是不是存在目标值</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] cur : direction) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur[<span class="number">0</span>] + i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> cur[<span class="number">1</span>] + j;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果存在true，表示找到了，返回true即可</span></span><br><span class="line">            <span class="keyword">if</span> (dfs(matrix, x, y, target, flag)) &#123;</span><br><span class="line">                <span class="comment">// 如果在某个方向找到目标值，返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到这个地方表示所有的方向都访问过了，但是没有找到，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="13-龟兔赛跑算法–快慢指针的使用"><a href="#13-龟兔赛跑算法–快慢指针的使用" class="headerlink" title="13 龟兔赛跑算法–快慢指针的使用"></a>13 龟兔赛跑算法–快慢指针的使用</h3><p><a class="link"   href="https://zhuanlan.zhihu.com/p/496079620" >参考文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Sas"><figure class="iseeu highlight sas"><table><tr><td class="code"><pre><span class="line">Floyd判圈算法</span><br><span class="line">			- 解决是否存在环的问题</span><br><span class="line">			- 解决求环的入口的问题</span><br><span class="line">			- 解决求环的长度的问题</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://leetcode.cn/problems/linked-list-cycle/" >141. 环形链表 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 判断是否存在环</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">     <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">     <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">     <span class="keyword">while</span>(slow != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">         fast = fast.next.next;</span><br><span class="line">         slow = slow.next;</span><br><span class="line">         <span class="keyword">if</span>(fast == slow)&#123; <span class="comment">//表示相遇了</span></span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://leetcode.cn/problems/linked-list-cycle-ii/" >142. 环形链表 II <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 求环的起点</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="comment">// 此时表示存在环，并且他们相遇在环的某一位置上哦</span></span><br><span class="line">                <span class="keyword">while</span> (res != slow)&#123;</span><br><span class="line">                    res = res.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到这个地方表示不存在环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>对于求环的长度问题暂未遇到。思路是：假设存在环，快慢指针第一次相遇的位置一定在环的某个位置上，然后让快指针不动，慢指针走一圈，引入一个变量计算长度，当慢指针与快指针再次相遇的时候，刚好为环的长度。</p>
<h3 id="14-Java数学类的三个方法"><a href="#14-Java数学类的三个方法" class="headerlink" title="14 Java数学类的三个方法"></a>14 <code>Java</code>数学类的三个方法</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">一定要注意，题目中要求的数据范围：是四舍五入，还是什么</span><br></pre></td></tr></table></figure></div>

<ol>
<li>**Math.ceil(double a)**：向上取整方法。返回大于或等于参数的最小整数。如果参数是正数，则返回大于或等于该参数的最小整数；如果参数是负数，则返回小于或等于该参数的最大整数。返回值类型为<code>double</code>。</li>
<li>**Math.floor(double a)**：向下取整方法。返回小于或等于参数的最大整数。如果参数是正数，则返回不大于该参数的最大整数；如果参数是负数，则返回大于或等于该参数的最小整数。返回值类型为<code>double</code>。</li>
<li>**Math.round(float a) 和 Math.round(double a)**：四舍五入方法。返回最接近参数的整数。对于<code>float</code>类型的参数，返回<code>int</code>类型的整数；对于<code>double</code>类型的参数，返回<code>long</code>类型的整数。这是标准的四舍五入操作，即如果待舍入数的小数部分大于等于0.5，则向上取整；如果小于0.5，则向下取整。</li>
</ol>
<h3 id="15-再学完美、完全二叉树"><a href="#15-再学完美、完全二叉树" class="headerlink" title="15 再学完美、完全二叉树"></a>15 再学完美、完全二叉树</h3><p><a class="link"   href="https://blog.csdn.net/lyl123_456/article/details/102494659" >相关博文1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>								<a class="link"   href="https://blog.csdn.net/weixin_52055811/article/details/129966800" >相关博文2 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ol>
<li>二叉树的性质</li>
</ol>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">（1）若二叉树的层次从0开始，则在二叉树的第i层至多有2^i个结点(i&gt;=0)。</span><br><span class="line">（2）高度为k的二叉树最多有2^(k+1) - 1个结点(k&gt;=-1)。 (空树的高度为-1)</span><br><span class="line"><span class="code">	度：结点所拥有的子树个数称为结点的度(Degree)</span></span><br><span class="line"><span class="code">	叶子（终端结点）：没有孩子的结点(也就是度为0的结点)称为叶子(Leaf)或终端结点</span></span><br><span class="line"><span class="code">（3）对任何一棵二叉树，如果其叶子结点(度为0)数为m, 度为2的结点数为n, 则m = n + 1。</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>完美二叉树（满二叉树）</li>
</ol>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">一个深度为k(&gt;=-1)且有2^(k+1) - 1个结点的二叉树称为完美二叉树。 </span><br><span class="line">(注： 国内的数据结构教材大多翻译为&quot;满二叉树&quot;)。</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>完全二叉树</li>
</ol>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>完满二叉树</li>
</ol>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">所有非叶子结点的度都是2。（只要你有孩子，你就必然是有两个孩子。）</span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li>完满(Full)二叉树 vs 完全(Complete)二叉树 vs 完美(Perfect)二叉树</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img-blog.csdnimg.cn/20191011090955281.png"
                     
                ></p>
<p><a class="link"   href="https://pintia.cn/problem-sets/1779778307878768640/exam/problems/1779778385079140362?type=7&page=0" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码如下</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> n , index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] nums , res;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = in.nextInt();</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            nums[i] = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            ans.append(res[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans.toString().trim());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后模拟后序遍历的顺序</span></span><br><span class="line">        dfs(i * <span class="number">2</span>); <span class="comment">// 左</span></span><br><span class="line">        dfs(i * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 右</span></span><br><span class="line">        <span class="comment">// 然后处理当前节点</span></span><br><span class="line">        res[i] = nums[index++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="16-HashMap重写排序"><a href="#16-HashMap重写排序" class="headerlink" title="16 HashMap重写排序"></a>16 HashMap重写排序</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap 根据value进行排序</span></span><br><span class="line"><span class="comment">// 举例： 首先按照value进行从大到小的方式排序，然后如果value相同，则按照key从小到大排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main_</span>测试 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;b&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;a&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;c&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;d&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = hashMap.entrySet();</span><br><span class="line">        <span class="comment">// 转换为列表</span></span><br><span class="line">        List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(hashMap.entrySet());</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        list.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> &#123;</span><br><span class="line">                <span class="comment">// 先比较value，如果value相同再比较key</span></span><br><span class="line">                <span class="keyword">if</span> (o2.getValue() - o1.getValue() != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> o2.getValue() - o1.getValue();</span><br><span class="line"><span class="comment">//                    return valueComparison;</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// value相同才按照key从小到大的方式进行排序</span></span><br><span class="line">                    <span class="keyword">return</span> o1.getKey().compareTo(o2.getKey()); <span class="comment">// 从小到大排序</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 输出排序后的结果</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : list) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-f922496ecd3ef9eec758cb0767f5725d_720w.webp"
                     
                ></p>
<h3 id="17-位移运算符"><a href="#17-位移运算符" class="headerlink" title="17.  位移运算符"></a>17.  位移运算符</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 左移m&lt;&lt;n 代表把数字m在无溢出的前提下乘以2的n次方。</span><br><span class="line">2. 右移m&gt;&gt;n 代表把数字m除以2的n次方，原来是正数的还是正数，负数还是负数。注意，如果是单数，也就是二进制末位为1，则结果是将m除以2的n次方的整数商。</span><br><span class="line"></span><br><span class="line">3. 记忆：小屁股指向谁，就向那边移动哦。</span><br></pre></td></tr></table></figure></div>

<h3 id="18-无敌前缀树"><a href="#18-无敌前缀树" class="headerlink" title="18. 无敌前缀树"></a>18. 无敌前缀树</h3><h5 id="1-使用类的方式构建前缀树"><a href="#1-使用类的方式构建前缀树" class="headerlink" title="1. 使用类的方式构建前缀树"></a>1. 使用类的方式构建前缀树</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> pass ; <span class="comment">// 表示经过这个节点的值</span></span><br><span class="line">        <span class="type">int</span> end; <span class="comment">// 表示以这个节点结尾的值</span></span><br><span class="line">        TrieNode[] nexts;</span><br><span class="line">        <span class="comment">// 当字符数量多的时候，数组不够使用，可以使用map来进行映射</span></span><br><span class="line">        HashMap&lt;Integer , TrieNode&gt; map ;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">            nexts = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">            map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将字符串word插入到前缀树中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        node.pass ++ ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , path; i &lt; word.length(); i++) &#123;</span><br><span class="line">            path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.nexts[path] == <span class="literal">null</span>)&#123;</span><br><span class="line">                node.nexts[path] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.nexts[path];</span><br><span class="line">            node.pass++;</span><br><span class="line">        &#125;</span><br><span class="line">        node.end++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询前缀树中，有多少单词以pre作为前缀</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordStartingWith</span><span class="params">(String pre)</span>&#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , path ; i &lt; pre.length(); i++) &#123;</span><br><span class="line">            path = pre.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.nexts[path] == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.nexts[path];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.pass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询前缀树中word单词出现了几次，求最后一个节点end即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsEqualTo</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root; <span class="comment">// 从头节点进行出发</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , path ; i &lt; word.length(); i++) &#123;</span><br><span class="line">            path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.nexts[path] == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 表示没有这个节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.nexts[path];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除word单词在前缀树中构建：</span></span><br><span class="line">        <span class="comment">// 情况1 ： 如果之前word插入过前缀树，那么此时删掉一次</span></span><br><span class="line">        <span class="comment">// 情况2 ： 如果之前没有插入过前缀树，那么什么也不做</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (countWordsEqualTo(word) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            node.pass -- ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , path ; i &lt; word.length(); i++) &#123;</span><br><span class="line">                path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="comment">// 如果下一个节点减减之后为0，之后肯定都不用管了，直接删掉后面的即可，因为后面的此时都连接不上了</span></span><br><span class="line">                <span class="keyword">if</span> (--node.nexts[path].pass == <span class="number">0</span>)&#123;</span><br><span class="line">                    node.nexts[path] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.nexts[path];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 走到最后将此时的end结束减减</span></span><br><span class="line">            node.end -- ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="2-使用静态变量的方式构建（推荐）"><a href="#2-使用静态变量的方式构建（推荐）" class="headerlink" title="2. 使用静态变量的方式构建（推荐）"></a>2. 使用静态变量的方式构建（推荐）</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">150001</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span>[][] tree = <span class="keyword">new</span> <span class="title class_">int</span>[MAX][<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span>[] pass = <span class="keyword">new</span> <span class="title class_">int</span>[MAX];</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span>[] end = <span class="keyword">new</span> <span class="title class_">int</span>[MAX];</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> cnt ;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将单词插入</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            pass[cur]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , path ; i &lt; word.length(); i++) &#123;</span><br><span class="line">                path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>)&#123;</span><br><span class="line">                    tree[cur][path] = ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = tree[cur][path];</span><br><span class="line">                pass[cur]++;</span><br><span class="line">            &#125;</span><br><span class="line">            end[cur]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后统计每个单词在字典树中出现的次数即可</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(String word)</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , path; i &lt; word.length(); i++) &#123;</span><br><span class="line">                path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = tree[cur][path];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> end[cur];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 查找以这个字符串为前缀出现的次数 pass的值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">prefixNumber</span><span class="params">(String pre)</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , path ; i &lt; pre.length(); i++) &#123;</span><br><span class="line">                path = pre.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 表示断开了，不存在以他为前缀的哦</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = tree[cur][path];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pass[cur];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String word)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (search(word) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 存在才删除</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                pass[cur]--;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , path ; i &lt; word.length(); i++) &#123;</span><br><span class="line">                    path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (--pass[tree[cur][path]] == <span class="number">0</span>)&#123;  <span class="comment">// 这个地方每一次将pass已经进行自减过了哦</span></span><br><span class="line">                        <span class="comment">// 表示下一个是空</span></span><br><span class="line">                        tree[cur][path] = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur = tree[cur][path];</span><br><span class="line">                &#125;</span><br><span class="line">                end[cur]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= cnt ; i++) &#123;</span><br><span class="line">                Arrays.fill(tree[i] , <span class="number">0</span>);</span><br><span class="line">                pass[i] = <span class="number">0</span>;</span><br><span class="line">                end[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="3-相关题目讲解"><a href="#3-相关题目讲解" class="headerlink" title="3. 相关题目讲解"></a>3. 相关题目讲解</h5><p><a class="link"   href="https://leetcode.cn/problems/QC3q1f/" >LCR 062. 实现 Trie (前缀树) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用静态数组的方式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">50001</span>;</span><br><span class="line">    <span class="type">int</span>[][] tree = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span>[] pass = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="type">int</span>[] end = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="type">int</span> cnt ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        pass[cur]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , path ; i &lt; word.length(); i++) &#123;</span><br><span class="line">            path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 表示此时这个没有路，构建出来即可</span></span><br><span class="line">                tree[cur][path] = ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = tree[cur][path];</span><br><span class="line">            pass[cur]++;</span><br><span class="line">        &#125;</span><br><span class="line">        end[cur]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , path ; i &lt; word.length(); i++) &#123;</span><br><span class="line">            path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = tree[cur][path];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end[cur] != <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , path ; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            path = prefix.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = tree[cur][path];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="19-数论"><a href="#19-数论" class="headerlink" title="19 .数论"></a>19 .数论</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">前言：真心感慨先人的智慧，各种定理，各种推理，全部给出结论，而我在几十年后的今天看了好久才能看出一丝门道，学无止境啊</span><br></pre></td></tr></table></figure></div>

<h4 id="1-费马小定理"><a href="#1-费马小定理" class="headerlink" title="1. 费马小定理"></a>1. 费马小定理</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 概念：如果p是一个质数，而整数a不是p的倍数，即a与p互质，那么满足等式a^(p-1)≡1(mod p)，即a的(p-1)次方除以p的余数恒等于1</span><br><span class="line">2. 推论：a mod p = 1 / a ^ (p-2)    =&gt;     引出逆元计算</span><br><span class="line">3. 逆元可以用来进行模算术除法，即除以一个数可以转化为乘以其逆元。</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line">综上所述：假如要求a在质数p下的逆元，即为 a ^ (p-2)  ，因为除以 a 等于除以1 / a ^ (p-2)</span><br><span class="line">相当于乘以 a ^ (p-2) , 即正好满足逆元定义。（注意这个公式下p一定要是质数哦）</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h4 id="2-快速求逆元"><a href="#2-快速求逆元" class="headerlink" title="2. 快速求逆元"></a>2. 快速求逆元</h4><p>前提，p为质数</p>
<p>题目：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">技巧1 ： 0 异或 任意数 等于 任意数</span><br><span class="line">（异或运算中，不同为1 ，相同为0）</span><br><span class="line">System.out.println(0 ^ 312312321);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>注意这个和快速幂还有些不同，在利用下述模板进行逆元求解的时候，不要忘记模m了</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">pow2</span><span class="params">(<span class="type">long</span> x , <span class="type">long</span> y , <span class="type">long</span> m)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (y != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (y % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 表示此时是奇数</span></span><br><span class="line">                res = res * x % m;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x * x % m;</span><br><span class="line">            y = y/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>蓝桥真题</p>
</li>
<li><pre><code>给定质数模数 M=2146516019M=2146516019，根据费马小定理对于不是 MM 倍数的正整数 aa，有 a(M−1)≡1(mod M)a(M−1)≡1(mod M)，求出 [1,233333333][1,233333333] 内所有自然数的逆元。则所有逆元的异或和为多少？
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  long res = 0;</span><br><span class="line">  long m = 2146516019;</span><br><span class="line">  for (int i = 1; i &lt;= 233333333 ; i++) &#123;</span><br><span class="line">  	res ^= pow2(i , m - 2 , m);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(res);</span><br><span class="line">  =============================================================================</span><br><span class="line">   static long pow2(long x , long y , long m)&#123;</span><br><span class="line">          long res = 1;</span><br><span class="line">          while (y != 0)&#123;</span><br><span class="line">              if (y % 2 == 1)&#123;</span><br><span class="line">                  // 表示此时是奇数</span><br><span class="line">                  res = res * x % m;</span><br><span class="line">              &#125;</span><br><span class="line">              y = y/2;</span><br><span class="line">              x = x * x % m;</span><br><span class="line">          &#125;</span><br><span class="line">          return res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
</code></pre>
</li>
</ul>
<h4 id="3-数论"><a href="#3-数论" class="headerlink" title="3. 数论"></a>3. 数论</h4><h3 id="20-差分数组"><a href="#20-差分数组" class="headerlink" title="20 差分数组"></a>20 差分数组</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">对连续子数组的操作，可以转变为对差分数组中的两个数的操作</span><br></pre></td></tr></table></figure></div>

<h4 id="1-定义和常用性质"><a href="#1-定义和常用性质" class="headerlink" title="1. 定义和常用性质"></a>1. 定义和常用性质</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义：对于数组a,他的差分数组d为：</span></span><br><span class="line">	d[<span class="number">0</span>] = a[<span class="number">0</span>] , d = <span class="number">0</span></span><br><span class="line">	d[i] = a[i] - a[i - <span class="number">1</span>] , d &gt;= <span class="number">1</span></span><br><span class="line"><span class="comment"># 性质：</span></span><br><span class="line">    <span class="number">1.</span>从左向右累加d中的元素，可以得到原数组a</span><br><span class="line">    <span class="number">2.</span>将子数组a的子数组a[i] , a[i+<span class="number">1</span>] ...  a[j] 都加上x 等价于：</span><br><span class="line">    			   将d[i] 增加x , 将 d[j+<span class="number">1</span>] 减少 x</span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line">	利用性质<span class="number">2</span>，可以实现在O(<span class="number">1</span>)的时间复杂度下完成对a的子数组的操作，然后利用性质<span class="number">1</span>还原数组</span><br><span class="line"><span class="comment"># 注意点：</span></span><br><span class="line">	</span><br></pre></td></tr></table></figure></div>

<h4 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h4><p><a class="link"   href="https://leetcode.cn/problems/car-pooling/" >1094. 拼车 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">carPooling</span><span class="params">(<span class="type">int</span>[][] trips, <span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">     <span class="comment">// 0 &lt;= fromi &lt; toi &lt;= 1000</span></span><br><span class="line">        <span class="comment">// 定义a[i] 表示到底位置 i 的时候 车上的人数，需要判断所有的a[i] 是否满足 &lt;= capacity</span></span><br><span class="line">        <span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] trip : trips) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> trip[<span class="number">0</span>] , start = trip[<span class="number">1</span>] , end = trip[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">// start 到  end - 1  是增加上: 刚好满足差分</span></span><br><span class="line">            <span class="comment">// end 是减少人</span></span><br><span class="line">            d[start] += num;</span><br><span class="line">            d[end] -= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : d) &#123;</span><br><span class="line">            s += i ;</span><br><span class="line">            <span class="keyword">if</span> (s &gt; capacity)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark SQL</title>
    <url>/2024/04/15/Spark-SQL/</url>
    <content><![CDATA[<h2 id="Spark-SQL"><a href="#Spark-SQL" class="headerlink" title="Spark SQL"></a>Spark SQL</h2><h3 id="1-dataframe类型的详解"><a href="#1-dataframe类型的详解" class="headerlink" title="1. dataframe类型的详解"></a>1. dataframe类型的详解</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/v2-3d4646adbdc8dffdbdf5e4d5471d0065_r.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-9973137e99ffcba2e005275e7ccee435_720w.webp"
                     
                ></p>
<h3 id="2-dataframe的创建"><a href="#2-dataframe的创建" class="headerlink" title="2. dataframe的创建"></a>2. dataframe的创建</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-896a75d1c541fa7ea3e48ec796a223a2_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-d2bde66b53464be453bc0146b41e6c36_720w.webp"
                     
                ></p>
<h3 id="3-dataframe的使用"><a href="#3-dataframe的使用" class="headerlink" title="3. dataframe的使用"></a>3. dataframe的使用</h3><h4 id="3-1-使用df中的方法进行操作（dsl方法-—-df提供）"><a href="#3-1-使用df中的方法进行操作（dsl方法-—-df提供）" class="headerlink" title="3.1 使用df中的方法进行操作（dsl方法 — df提供）"></a>3.1 使用df中的方法进行操作（dsl方法 — df提供）</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">df数据的查询</span><br><span class="line"><span class="number">1.</span> 指定查询的字段数据(指定字段的字符串格式，结果会返回一个新的df，可以使用df.show()查看</span><br><span class="line">	df.select(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="number">2.</span> 指定多个字段<span class="comment">--一次查询多个字段（将字段放入列表中，注意需要使用字符串的形式）</span></span><br><span class="line">	df.select([<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="number">3.</span> 直接使用df进行查询</span><br><span class="line">	df.select(df[<span class="string">&#x27;name&#x27;</span>],df[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="number">4.</span> 展示所有数据<span class="comment">---&gt; 直接使用df.show() 即可将所有结果查询出来</span></span><br><span class="line">	df.show()   # 此时就是对所有字段进行处理</span><br><span class="line"><span class="number">5.</span> df.show(num)  可以指定展示多少条数据，默认是<span class="number">20</span>条数据，同时<span class="keyword">show</span>()方法不会返回新的df</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">df的条件过滤</span><br><span class="line"><span class="number">1.</span> df.where(<span class="string">&#x27;age &gt; 20&#x27;</span>) # 相当于将所有数据都进行过滤，返回一个新的df</span><br><span class="line"><span class="number">2.</span> df.where(<span class="string">&#x27;age &gt; 20&#x27;</span>) # 相当于将所有数据都进行过滤，返回一个新的df，并且，没有指定行</span><br><span class="line">	相当于得到年龄大于<span class="number">20</span>的全部过滤出来</span><br><span class="line"><span class="number">3.</span> 多个条件的与或非（<span class="keyword">and</span> , <span class="keyword">or</span> , ）</span><br><span class="line">	df.where(<span class="string">&#x27;age &gt;= 20 and gender = &quot;男&quot;&#x27;</span>) # 注意单双引号的嵌套使用</span><br><span class="line">	</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>（分组操作，一般结合聚合操作）的操作</span><br><span class="line"><span class="number">1.</span> df.groupby(<span class="string">&#x27;gender&#x27;</span>).<span class="built_in">sum</span>(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">	# 相当于对性别进行分组操作，同时对两个组中的年龄进行累加</span><br><span class="line">	# <span class="keyword">select</span> gender , <span class="built_in">sum</span>(<span class="string">&#x27;age&#x27;</span>) <span class="keyword">from</span> df <span class="keyword">group</span> <span class="keyword">by</span> gender</span><br><span class="line">	# 常见的聚合函数：<span class="built_in">sum</span>()，<span class="built_in">avg</span>() , <span class="built_in">min</span>() , <span class="built_in">max</span>()</span><br><span class="line"><span class="number">2.</span> 对于多个分组字段的使用，和进行查询的时候一样，使用一个列表进行</span><br><span class="line">	# 相当于先对性别进行一个分组，然后在两个性别中在对每一个科目在进行一个分组</span><br><span class="line">	df.groupby([<span class="string">&#x27;gender , cls&#x27;</span>]).<span class="built_in">avg</span>(<span class="string">&#x27;age&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">分组后的数据过滤</span><br><span class="line"><span class="number">1.</span> # 注意的点就是分组后的过滤，也不需要使用<span class="keyword">having</span>，而是同样使用<span class="keyword">where</span></span><br><span class="line">	df.groupby(<span class="string">&#x27;gender&#x27;</span>).<span class="built_in">sum</span>(<span class="string">&#x27;age&#x27;</span>).<span class="keyword">where</span>(<span class="string">&#x27;sum(age) &gt; 80&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">排序操作 orderBy()</span><br><span class="line"><span class="number">1.</span> df.orderBy(<span class="string">&#x27;age&#x27;</span>) </span><br><span class="line">	# 默认是升序排序,按照年龄进行升序排序</span><br><span class="line">	# 返回一个新的df</span><br><span class="line">	# 如果需要降序，就传入一个参数，进行降序排序</span><br><span class="line">	df.orderBy(<span class="string">&#x27;age&#x27;</span>,ascending <span class="operator">=</span> <span class="literal">False</span>)</span><br><span class="line"><span class="number">2.</span> 多字段排序</span><br><span class="line">	# 如果需要多个字段进行排序，可以使用列表</span><br><span class="line">	# 先按照age进行排序，如果年龄相同，就按照id进行从小到大进行排序</span><br><span class="line">	df.orderBy([<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line"><span class="number">3.</span> （多字段是按照一个排序规则进行操作）</span><br><span class="line">注意点就是，不能指定一个字段进行升序，一个降序。也就是说，和<span class="keyword">sql</span>里面是一样的。</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">指定返回数量 limit()</span><br><span class="line"><span class="number">1.</span> # 返回指定数量的数据</span><br><span class="line">   # 返回一个新的df</span><br><span class="line">	df.limit(<span class="number">5</span>)</span><br><span class="line">	</span><br></pre></td></tr></table></figure></div>

<h4 id="3-2-使用sql语句进行操作（sql语句—sparkSession提供）"><a href="#3-2-使用sql语句进行操作（sql语句—sparkSession提供）" class="headerlink" title="3.2 使用sql语句进行操作（sql语句—sparkSession提供）"></a>3.2 使用sql语句进行操作（sql语句—sparkSession提供）</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-8d036e7f21c29ee7acc86b9354c7b5cf_720w.webp"
                     
                ></p>
<h4 id="3-3-关联的操作"><a href="#3-3-关联的操作" class="headerlink" title="3.3 关联的操作"></a>3.3 关联的操作</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">join</span>的关联操作</span><br><span class="line"><span class="number">1.</span> 内关联 </span><br><span class="line"><span class="number">2.</span> 左关联 ： 左边的数据全部展示，如果有相同的id，右边表的数据也会展示</span><br><span class="line"><span class="number">3.</span> 右关联</span><br></pre></td></tr></table></figure></div>



<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-550a1afb4cb03613679d0e1069c26979_720w.webp"
                     
                ></p>
<h4 id="3-4-df数据的缓存和checkpoint"><a href="#3-4-df数据的缓存和checkpoint" class="headerlink" title="3.4 df数据的缓存和checkpoint"></a>3.4 df数据的缓存和checkpoint</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 缓存使用方法：</span></span><br><span class="line">	<span class="comment"># 进行缓存</span></span><br><span class="line">	df.persist()</span><br><span class="line">	<span class="comment"># 后序在进行计算时，如果计算错误就直接从缓存中读取</span></span><br><span class="line">	<span class="comment"># 缓存的级别：默认有限缓存到内存中，内存不足缓存到磁盘上</span></span><br><span class="line">    new_df = df.where(<span class="string">&#x27;id &gt; 1&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># checkpoint的作用：</span></span><br><span class="line"><span class="comment"># checkpoint的意思就是建立检查点,类似于快照,例如在spark计算里面 计算流程DAG特别长,服务器需要将整个DAG计算完成得出结果,但是如果在这很长的计算流程中突然中间算出的数据丢失了,spark又会根据RDD的依赖关系从头到尾计算一遍,这样子就很费性能,当然我们可以将中间的计算结果通过cache或者persist放到内存或者磁盘中,但是这样也不能保证数据完全不会丢失,存储的这个内存出问题了或者磁盘坏了,也会导致spark从头再根据RDD计算一遍,所以就有了checkpoint,其中checkpoint的作用就是将DAG中比较重要的中间数据做一个检查点将结果存储到一个高可用的地方(通常这个地方就是HDFS里面)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方法 首先设置checkpoint存储的位置</span></span><br><span class="line">sc.setCheckpointDir(<span class="string">&#x27;hdfs:///spark_checkpoint&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后进行checkpoint操作:如果计算错误，就可以从hdfs中进行读取</span></span><br><span class="line">df.checkpoint()</span><br></pre></td></tr></table></figure></div>

<ul>
<li>当存在缓存和checkpoint时候，优先读取缓存中的数据，因为缓存的读写速度较快</li>
</ul>
<h4 id="3-5-df中的内置函数"><a href="#3-5-df中的内置函数" class="headerlink" title="3.5 df中的内置函数"></a>3.5 df中的内置函数</h4><ol>
<li><p>spark中的内置函数和hive中的内置函数基本一致</p>
</li>
<li><p>使用之前需要导入相应的模块</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession,functions <span class="keyword">as</span> F</span><br><span class="line"><span class="comment"># functions是sparksql中的内置函数模块，里面封装了许多内置方法</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.字符串的操作  --  拼接  -- 得到一个新的df</span></span><br><span class="line">new_df = df.select(F.concat(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>)) <span class="comment"># sql:select concat(id , name) from df</span></span><br><span class="line">new_df.show()   <span class="comment"># 展示结果，这个方法拼接结果不会有分割字符</span></span><br><span class="line"><span class="comment"># 2.字符串的拼接，并且指定分割字符的方法</span></span><br><span class="line">new_df = df.select(F.concat_ws(<span class="string">&#x27;,&#x27;</span> , <span class="string">&#x27;id&#x27;</span> , <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line">new_df.show()</span><br><span class="line"><span class="comment"># 3. 字符串的截取</span></span><br><span class="line">df.select(F.substring(<span class="string">&#x27;name&#x27;</span> , <span class="number">1</span> , <span class="number">4</span>)) <span class="comment"># 表示从第一个字符开始，截取4个长度的字符</span></span><br><span class="line"><span class="comment"># 4. 字符串的切割</span></span><br><span class="line">df.select(F.split(<span class="string">&#x27;date&#x27;</span> , <span class="string">&#x27;-&#x27;</span>)) <span class="comment"># 将年份根据-进行切割，得到一个列表</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 时间操作，获取当前日期</span></span><br><span class="line">df.select(F.current_date())</span><br><span class="line"><span class="comment"># 2. 获取当前日期时间</span></span><br><span class="line">df.select(F.current_timestamp())</span><br><span class="line"><span class="comment"># 3. 获取当前的unix时间（时间戳）</span></span><br><span class="line">df.select(F.unix_timestamp())</span><br><span class="line"><span class="comment"># 4.将unix时间转化为指定格式的时间</span></span><br><span class="line">df.select(F.from_unixtime(<span class="string">&#x27;unix_t&#x27;</span> , <span class="built_in">format</span>=<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>))</span><br><span class="line"><span class="comment"># 5. 时间加减操作</span></span><br><span class="line">df.select(F.date_add(<span class="string">&#x27;date&#x27;</span> , <span class="number">1</span>)) <span class="comment"># 将字段date加一天</span></span><br><span class="line">df.select(F.date_add(<span class="string">&#x27;date&#x27;</span> , -<span class="number">1</span>)) <span class="comment"># 将字段date减一天</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 内置函数（常用于多个聚合操作） ---  需要配合agg进行使用（agg里面可以使用多个内置函数）</span></span><br><span class="line">df.groupby(<span class="string">&#x27;gender&#x27;</span>).agg(F.<span class="built_in">sum</span>(<span class="string">&#x27;age&#x27;</span>) , F.avg(<span class="string">&#x27;age&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定某个字段保留两位小数</span></span><br><span class="line">df.groupby(<span class="string">&#x27;gender&#x27;</span>).agg(F.<span class="built_in">sum</span>() , F.<span class="built_in">round</span>(F.avg(<span class="string">&#x27;age&#x27;</span>) , <span class="number">2</span>))</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 内置函数取别名的方法 ---  一般不使用中文的别名哦</span></span><br><span class="line"><span class="comment"># 取别名的操作，并且跟在内置函数后面</span></span><br><span class="line">df.groupby(<span class="string">&#x27;gender&#x27;</span>).agg(F.<span class="built_in">sum</span>().alias(<span class="string">&#x27;总和&#x27;</span>) , F.<span class="built_in">round</span>(F.avg(<span class="string">&#x27;age&#x27;</span>) , <span class="number">2</span>).alias(<span class="string">&#x27;平均值&#x27;</span>))</span><br></pre></td></tr></table></figure></div>



<h4 id="3-6-SparkSession的说明"><a href="#3-6-SparkSession的说明" class="headerlink" title="3.6 SparkSession的说明"></a>3.6 SparkSession的说明</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"><span class="comment"># 生成sparksession对象</span></span><br><span class="line"><span class="comment"># 默认是采用本地模式进行计算</span></span><br><span class="line">ss = SparkSession.builder.getOrCreate()</span><br><span class="line"><span class="comment"># 也可以指定其他资源调度方式进行计算        -----&gt;master()</span></span><br><span class="line"><span class="comment"># master(&#x27;yarn&#x27;) 采用yarn</span></span><br><span class="line"><span class="comment"># master(&#x27;spark://node1:7077&#x27;) 采用standalone</span></span><br><span class="line">ss1 = SparkSession.builder.master(<span class="string">&#x27;yarn&#x27;</span>).getOrCreate()</span><br><span class="line"><span class="comment"># 也可以指定计算程序的任务名称   -----&gt;appName()</span></span><br><span class="line">ss1 = SparkSession.builder.master(<span class="string">&#x27;yarn&#x27;</span>).appName(<span class="string">&#x27;yarn_sparkSql&#x27;</span>).getOrCreate()</span><br><span class="line"><span class="comment"># 指定配置信息 		-------&gt;config()</span></span><br><span class="line">ss1 = SparkSession.builder.master(<span class="string">&#x27;yarn&#x27;</span>).config().getOrCreate()</span><br></pre></td></tr></table></figure></div>

<h3 id="4-小案例—电影数据统计分析"><a href="#4-小案例—电影数据统计分析" class="headerlink" title="4.小案例—电影数据统计分析"></a>4.小案例—电影数据统计分析</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原数据格式，分析，以及导入原数据到hdfs中</span></span><br><span class="line"><span class="comment"># 字段： 用户id\t电影id\t评分\t时间</span></span><br><span class="line">代码流程如下：</span><br><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 生成SparkSession对象</span></span><br><span class="line">ss = SparkSession.builder.getOrCreate()</span><br><span class="line"><span class="comment"># 使用sparkcontext读取文件数据</span></span><br><span class="line">sc = ss.sparkContext</span><br><span class="line"><span class="comment"># 读取文件生成rdd数据</span></span><br><span class="line">rdd = sc.textFile(<span class="string">&#x27;hdfs:///movie&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这一步可以先进行查看一部分的数据</span></span><br><span class="line"><span class="built_in">print</span>(rdd.take(<span class="number">20</span>)) <span class="comment"># 查看20条数据</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将rdd数据转化为df数据,先将rdd转化为二位嵌套</span></span><br><span class="line">table_rdd = rdd.<span class="built_in">map</span>(</span><br><span class="line">	<span class="keyword">lambda</span> x : [<span class="built_in">int</span>(x.split(<span class="string">&#x27;\t&#x27;</span>)[<span class="number">0</span>]) , <span class="built_in">int</span>(x.split(<span class="string">&#x27;\t&#x27;</span>)[<span class="number">1</span>]) , double(x.split(<span class="string">&#x27;\t&#x27;</span>)[<span class="number">2</span>]) ,s.split(<span class="string">&#x27;\t&#x27;</span>)[<span class="number">3</span>] ] <span class="comment"># 注意时间可以使用字符串</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 定义schedule信息，指定字段名和字段类型</span></span><br><span class="line">schema_type = StructType()</span><br><span class="line">	.add(<span class="string">&#x27;userId&#x27;</span>,IntegerType())</span><br><span class="line">	.add(<span class="string">&#x27;movieId&#x27;</span>,IntegerType())</span><br><span class="line">    .add(<span class="string">&#x27;score&#x27;</span>,DoubleType())</span><br><span class="line">    .add(<span class="string">&#x27;unix_time&#x27;</span>,StringType())</span><br><span class="line"><span class="comment"># 转化为df数据</span></span><br><span class="line">df = table_rdd.toDF(schema_type)</span><br><span class="line"><span class="comment"># 查看df数据，默认20条</span></span><br><span class="line">df.show()</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.查询每个用户的平均分</span></span><br><span class="line">user_avg = df.groupBy(<span class="string">&#x27;userId&#x27;</span>).agg(F.avg(<span class="string">&#x27;score&#x27;</span>).alias(<span class="string">&#x27;avg_data&#x27;</span>))</span><br><span class="line">user_avg.show() <span class="comment"># 用户打分平均分展示</span></span><br><span class="line"><span class="comment"># 2. 查询每个电影的平均分</span></span><br><span class="line">movie_avg = df.groupBy(<span class="string">&#x27;movieId&#x27;</span>).agg(F.avg(<span class="string">&#x27;score&#x27;</span>).alias(<span class="string">&#x27;avg_data&#x27;</span>))</span><br><span class="line">	<span class="comment"># 计算结果保留两位小数</span></span><br><span class="line">movie_avg= df.groupBy(<span class="string">&#x27;movieId&#x27;</span>).agg(F.<span class="built_in">round</span>(F.avg(<span class="string">&#x27;score&#x27;</span>),<span class="number">2</span>).alias(<span class="string">&#x27;avg_data&#x27;</span>))</span><br><span class="line">movie_avg.show() <span class="comment"># 电影平均分展示</span></span><br><span class="line"><span class="comment"># 3. 查询高分电影中（评分大于3的）打分次数最多的用户，并求出此人打的平均分</span></span><br><span class="line"> <span class="number">3.1</span> : 得到不同用户打高分电影的数量 </span><br><span class="line">        df.where(<span class="string">&#x27;score &gt;3&#x27;</span>).groupBy(<span class="string">&#x27;userId&#x27;</span>)</span><br><span class="line">        .agg(F.count(<span class="string">&#x27;movieId&#x27;</span>).alias(<span class="string">&#x27;count_data&#x27;</span>))</span><br><span class="line"> <span class="number">3.2</span> ：然后根据数量进行降序排序，得到第一个就是打分次数最多的用户</span><br><span class="line">        df.where(<span class="string">&#x27;score &gt;3&#x27;</span>).groupBy(<span class="string">&#x27;userId&#x27;</span>)</span><br><span class="line">        .agg(F.count(<span class="string">&#x27;movieId&#x27;</span>).alias(<span class="string">&#x27;count_data&#x27;</span>))</span><br><span class="line">        .orderBy(<span class="string">&#x27;count_data&#x27;</span>,ascending = <span class="literal">False</span>)</span><br><span class="line"> <span class="number">3.3</span> ：first()方法，取出第一行数据</span><br><span class="line">	first()取出的是一个row对象，不在是一个df对象，不能使用show()进行展示哦</span><br><span class="line">		user_rdd = df.where(<span class="string">&#x27;score &gt;3&#x27;</span>).groupBy(<span class="string">&#x27;userId&#x27;</span>)</span><br><span class="line">        .agg(F.count(<span class="string">&#x27;movieId&#x27;</span>).alias(<span class="string">&#x27;count_data&#x27;</span>))</span><br><span class="line">        .orderBy(<span class="string">&#x27;count_data&#x27;</span>,ascending = <span class="literal">False</span>).first()</span><br><span class="line">     <span class="built_in">print</span>(user_rdd)  <span class="comment"># 直接进行打印得到一个rdd对象，我们需要的是userId</span></span><br><span class="line">     userId = user_rdd[<span class="string">&#x27;userId&#x27;</span>] <span class="comment"># 得到目标用户</span></span><br><span class="line">     <span class="built_in">print</span>(user_rdd[<span class="string">&#x27;userId&#x27;</span>])</span><br><span class="line"> <span class="number">3.4</span> ： 根据用户<span class="built_in">id</span>查找这个用户所有打分电影的平均分:</span><br><span class="line"><span class="comment"># 方法1</span></span><br><span class="line">user_movie_avg = df.groupBy(<span class="string">&#x27;userId&#x27;</span>).agg(F.avg(<span class="string">&#x27;score&#x27;</span>).alias(<span class="string">&#x27;avg_data&#x27;</span>))</span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line">user_movie_avg = movie_avg.where(movie_avg[<span class="string">&#x27;userId&#x27;</span>] == userId)</span><br><span class="line"><span class="comment"># 结果展示</span></span><br><span class="line">user_movie_avg.show()</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4. 查询每个用户的平均打分，最低打分，最高打分</span></span><br><span class="line"><span class="comment"># agg()里面可以使用多个内置函数</span></span><br><span class="line">df.groupBy(<span class="string">&#x27;userId&#x27;</span>).agg(F.avg(<span class="string">&#x27;score&#x27;</span>) , F.<span class="built_in">max</span>(<span class="string">&#x27;score&#x27;</span>) , F.<span class="built_in">min</span>(<span class="string">&#x27;score&#x27;</span>))</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 5. 查询被评分超过100次的电影的平均分，进行排名，取出Top10</span></span><br><span class="line">df.groupBy(<span class="string">&#x27;movieId&#x27;</span>)</span><br><span class="line">.agg(F.count(<span class="string">&#x27;movieId&#x27;</span>).alias(<span class="string">&#x27;count_data&#x27;</span>) , F.avg(<span class="string">&#x27;score&#x27;</span>).alias(<span class="string">&#x27;avg_data&#x27;</span>))</span><br><span class="line">.where(<span class="string">&#x27;count_data &gt; 100&#x27;</span>)</span><br><span class="line">.orderBy(<span class="string">&#x27;avg_data&#x27;</span>,ascending = <span class="literal">False</span>).limit(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="5-分区数目（了解）"><a href="#5-分区数目（了解）" class="headerlink" title="5. 分区数目（了解）"></a>5. 分区数目（了解）</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调整分区数目</span></span><br><span class="line">ss = SparkSession.builder.master(<span class="string">&#x27;yarn&#x27;</span>)</span><br><span class="line">.config(<span class="string">&#x27;spark.sql.shuffle.partitions&#x27;</span>,<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">.getOrCreate()</span><br></pre></td></tr></table></figure></div>

<h3 id="6-sparkSession读取不同类型文件"><a href="#6-sparkSession读取不同类型文件" class="headerlink" title="6. sparkSession读取不同类型文件"></a>6. sparkSession读取不同类型文件</h3><h4 id="6-1-数据读入"><a href="#6-1-数据读入" class="headerlink" title="6.1 数据读入"></a>6.1 数据读入</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-700c483397a510330ca7de2707f25655_720w.webp"
                     
                ></p>
<p>注意在读取mysql的数据时候，需要将驱动依赖放到spark&#x2F;jars&#x2F;下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-3e8dacd73984d322bed1d8413352aaca_720w.webp"
                     
                ></p>
<h4 id="6-2-数据读出"><a href="#6-2-数据读出" class="headerlink" title="6.2 数据读出"></a>6.2 数据读出</h4><ul>
<li>将df数据写入到不同的文件下</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-c8c57fd77bc297648d1b43286fe44879_720w.webp"
                     
                ></p>
<h3 id="7-自定义函数"><a href="#7-自定义函数" class="headerlink" title="7. 自定义函数"></a>7. 自定义函数</h3><h4 id="7-1-函数分类"><a href="#7-1-函数分类" class="headerlink" title="7.1 函数分类"></a>7.1 函数分类</h4><ul>
<li>udf		一进一出	可以自定义</li>
<li>udaf      多进一出    可以自定义  需要借助pandas</li>
<li>udtf       一进多出    不能自定义</li>
</ul>
<ol>
<li>自定义udf函数步骤<ul>
<li>数据是一行一行处理（传递一行处理一行）</li>
<li>自定义udf函数也可以使用sql语句的方式进行使用哦</li>
</ul>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-57e95d180036f75c974003f974c9beae_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-325b8dae62fcf9f0dd9a18e9813812be_720w.webp"
                     
                ></p>
<ul>
<li>自定义函数也可以使用装饰器的方式进行注册</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-0dba6e23b1d01568ae72d85f5a1b758a_720w.webp"
                     
                ></p>
<ul>
<li>但这种方式不能使用SQL语句的方式进行使用</li>
</ul>
<ol start="2">
<li><p>自定义udaf函数步骤</p>
<ul>
<li>自定义udaf函数的格式</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-fec57c303f7f458e06b1d5cbc852d52e_720w.webp"
                     
                ></p>
<ul>
<li>注册方法同上</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-924a9ed6806e53131145c930ce0b023e_720w.webp"
                     
                ></p>
</li>
</ol>
<h3 id="8-pandas的学习"><a href="#8-pandas的学习" class="headerlink" title="8.pandas的学习"></a>8.pandas的学习</h3><ol>
<li><p>定义方式（两种）：</p>
<ul>
<li><p>值得注意的是pandas中的df和spark中的df不相同哦，pandas中的是单机计算资源，速度较慢</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-414651540dc98062801a1fa16f4a7a4d_720w.webp"
                     
                ></p>
</li>
</ul>
</li>
<li><p>将pandas中的df转化为spark中的df进行计算</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-c4ad6c77cf47edd6c79d6f4fd2b1478f_720w.webp"
                     
                ></p>
</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-79a388b17fb470113442687d1ce7b099_720w.webp"
                      style="zoom:80%;" 
                >
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据技术</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>一文讲懂Kafka</title>
    <url>/2024/06/04/%E4%B8%80%E6%96%87%E8%AE%B2%E6%87%82Kafka/</url>
    <content><![CDATA[<h2 id="初识-Kafka"><a href="#初识-Kafka" class="headerlink" title="初识 Kafka"></a>初识 Kafka</h2><h3 id="什么是-Kafka"><a href="#什么是-Kafka" class="headerlink" title="什么是 Kafka"></a>什么是 Kafka</h3><p>Kafka 是由 <code>Linkedin</code> 公司开发的，它是一个分布式的，支持多分区、多副本，基于 Zookeeper 的分布式消息流平台，它同时也是一款开源的<strong>基于发布订阅模式的消息引擎系统</strong>。</p>
<h3 id="Kafka-的基本术语"><a href="#Kafka-的基本术语" class="headerlink" title="Kafka 的基本术语"></a>Kafka 的基本术语</h3><p>消息：Kafka 中的数据单元被称为<code>消息</code>，也被称为记录，可以把它看作数据库表中某一行的记录。</p>
<p>批次：为了提高效率， 消息会<code>分批次</code>写入 Kafka，批次就代指的是一组消息。</p>
<p>主题：消息的种类称为 <code>主题</code>（Topic）,可以说一个主题代表了一类消息。相当于是对消息进行分类。主题就像是数据库中的表。</p>
<p>分区：主题可以被分为若干个分区（partition），同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现 kafka 的<code>伸缩性</code>，单一主题中的分区有序，但是无法保证主题中所有的分区有序</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb068baff14810~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<p>生产者： 向主题发布消息的客户端应用程序称为<code>生产者</code>（Producer），生产者用于持续不断的向某个主题发送消息。</p>
<p>消费者：订阅主题消息的客户端程序称为<code>消费者</code>（Consumer），消费者用于处理生产者产生的消息。</p>
<p>消费者群组：生产者与消费者的关系就如同餐厅中的厨师和顾客之间的关系一样，一个厨师对应多个顾客，也就是一个生产者对应多个消费者，<code>消费者群组</code>（Consumer Group）指的就是由一个或多个消费者组成的群体。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb068bab005524~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<p>偏移量：<code>偏移量</code>（Consumer Offset）是一种元数据，它是一个不断递增的整数值，用来记录消费者发生重平衡时的位置，以便用来恢复数据。</p>
<p>broker: 一个独立的 Kafka 服务器就被称为 <code>broker</code>，broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。</p>
<p>broker 集群：broker 是<code>集群</code> 的组成部分，broker 集群由一个或多个 broker 组成，每个集群都有一个 broker 同时充当了<code>集群控制器</code>的角色（自动从集群的活跃成员中选举出来）。</p>
<p>副本：Kafka 中消息的备份又叫做 <code>副本</code>（Replica），副本的数量是可以配置的，Kafka 定义了两类副本：领导者副本（Leader Replica） 和 追随者副本（Follower Replica），前者对外提供服务，后者只是被动跟随。</p>
<p>重平衡：Rebalance。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段。</p>
<h3 id="Kafka-的特性（设计原则）"><a href="#Kafka-的特性（设计原则）" class="headerlink" title="Kafka 的特性（设计原则）"></a>Kafka 的特性（设计原则）</h3><ul>
<li><code>高吞吐、低延迟</code>：kakfa 最大的特点就是收发消息非常快，kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒。</li>
<li><code>高伸缩性</code>： 每个主题(topic) 包含多个分区(partition)，主题中的分区可以分布在不同的主机(broker)中。</li>
<li><code>持久性、可靠性</code>： Kafka 能够允许数据的持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，Kafka 底层的数据存储是基于 Zookeeper 存储的，Zookeeper 我们知道它的数据能够持久存储。</li>
<li><code>容错性</code>： 允许集群中的节点失败，某个节点宕机，Kafka 集群能够正常工作</li>
<li><code>高并发</code>： 支持数千个客户端同时读写</li>
</ul>
<h3 id="Kafka-的使用场景"><a href="#Kafka-的使用场景" class="headerlink" title="Kafka 的使用场景"></a>Kafka 的使用场景</h3><ul>
<li>活动跟踪：Kafka 可以用来跟踪用户行为，比如我们经常回去淘宝购物，你打开淘宝的那一刻，你的登陆信息，登陆次数都会作为消息传输到 Kafka ，当你浏览购物的时候，你的浏览信息，你的搜索指数，你的购物爱好都会作为一个个消息传递给 Kafka ，这样就可以生成报告，可以做智能推荐，购买喜好等。</li>
<li>传递消息：Kafka 另外一个基本用途是传递消息，应用程序向用户发送通知就是通过传递消息来实现的，这些应用组件可以生成消息，而不需要关心消息的格式，也不需要关心消息是如何发送的。</li>
<li>度量指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li>
<li>日志记录：Kafka 的基本概念来源于提交日志，比如我们可以把数据库的更新发送到 Kafka 上，用来记录数据库的更新时间，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</li>
<li>流式处理：流式处理是有一个能够提供多种应用程序的领域。</li>
<li>限流削峰：Kafka 多用于互联网领域某一时刻请求特别多的情况下，可以把请求写入Kafka 中，避免直接请求后端程序导致服务崩溃。</li>
</ul>
<h3 id="Kafka-的消息队列"><a href="#Kafka-的消息队列" class="headerlink" title="Kafka 的消息队列"></a>Kafka 的消息队列</h3><p>Kafka 的消息队列一般分为两种模式：点对点模式和发布订阅模式</p>
<p>Kafka 是支持消费者群组的，也就是说 Kafka 中会有一个或者多个消费者，如果一个生产者生产的消息由一个消费者进行消费的话，那么这种模式就是点对点模式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb068bb0f1a796~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<p>如果一个生产者或者多个生产者产生的消息能够被多个消费者同时消费的情况，这样的消息队列成为发布订阅模式的消息队列</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb068bb477c550~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<h3 id="Kafka-系统架构"><a href="#Kafka-系统架构" class="headerlink" title="Kafka 系统架构"></a>Kafka 系统架构</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb068cc433bb21~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<p>如上图所示，一个典型的 Kafka 集群中包含若干Producer（可以是web前端产生的Page View，或者是服务器日志，系统CPU、Memory等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</p>
<h3 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h3><p>Kafka 有四个核心API，它们分别是</p>
<ul>
<li>Producer API，它允许应用程序向一个或多个 topics 上发送消息记录</li>
<li>Consumer API，允许应用程序订阅一个或多个 topics 并处理为其生成的记录流</li>
<li>Streams API，它允许应用程序作为流处理器，从一个或多个主题中消费输入流并为其生成输出流，有效的将输入流转换为输出流。</li>
<li>Connector API，它允许构建和运行将 Kafka 主题连接到现有应用程序或数据系统的可用生产者和消费者。例如，关系数据库的连接器可能会捕获对表的所有更改</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb068ba7a2fbdd~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<h3 id="Kafka-为何如此之快"><a href="#Kafka-为何如此之快" class="headerlink" title="Kafka 为何如此之快"></a>Kafka 为何如此之快</h3><p>Kafka 实现了<code>零拷贝</code>原理来快速移动数据，避免了内核之间的切换。Kafka 可以将数据记录分批发送，从生产者到文件系统（Kafka 主题日志）到消费者，可以端到端的查看这些批次的数据。</p>
<p>批处理能够进行更有效的数据压缩并减少 I&#x2F;O 延迟，Kafka 采取顺序写入磁盘的方式，避免了随机磁盘寻址的浪费，更多关于磁盘寻址的了解，请参阅 <a class="link"   href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247484654&idx=1&sn=9b6f5aaad05a49416e8f30e6b86691ae&chksm=fc45f91dcb32700b683b9a13d0d94d261171d346333d73967a4d501de3ecc273d67e8251aeae&token=674527772&lang=zh_CN%23rd" >程序员需要了解的硬核知识之磁盘 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 。</p>
<p>总结一下其实就是四个要点</p>
<ul>
<li>顺序读写</li>
<li>零拷贝</li>
<li>消息压缩</li>
<li>分批发送</li>
</ul>
<h2 id="Kafka-安装和重要配置"><a href="#Kafka-安装和重要配置" class="headerlink" title="Kafka 安装和重要配置"></a>Kafka 安装和重要配置</h2><p>Kafka 安装我在 Kafka 系列第一篇应该比较详细了，详情见<a class="link"   href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247484570&idx=1&sn=1ad1c96bc7d47b88e976cbd045baf7d7&chksm=fc45f969cb32707f882c52d7434b2c0bf2ccbbc2cd854e1dc5c203deb8ae9c1831cf216e8bad&token=674527772&lang=zh_CN%23rd" >带你涨姿势的认识一下kafka <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 这篇文章。</p>
<p>那我们还是主要来说一下 Kafka 中的重要参数配置吧，这些参数对 Kafka 来说是非常重要的。</p>
<h3 id="broker-端配置"><a href="#broker-端配置" class="headerlink" title="broker 端配置"></a>broker 端配置</h3><ul>
<li>broker.id</li>
</ul>
<p>每个 kafka broker 都有一个唯一的标识来表示，这个唯一的标识符即是 broker.id，它的默认值是 0。这个值在 kafka 集群中必须是唯一的，这个值可以任意设定，</p>
<ul>
<li>port</li>
</ul>
<p>如果使用配置样本来启动 kafka，它会监听 9092 端口。修改 port 配置参数可以把它设置成任意的端口。要注意，如果使用 1024 以下的端口，需要使用 root 权限启动 kakfa。</p>
<ul>
<li>zookeeper.connect</li>
</ul>
<p>用于保存 broker 元数据的 Zookeeper 地址是通过 zookeeper.connect 来指定的。比如我可以这么指定 <code>localhost:2181</code> 表示这个 Zookeeper 是运行在本地 2181 端口上的。我们也可以通过 比如我们可以通过 <code>zk1:2181,zk2:2181,zk3:2181</code> 来指定 zookeeper.connect 的多个参数值。该配置参数是用冒号分割的一组 <code>hostname:port/path</code> 列表，其含义如下</p>
<p>hostname 是 Zookeeper 服务器的机器名或者 ip 地址。</p>
<p>port 是 Zookeeper 客户端的端口号</p>
<p>&#x2F;path 是可选择的 Zookeeper 路径，Kafka 路径是使用了 <code>chroot</code> 环境，如果不指定默认使用跟路径。</p>
<blockquote>
<p>如果你有两套 Kafka 集群，假设分别叫它们 kafka1 和 kafka2，那么两套集群的<code>zookeeper.connect</code>参数可以这样指定：<code>zk1:2181,zk2:2181,zk3:2181/kafka1</code>和<code>zk1:2181,zk2:2181,zk3:2181/kafka2</code></p>
</blockquote>
<ul>
<li>log.dirs</li>
</ul>
<p>Kafka 把所有的消息都保存到磁盘上，存放这些日志片段的目录是通过 <code>log.dirs</code> 来制定的，它是用一组逗号来分割的本地系统路径，log.dirs 是没有默认值的，<strong>你必须手动指定他的默认值</strong>。其实还有一个参数是 <code>log.dir</code>，如你所知，这个配置是没有 <code>s</code> 的，默认情况下只用配置 log.dirs 就好了，比如你可以通过 <code>/home/kafka1,/home/kafka2,/home/kafka3</code> 这样来配置这个参数的值。</p>
<ul>
<li>num.recovery.threads.per.data.dir</li>
</ul>
<p>对于如下3种情况，Kafka 会使用<code>可配置的线程池</code>来处理日志片段。</p>
<p>服务器正常启动，用于打开每个分区的日志片段；</p>
<p>服务器崩溃后重启，用于检查和截断每个分区的日志片段；</p>
<p>服务器正常关闭，用于关闭日志片段。</p>
<p>默认情况下，每个日志目录只使用一个线程。因为这些线程只是在服务器启动和关闭时会用到，所以完全可以设置大量的线程来达到井行操作的目的。特别是对于包含大量分区的服务器来说，一旦发生崩愤，在进行恢复时使用井行操作可能会省下数小时的时间。设置此参数时需要注意，所配置的数字对应的是 log.dirs 指定的单个日志目录。也就是说，如果 num.recovery.threads.per.data.dir 被设为 8，并且 log.dir 指定了 3 个路径，那么总共需要 24 个线程。</p>
<ul>
<li>auto.create.topics.enable</li>
</ul>
<p>默认情况下，kafka 会使用三种方式来自动创建主题，下面是三种情况：</p>
<p>当一个生产者开始往主题写入消息时</p>
<p>当一个消费者开始从主题读取消息时</p>
<p>当任意一个客户端向主题发送元数据请求时</p>
<p><code>auto.create.topics.enable</code>参数我建议最好设置成 false，即不允许自动创建 Topic。在我们的线上环境里面有很多名字稀奇古怪的 Topic，我想大概都是因为该参数被设置成了 true 的缘故。</p>
<h3 id="主题默认配置"><a href="#主题默认配置" class="headerlink" title="主题默认配置"></a>主题默认配置</h3><p>Kafka 为新创建的主题提供了很多默认配置参数，下面就来一起认识一下这些参数</p>
<ul>
<li>num.partitions</li>
</ul>
<p>num.partitions 参数指定了新创建的主题需要包含多少个分区。如果启用了主题自动创建功能（该功能是默认启用的），主题分区的个数就是该参数指定的值。该参数的默认值是 1。要注意，我们可以增加主题分区的个数，但不能减少分区的个数。</p>
<ul>
<li>default.replication.factor</li>
</ul>
<p>这个参数比较简单，它表示 kafka保存消息的副本数，如果一个副本失效了，另一个还可以继续提供服务default.replication.factor 的默认值为1，这个参数在你启用了主题自动创建功能后有效。</p>
<ul>
<li>log.retention.ms</li>
</ul>
<p>Kafka 通常根据时间来决定数据可以保留多久。默认使用 log.retention.hours 参数来配置时间，默认是 168 个小时，也就是一周。除此之外，还有两个参数 log.retention.minutes 和 log.retentiion.ms 。这三个参数作用是一样的，都是决定消息多久以后被删除，推荐使用 log.retention.ms。</p>
<ul>
<li>log.retention.bytes</li>
</ul>
<p>另一种保留消息的方式是判断消息是否过期。它的值通过参数 <code>log.retention.bytes</code> 来指定，作用在每一个分区上。也就是说，如果有一个包含 8 个分区的主题，并且 log.retention.bytes 被设置为 1GB，那么这个主题最多可以保留 8GB 数据。所以，当主题的分区个数增加时，整个主题可以保留的数据也随之增加。</p>
<ul>
<li>log.segment.bytes</li>
</ul>
<p>上述的日志都是作用在日志片段上，而不是作用在单个消息上。当消息到达 broker 时，它们被追加到分区的当前日志片段上，当日志片段大小到达 log.segment.bytes 指定上限（默认为 1GB）时，当前日志片段就会被关闭，一个新的日志片段被打开。如果一个日志片段被关闭，就开始等待过期。这个参数的值越小，就越会频繁的关闭和分配新文件，从而降低磁盘写入的整体效率。</p>
<ul>
<li>log.segment.ms</li>
</ul>
<p>上面提到日志片段经关闭后需等待过期，那么 <code>log.segment.ms</code> 这个参数就是指定日志多长时间被关闭的参数和，log.segment.ms 和 log.retention.bytes 也不存在互斥问题。日志片段会在大小或时间到达上限时被关闭，就看哪个条件先得到满足。</p>
<ul>
<li>message.max.bytes</li>
</ul>
<p>broker 通过设置 <code>message.max.bytes</code> 参数来限制单个消息的大小，默认是 1000 000， 也就是 1MB，如果生产者尝试发送的消息超过这个大小，不仅消息不会被接收，还会收到 broker 返回的错误消息。跟其他与字节相关的配置参数一样，该参数指的是压缩后的消息大小，也就是说，只要压缩后的消息小于 mesage.max.bytes，那么消息的实际大小可以大于这个值</p>
<p>这个值对性能有显著的影响。值越大，那么负责处理网络连接和请求的线程就需要花越多的时间来处理这些请求。它还会增加磁盘写入块的大小，从而影响 IO 吞吐量。</p>
<ul>
<li>retention.ms</li>
</ul>
<p>规定了该主题消息被保存的时常，默认是7天，即该主题只能保存7天的消息，一旦设置了这个值，它会覆盖掉 Broker 端的全局参数值。</p>
<ul>
<li>retention.bytes</li>
</ul>
<p><code>retention.bytes</code>：规定了要为该 Topic 预留多大的磁盘空间。和全局参数作用相似，这个值通常在多租户的 Kafka 集群中会有用武之地。当前默认值是 -1，表示可以无限使用磁盘空间。</p>
<h3 id="JVM-参数配置"><a href="#JVM-参数配置" class="headerlink" title="JVM 参数配置"></a>JVM 参数配置</h3><p>JDK 版本一般推荐直接使用 JDK1.8，这个版本也是现在中国大部分程序员的首选版本。</p>
<p>说到 JVM 端设置，就绕不开<code>堆</code>这个话题，业界最推崇的一种设置方式就是直接将 JVM 堆大小设置为 6GB，这样会避免很多 Bug 出现。</p>
<p>JVM 端配置的另一个重要参数就是垃圾回收器的设置，也就是平时常说的 <code>GC</code> 设置。如果你依然在使用 Java 7，那么可以根据以下法则选择合适的垃圾回收器：</p>
<ul>
<li>如果 Broker 所在机器的 CPU 资源非常充裕，建议使用 CMS 收集器。启用方法是指定<code>-XX:+UseCurrentMarkSweepGC</code>。</li>
<li>否则，使用吞吐量收集器。开启方法是指定<code>-XX:+UseParallelGC</code>。</li>
</ul>
<p>当然了，如果你已经在使用 Java 8 了，那么就用默认的 G1 收集器就好了。在没有任何调优的情况下，G1 表现得要比 CMS 出色，主要体现在更少的 Full GC，需要调整的参数更少等，所以使用 G1 就好了。</p>
<p>一般 G1 的调整只需要这两个参数即可</p>
<ul>
<li>MaxGCPauseMillis</li>
</ul>
<p>该参数指定每次垃圾回收默认的停顿时间。该值不是固定的，G1可以根据需要使用更长的时间。它的默认值是 200ms，也就是说，每一轮垃圾回收大概需要200 ms 的时间。</p>
<ul>
<li>InitiatingHeapOccupancyPercent</li>
</ul>
<p>该参数指定了 G1 启动新一轮垃圾回收之前可以使用的堆内存百分比，默认值是45，这就表明G1在堆使用率到达45之前不会启用垃圾回收。这个百分比包括新生代和老年代。</p>
<h2 id="Kafka-Producer"><a href="#Kafka-Producer" class="headerlink" title="Kafka Producer"></a>Kafka Producer</h2><p>在 Kafka 中，我们把产生消息的那一方称为<code>生产者</code>，比如我们经常回去淘宝购物，你打开淘宝的那一刻，你的登陆信息，登陆次数都会作为消息传输到 Kafka 后台，当你浏览购物的时候，你的浏览信息，你的搜索指数，你的购物爱好都会作为一个个消息传递给 Kafka 后台，然后淘宝会根据你的爱好做智能推荐，致使你的钱包从来都禁不住诱惑，那么这些生产者产生的<code>消息</code>是怎么传到 Kafka 应用程序的呢？发送过程是怎么样的呢？</p>
<p>尽管消息的产生非常简单，但是消息的发送过程还是比较复杂的，如图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb068cd8d08784~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<p>我们从创建一个<code>ProducerRecord</code> 对象开始，ProducerRecord 是 Kafka 中的一个核心类，它代表了一组 Kafka 需要发送的 <code>key/value</code> 键值对，它由记录要发送到的主题名称（Topic Name），可选的分区号（Partition Number）以及可选的键值对构成。</p>
<p>在发送 ProducerRecord 时，我们需要将键值对对象由序列化器转换为字节数组，这样它们才能够在网络上传输。然后消息到达了分区器。</p>
<p>如果发送过程中指定了有效的分区号，那么在发送记录时将使用该分区。如果发送过程中未指定分区，则将使用key 的 hash 函数映射指定一个分区。如果发送的过程中既没有分区号也没有，则将以循环的方式分配一个分区。选好分区后，生产者就知道向哪个主题和分区发送数据了。</p>
<p>ProducerRecord 还有关联的时间戳，如果用户没有提供时间戳，那么生产者将会在记录中使用当前的时间作为时间戳。Kafka 最终使用的时间戳取决于 topic 主题配置的时间戳类型。</p>
<ul>
<li>如果将主题配置为使用 <code>CreateTime</code>，则生产者记录中的时间戳将由 broker 使用。</li>
<li>如果将主题配置为使用<code>LogAppendTime</code>，则生产者记录中的时间戳在将消息添加到其日志中时，将由 broker 重写。</li>
</ul>
<p>然后，这条消息被存放在一个记录批次里，这个批次里的所有消息会被发送到相同的主题和分区上。由一个独立的线程负责把它们发到 Kafka Broker 上。</p>
<p>Kafka Broker 在收到消息时会返回一个响应，如果写入成功，会返回一个 RecordMetaData 对象，<strong>它包含了主题和分区信息，以及记录在分区里的偏移量，上面两种的时间戳类型也会返回给用户</strong>。如果写入失败，会返回一个错误。生产者在收到错误之后会尝试重新发送消息，几次之后如果还是失败的话，就返回错误消息。</p>
<h3 id="创建-Kafka-生产者"><a href="#创建-Kafka-生产者" class="headerlink" title="创建 Kafka 生产者"></a>创建 Kafka 生产者</h3><p>要向 Kafka 写入消息，首先需要创建一个生产者对象，并设置一些属性。Kafka 生产者有3个必选的属性</p>
<ul>
<li>bootstrap.servers</li>
</ul>
<p>该属性指定 broker 的地址清单，地址的格式为 <code>host:port</code>。清单里不需要包含所有的 broker 地址，生产者会从给定的 broker 里查找到其他的 broker 信息。不过建议至少要提供<code>两个</code> broker 信息，一旦其中一个宕机，生产者仍然能够连接到集群上。</p>
<ul>
<li>key.serializer</li>
</ul>
<p>broker 需要接收到序列化之后的 <code>key/value</code>值，所以生产者发送的消息需要经过序列化之后才传递给 Kafka Broker。生产者需要知道采用何种方式把 Java 对象转换为字节数组。key.serializer 必须被设置为一个实现了<code>org.apache.kafka.common.serialization.Serializer</code> 接口的类，生产者会使用这个类把键对象序列化为字节数组。这里拓展一下 Serializer 类</p>
<p>Serializer 是一个接口，它表示类将会采用何种方式序列化，它的作用是把对象转换为字节，实现了 Serializer 接口的类主要有 <code>ByteArraySerializer</code>、<code>StringSerializer</code>、<code>IntegerSerializer</code> ，其中 ByteArraySerialize 是 Kafka 默认使用的序列化器，其他的序列化器还有很多，你可以通过 <a class="link"   href="https://link.juejin.cn/?target=https://kafka.apache.org/23/javadoc/index.html?org/apache/kafka/clients/producer/KafkaProducer.html" >这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 查看其他序列化器。要注意的一点：<strong>key.serializer 是必须要设置的，即使你打算只发送值的内容</strong>。</p>
<ul>
<li>value.serializer</li>
</ul>
<p>与 key.serializer 一样，value.serializer 指定的类会将值序列化。</p>
<p>下面代码演示了如何创建一个 Kafka 生产者，这里只指定了必要的属性，其他使用默认的配置</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制代码private Properties properties = new Properties();</span><br><span class="line">properties.put(&quot;bootstrap.servers&quot;,&quot;broker1:9092,broker2:9092&quot;);</span><br><span class="line">properties.put(&quot;key.serializer&quot;,&quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">properties.put(&quot;value.serializer&quot;,&quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">properties = new KafkaProducer&lt;String,String&gt;(properties);</span><br></pre></td></tr></table></figure></div>

<p>来解释一下这段代码</p>
<ul>
<li>首先创建了一个 Properties 对象</li>
<li>使用 <code>StringSerializer</code> 序列化器序列化 key &#x2F; value 键值对</li>
<li>在这里我们创建了一个新的生产者对象，并为键值设置了恰当的类型，然后把 Properties 对象传递给他。</li>
</ul>
<h3 id="Kafka-消息发送"><a href="#Kafka-消息发送" class="headerlink" title="Kafka 消息发送"></a>Kafka 消息发送</h3><p>实例化生产者对象后，接下来就可以开始发送消息了，发送消息主要由下面几种方式</p>
<h3 id="简单消息发送"><a href="#简单消息发送" class="headerlink" title="简单消息发送"></a>简单消息发送</h3><p>Kafka 最简单的消息发送如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制代码ProducerRecord&lt;String,String&gt; record =</span><br><span class="line">                new ProducerRecord&lt;String, String&gt;(&quot;CustomerCountry&quot;,&quot;West&quot;,&quot;France&quot;);</span><br><span class="line"></span><br><span class="line">producer.send(record);</span><br></pre></td></tr></table></figure></div>

<p>代码中生产者(producer)的 <code>send()</code> 方法需要把 <code>ProducerRecord</code> 的对象作为参数进行发送，ProducerRecord 有很多构造函数，这个我们下面讨论，这里调用的是</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制代码public ProducerRecord(String topic, K key, V value) &#123;&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个构造函数，需要传递的是 topic主题，key 和 value。</p>
<p>把对应的参数传递完成后，生产者调用 send() 方法发送消息（ProducerRecord对象）。我们可以从生产者的架构图中看出，消息是先被写入分区中的缓冲区中，然后分批次发送给 Kafka Broker。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb068ce25704e8~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<p>发送成功后，send() 方法会返回一个 <code>Future(java.util.concurrent)</code> 对象，Future 对象的类型是 <code>RecordMetadata</code> 类型，我们上面这段代码没有考虑返回值，所以没有生成对应的 Future 对象，所以没有办法知道消息是否发送成功。如果不是很重要的信息或者对结果不会产生影响的信息，可以使用这种方式进行发送。</p>
<p>我们可以忽略发送消息时可能发生的错误或者在服务器端可能发生的错误，但在消息发送之前，生产者还可能发生其他的异常。这些异常有可能是 <code>SerializationException(序列化失败)</code>，<code>BufferedExhaustedException 或 TimeoutException(说明缓冲区已满)</code>，又或是 <code>InterruptedException(说明发送线程被中断)</code></p>
<h3 id="同步发送消息"><a href="#同步发送消息" class="headerlink" title="同步发送消息"></a>同步发送消息</h3><p>第二种消息发送机制如下所示</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制代码ProducerRecord&lt;String,String&gt; record =</span><br><span class="line">                new ProducerRecord&lt;String, String&gt;(&quot;CustomerCountry&quot;,&quot;West&quot;,&quot;France&quot;);</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line">  RecordMetadata recordMetadata = producer.send(record).get();</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">  e.printStackTrace()；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这种发送消息的方式较上面的发送方式有了改进，首先调用 send() 方法，然后再调用 get() 方法等待 Kafka 响应。如果服务器返回错误，get() 方法会抛出异常，如果没有发生错误，我们会得到 <code>RecordMetadata</code> 对象，可以用它来查看消息记录。</p>
<p>生产者（KafkaProducer）在发送的过程中会出现两类错误：其中一类是重试错误，这类错误可以通过重发消息来解决。比如连接的错误，可以通过再次建立连接来解决；无<code>主</code>错误则可以通过重新为分区选举首领来解决。KafkaProducer 被配置为自动重试，如果多次重试后仍无法解决问题，则会抛出重试异常。另一类错误是无法通过重试来解决的，比如<code>消息过大</code>对于这类错误，KafkaProducer 不会进行重试，直接抛出异常。</p>
<h3 id="异步发送消息"><a href="#异步发送消息" class="headerlink" title="异步发送消息"></a>异步发送消息</h3><p>同步发送消息都有个问题，那就是同一时间只能有一个消息在发送，这会造成许多消息无法直接发送，造成消息滞后，无法发挥效益最大化。</p>
<p>比如消息在应用程序和 Kafka 集群之间一个来回需要 10ms。如果发送完每个消息后都等待响应的话，那么发送100个消息需要 1 秒，但是如果是<code>异步</code>方式的话，发送 100 条消息所需要的时间就会少很多很多。大多数时候，虽然Kafka 会返回 <code>RecordMetadata</code> 消息，但是我们并不需要等待响应。</p>
<p>为了在异步发送消息的同时能够对异常情况进行处理，生产者提供了回掉支持。下面是回调的一个例子</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制代码ProducerRecord&lt;String, String&gt; producerRecord = new ProducerRecord&lt;String, String&gt;(&quot;CustomerCountry&quot;, &quot;Huston&quot;, &quot;America&quot;);</span><br><span class="line">        producer.send(producerRecord,new DemoProducerCallBack());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DemoProducerCallBack implements Callback &#123;</span><br><span class="line"></span><br><span class="line">  public void onCompletion(RecordMetadata metadata, Exception exception) &#123;</span><br><span class="line">    if(exception != null)&#123;</span><br><span class="line">      exception.printStackTrace();;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先实现回调需要定义一个实现了<code>org.apache.kafka.clients.producer.Callback</code>的类，这个接口只有一个 <code>onCompletion</code>方法。如果 kafka 返回一个错误，onCompletion 方法会抛出一个非空(non null)异常，这里我们只是简单的把它打印出来，如果是生产环境需要更详细的处理，然后在 send() 方法发送的时候传递一个 Callback 回调的对象。</p>
<h3 id="生产者分区机制"><a href="#生产者分区机制" class="headerlink" title="生产者分区机制"></a>生产者分区机制</h3><p>Kafka 对于数据的读写是以<code>分区</code>为粒度的，分区可以分布在多个主机（Broker）中，这样每个节点能够实现独立的数据写入和读取，并且能够通过增加新的节点来增加 Kafka 集群的吞吐量，通过分区部署在多个 Broker 来实现<code>负载均衡</code>的效果。</p>
<p>上面我们介绍了生产者的发送方式有三种：<code>不管结果如何直接发送</code>、<code>发送并返回结果</code>、<code>发送并回调</code>。由于消息是存在主题（topic）的分区（partition）中的，所以当 Producer 生产者发送产生一条消息发给 topic 的时候，你如何判断这条消息会存在哪个分区中呢？</p>
<p>这其实就设计到 Kafka 的分区机制了。</p>
<h4 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h4><p>Kafka 的分区策略指的就是将生产者发送到哪个分区的算法。Kafka 为我们提供了默认的分区策略，同时它也支持你自定义分区策略。</p>
<p>如果要自定义分区策略的话，你需要显示配置生产者端的参数 <code>Partitioner.class</code>，我们可以看一下这个类它位于 <code>org.apache.kafka.clients.producer</code> 包下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制代码public interface Partitioner extends Configurable, Closeable &#123;</span><br><span class="line">  </span><br><span class="line">  public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster);</span><br><span class="line"></span><br><span class="line">  public void close();</span><br><span class="line">  </span><br><span class="line">  default public void onNewBatch(String topic, Cluster cluster, int prevPartition) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>Partitioner 类有三个方法，分别来解释一下</p>
<ul>
<li>partition(): 这个类有几个参数: <code>topic</code>，表示需要传递的主题；<code>key</code> 表示消息中的键值；<code>keyBytes</code>表示分区中序列化过后的key，byte数组的形式传递；<code>value</code> 表示消息的 value 值；<code>valueBytes</code> 表示分区中序列化后的值数组；<code>cluster</code>表示当前集群的原数据。Kafka 给你这么多信息，就是希望让你能够充分地利用这些信息对消息进行分区，计算出它要被发送到哪个分区中。</li>
<li>close() : 继承了 <code>Closeable</code> 接口能够实现 close() 方法，在分区关闭时调用。</li>
<li>onNewBatch(): 表示通知分区程序用来创建新的批次</li>
</ul>
<p>其中与分区策略息息相关的就是 partition() 方法了，分区策略有下面这几种</p>
<p><strong>顺序轮询</strong></p>
<p>顺序分配，消息是均匀的分配给每个 partition，即每个分区存储一次消息。就像下面这样</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb068cdf11869e~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<p>上图表示的就是轮询策略，轮训策略是 Kafka Producer 提供的默认策略，如果你不使用指定的轮训策略的话，Kafka 默认会使用顺序轮训策略的方式。</p>
<p><strong>随机轮询</strong></p>
<p>随机轮询简而言之就是随机的向 partition 中保存消息，如下图所示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb068ce25be1db~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<p>实现随机分配的代码只需要两行，如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制代码List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">return ThreadLocalRandom.current().nextInt(partitions.size());</span><br></pre></td></tr></table></figure></div>

<p>先计算出该主题总的分区数，然后随机地返回一个小于它的正整数。</p>
<p>本质上看随机策略也是力求将数据均匀地打散到各个分区，但从实际表现来看，它要逊于轮询策略，所以<strong>如果追求数据的均匀分布，还是使用轮询策略比较好</strong>。事实上，随机策略是老版本生产者使用的分区策略，在新版本中已经改为轮询了。</p>
<p><strong>按照 key 进行消息保存</strong></p>
<p>这个策略也叫做 <strong>key-ordering</strong> 策略，Kafka 中每条消息都会有自己的key，一旦消息被定义了 Key，那么你就可以保证同一个 Key 的所有消息都进入到相同的分区里面，由于每个分区下的消息处理都是有顺序的，故这个策略被称为按消息键保序策略，如下图所示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb068cdc3ca978~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<p>实现这个策略的 partition 方法同样简单，只需要下面两行代码即可：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制代码List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">return Math.abs(key.hashCode()) % partitions.size();</span><br></pre></td></tr></table></figure></div>

<p>上面这几种分区策略都是比较基础的策略，除此之外，你还可以自定义分区策略。</p>
<h3 id="生产者压缩机制"><a href="#生产者压缩机制" class="headerlink" title="生产者压缩机制"></a>生产者压缩机制</h3><p>压缩一词简单来讲就是一种互换思想，它是一种经典的用 CPU 时间去换磁盘空间或者 I&#x2F;O 传输量的思想，希望以较小的 CPU 开销带来更少的磁盘占用或更少的网络 I&#x2F;O 传输。如果你还不了解的话我希望你先读完这篇文章 <a class="link"   href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247484672&idx=1&sn=7de8762995227b21f35c6bbb47b22233&chksm=fc45f8f3cb3271e5deac7e08d5dcdbfb24e3d66a1ac431fd78252bb0e0cb3cd1c727f053211a&token=343157109&lang=zh_CN%23rd" >程序员需要了解的硬核知识之压缩算法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，然后你就明白压缩是怎么回事了。</p>
<h4 id="Kafka-压缩是什么"><a href="#Kafka-压缩是什么" class="headerlink" title="Kafka 压缩是什么"></a>Kafka 压缩是什么</h4><p>Kafka 的消息分为两层：消息集合 和 消息。一个消息集合中包含若干条日志项，而日志项才是真正封装消息的地方。Kafka 底层的消息日志由一系列消息集合日志项组成。Kafka 通常不会直接操作具体的一条条消息，它总是在消息集合这个层面上进行<code>写入</code>操作。</p>
<p>在 Kafka 中，压缩会发生在两个地方：Kafka Producer 和 Kafka Consumer，为什么启用压缩？说白了就是消息太大，需要<code>变小一点</code> 来使消息发的更快一些。</p>
<p>Kafka Producer 中使用 <code>compression.type</code> 来开启压缩</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制代码private Properties properties = new Properties();</span><br><span class="line">properties.put(&quot;bootstrap.servers&quot;,&quot;192.168.1.9:9092&quot;);</span><br><span class="line">properties.put(&quot;key.serializer&quot;,&quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">properties.put(&quot;value.serializer&quot;,&quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">properties.put(&quot;compression.type&quot;, &quot;gzip&quot;);</span><br><span class="line"></span><br><span class="line">Producer&lt;String,String&gt; producer = new KafkaProducer&lt;String, String&gt;(properties);</span><br><span class="line"></span><br><span class="line">ProducerRecord&lt;String,String&gt; record =</span><br><span class="line">  new ProducerRecord&lt;String, String&gt;(&quot;CustomerCountry&quot;,&quot;Precision Products&quot;,&quot;France&quot;);</span><br></pre></td></tr></table></figure></div>

<p>上面代码表明该 Producer 的压缩算法使用的是 GZIP</p>
<p><strong>有压缩必有解压缩</strong>，Producer 使用压缩算法压缩消息后并发送给服务器后，由 Consumer 消费者进行解压缩，因为采用的何种压缩算法是随着 key、value 一起发送过去的，所以消费者知道采用何种压缩算法。</p>
<h3 id="Kafka-重要参数配置"><a href="#Kafka-重要参数配置" class="headerlink" title="Kafka 重要参数配置"></a>Kafka 重要参数配置</h3><p>在上一篇文章 <a class="link"   href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247484570&idx=1&sn=1ad1c96bc7d47b88e976cbd045baf7d7&chksm=fc45f969cb32707f882c52d7434b2c0bf2ccbbc2cd854e1dc5c203deb8ae9c1831cf216e8bad&token=343157109&lang=zh_CN%23rd" >带你涨姿势的认识一下kafka <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中，我们主要介绍了一下 kafka 集群搭建的参数，本篇文章我们来介绍一下 Kafka 生产者重要的配置，生产者有很多可配置的参数，在文档里（<a class="link"   href="https://link.juejin.cn/?target=http://kafka.apache.org/documentation/%23producerconfigs%EF%BC%89%E9%83%BD%E6%9C%89%E8%AF%B4%E6%98%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E4%BB%8B%E7%BB%8D%E5%87%A0%E4%B8%AA%E5%9C%A8%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E3%80%81%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%96%B9%E9%9D%A2%E5%AF%B9%E7%94%9F%E4%BA%A7%E8%80%85%E5%BD%B1%E5%93%8D%E6%AF%94%E8%BE%83%E5%A4%A7%E7%9A%84%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8C%E8%AF%B4%E6%98%8E" >kafka.apache.org&#x2F;documentati… <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>key.serializer</strong></p>
<p>用于 key 键的序列化，它实现了 <code>org.apache.kafka.common.serialization.Serializer</code> 接口</p>
<p><strong>value.serializer</strong></p>
<p>用于 value 值的序列化，实现了 <code>org.apache.kafka.common.serialization.Serializer</code> 接口</p>
<p><strong>acks</strong></p>
<p>acks 参数指定了要有多少个分区副本接收消息，生产者才认为消息是写入成功的。此参数对消息丢失的影响较大</p>
<ul>
<li>如果 acks &#x3D; 0，就表示生产者也不知道自己产生的消息是否被服务器接收了，它才知道它写成功了。如果发送的途中产生了错误，生产者也不知道，它也比较懵逼，因为没有返回任何消息。这就类似于 UDP 的运输层协议，只管发，服务器接受不接受它也不关心。</li>
<li>如果 acks &#x3D; 1，只要集群的 Leader 接收到消息，就会给生产者返回一条消息，告诉它写入成功。如果发送途中造成了网络异常或者 Leader 还没选举出来等其他情况导致消息写入失败，生产者会受到错误消息，这时候生产者往往会再次重发数据。因为消息的发送也分为 <code>同步</code> 和 <code>异步</code>，Kafka 为了保证消息的高效传输会决定是同步发送还是异步发送。如果让客户端等待服务器的响应（通过调用 <code>Future</code> 中的 <code>get()</code> 方法），显然会增加延迟，如果客户端使用回调，就会解决这个问题。</li>
<li>如果 acks &#x3D; all，这种情况下是只有当所有参与复制的节点都收到消息时，生产者才会接收到一个来自服务器的消息。不过，它的延迟比 acks &#x3D;1 时更高，因为我们要等待不只一个服务器节点接收消息。</li>
</ul>
<p><strong>buffer.memory</strong></p>
<p>此参数用来设置生产者内存缓冲区的大小，生产者用它缓冲要发送到服务器的消息。如果应用程序发送消息的速度超过发送到服务器的速度，会导致生产者空间不足。这个时候，send() 方法调用要么被阻塞，要么抛出异常，具体取决于 <code>block.on.buffer.null</code> 参数的设置。</p>
<p><strong>compression.type</strong></p>
<p>此参数来表示生产者启用何种压缩算法，默认情况下，消息发送时不会被压缩。该参数可以设置为 snappy、gzip 和 lz4，它指定了消息发送给 broker 之前使用哪一种压缩算法进行压缩。下面是各压缩算法的对比</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb068cf4f6ba76~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb068d4a803cc4~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<p><strong>retries</strong></p>
<p>生产者从服务器收到的错误有可能是临时性的错误（比如分区找不到首领），在这种情况下，<code>reteis</code> 参数的值决定了生产者可以重发的消息次数，如果达到这个次数，生产者会放弃重试并返回错误。默认情况下，生产者在每次重试之间等待 100ms，这个等待参数可以通过 <code>retry.backoff.ms</code> 进行修改。</p>
<p><strong>batch.size</strong></p>
<p>当有多个消息需要被发送到同一个分区时，生产者会把它们放在同一个批次里。该参数指定了一个批次可以使用的内存大小，按照字节数计算。当批次被填满，批次里的所有消息会被发送出去。不过生产者井不一定都会等到批次被填满才发送，任意条数的消息都可能被发送。</p>
<p><strong>client.id</strong></p>
<p>此参数可以是任意的字符串，服务器会用它来识别消息的来源，一般配置在日志里</p>
<p><strong>max.in.flight.requests.per.connection</strong></p>
<p>此参数指定了生产者在收到服务器响应之前可以发送多少消息，它的值越高，就会占用越多的内存，不过也会提高吞吐量。把它设为1 可以保证消息是按照发送的顺序写入服务器。</p>
<p><strong>timeout.ms、request.timeout.ms 和 metadata.fetch.timeout.ms</strong></p>
<p>request.timeout.ms 指定了生产者在发送数据时等待服务器返回的响应时间，metadata.fetch.timeout.ms 指定了生产者在获取元数据（比如目标分区的首领是谁）时等待服务器返回响应的时间。如果等待时间超时，生产者要么重试发送数据，要么返回一个错误。timeout.ms 指定了 broker 等待同步副本返回消息确认的时间，与 asks 的配置相匹配—-如果在指定时间内没有收到同步副本的确认，那么 broker 就会返回一个错误。</p>
<p><strong>max.block.ms</strong></p>
<p>此参数指定了在调用 send() 方法或使用 partitionFor() 方法获取元数据时生产者的阻塞时间当生产者的发送缓冲区已捕，或者没有可用的元数据时，这些方法就会阻塞。在阻塞时间达到 max.block.ms 时，生产者会抛出超时异常。</p>
<p><strong>max.request.size</strong></p>
<p>该参数用于控制生产者发送的请求大小。它可以指能发送的单个消息的最大值，也可以指单个请求里所有消息的总大小。</p>
<p><strong>receive.buffer.bytes 和 send.buffer.bytes</strong></p>
<p>Kafka 是基于 TCP 实现的，为了保证可靠的消息传输，这两个参数分别指定了 TCP Socket 接收和发送数据包的缓冲区的大小。如果它们被设置为 -1，就使用操作系统的默认值。如果生产者或消费者与 broker 处于不同的数据中心，那么可以适当增大这些值。</p>
<h2 id="Kafka-Consumer"><a href="#Kafka-Consumer" class="headerlink" title="Kafka Consumer"></a>Kafka Consumer</h2><p>应用程序使用 <code>KafkaConsumer</code> 从 Kafka 中订阅主题并接收来自这些主题的消息，然后再把他们保存起来。应用程序首先需要创建一个 KafkaConsumer 对象，订阅主题并开始接受消息，验证消息并保存结果。一段时间后，生产者往主题写入的速度超过了应用程序验证数据的速度，这时候该如何处理？如果只使用单个消费者的话，应用程序会跟不上消息生成的速度，就像多个生产者像相同的主题写入消息一样，这时候就需要多个消费者共同参与消费主题中的消息，对消息进行分流处理。</p>
<p>Kafka 消费者从属于<code>消费者群组</code>。一个群组中的消费者订阅的都是<code>相同</code>的主题，每个消费者接收主题一部分分区的消息。下面是一个 Kafka 分区消费示意图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb068eb30222dc~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<p>上图中的主题 T1 有四个分区，分别是分区0、分区1、分区2、分区3，我们创建一个消费者群组1，消费者群组中只有一个消费者，它订阅主题T1，接收到 T1 中的全部消息。由于一个消费者处理四个生产者发送到分区的消息，压力有些大，需要帮手来帮忙分担任务，于是就演变为下图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb068f1af13377~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<p>这样一来，消费者的消费能力就大大提高了，但是在某些环境下比如用户产生消息特别多的时候，生产者产生的消息仍旧让消费者吃不消，那就继续增加消费者。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb069033019b60~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<p>如上图所示，每个分区所产生的消息能够被每个消费者群组中的消费者消费，如果向消费者群组中增加更多的消费者，那么多余的消费者将会闲置，如下图所示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb068f986c4185~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<p>向群组中增加消费者是横向伸缩消费能力的主要方式。总而言之，我们可以通过增加消费组的消费者来进行<code>水平扩展提升消费能力</code>。这也是为什么建议创建主题时使用比较多的分区数，这样可以在消费负载高的情况下增加消费者来提升性能。另外，消费者的数量不应该比分区数多，因为多出来的消费者是空闲的，没有任何帮助。</p>
<p>Kafka 一个很重要的特性就是，只需写入一次消息，可以支持任意多的应用读取这个消息。换句话说，每个应用都可以读到全量的消息。为了使得每个应用都能读到全量消息，应用需要有不同的消费组。对于上面的例子，假如我们新增了一个新的消费组 G2，而这个消费组有两个消费者，那么就演变为下图这样</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb0690843c4d19~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<p>在这个场景中，消费组 G1 和消费组 G2 都能收到 T1 主题的全量消息，在逻辑意义上来说它们属于不同的应用。</p>
<p><strong>总结起来就是如果应用需要读取全量消息，那么请为该应用设置一个消费组；如果该应用消费能力不足，那么可以考虑在这个消费组里增加消费者</strong>。</p>
<h3 id="消费者组和分区重平衡"><a href="#消费者组和分区重平衡" class="headerlink" title="消费者组和分区重平衡"></a>消费者组和分区重平衡</h3><h4 id="消费者组是什么"><a href="#消费者组是什么" class="headerlink" title="消费者组是什么"></a>消费者组是什么</h4><p><code>消费者组（Consumer Group）</code>是由一个或多个消费者实例（Consumer Instance）组成的群组，具有可扩展性和可容错性的一种机制。消费者组内的消费者<code>共享</code>一个消费者组ID，这个ID 也叫做 <code>Group ID</code>，组内的消费者共同对一个主题进行订阅和消费，同一个组中的消费者只能消费一个分区的消息，多余的消费者会闲置，派不上用场。</p>
<p>我们在上面提到了两种消费方式</p>
<ul>
<li>一个消费者群组消费一个主题中的消息，这种消费模式又称为<code>点对点</code>的消费方式，点对点的消费方式又被称为消息队列</li>
<li>一个主题中的消息被多个消费者群组共同消费，这种消费模式又称为<code>发布-订阅</code>模式</li>
</ul>
<h4 id="消费者重平衡"><a href="#消费者重平衡" class="headerlink" title="消费者重平衡"></a>消费者重平衡</h4><p>我们从上面的<code>消费者演变图</code>中可以知道这么一个过程：最初是一个消费者订阅一个主题并消费其全部分区的消息，后来有一个消费者加入群组，随后又有更多的消费者加入群组，而新加入的消费者实例<code>分摊</code>了最初消费者的部分消息，这种把分区的所有权通过一个消费者转到其他消费者的行为称为<code>重平衡</code>，英文名也叫做 <code>Rebalance</code> 。如下图所示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb06909972f3f2~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<p>重平衡非常重要，它为消费者群组带来了<code>高可用性</code> 和 <code>伸缩性</code>，我们可以放心的添加消费者或移除消费者，不过在正常情况下我们并不希望发生这样的行为。在重平衡期间，消费者无法读取消息，造成整个消费者组在重平衡的期间都不可用。另外，当分区被重新分配给另一个消费者时，消息当前的读取状态会丢失，它有可能还需要去刷新缓存，在它重新恢复状态之前会拖慢应用程序。</p>
<p>消费者通过向<code>组织协调者</code>（Kafka Broker）发送心跳来维护自己是消费者组的一员并确认其拥有的分区。对于不同不的消费群体来说，其组织协调者可以是不同的。只要消费者定期发送心跳，就会认为消费者是存活的并处理其分区中的消息。当消费者检索记录或者提交它所消费的记录时就会发送心跳。</p>
<p>如果过了一段时间 Kafka 停止发送心跳了，会话（Session）就会过期，组织协调者就会认为这个 Consumer 已经死亡，就会触发一次重平衡。如果消费者宕机并且停止发送消息，组织协调者会等待几秒钟，确认它死亡了才会触发重平衡。在这段时间里，<strong>死亡的消费者将不处理任何消息</strong>。在清理消费者时，消费者将通知协调者它要离开群组，组织协调者会触发一次重平衡，尽量降低处理停顿。</p>
<p>重平衡是一把双刃剑，它为消费者群组带来高可用性和伸缩性的同时，还有有一些明显的缺点(bug)，而这些 bug 到现在社区还无法修改。</p>
<p>重平衡的过程对消费者组有极大的影响。因为每次重平衡过程中都会导致万物静止，参考 JVM 中的垃圾回收机制，也就是 Stop The World ，STW，(引用自《深入理解 Java 虚拟机》中 p76 关于 Serial 收集器的描述)：</p>
<blockquote>
<p>更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程。直到它收集结束。<code>Stop The World</code> 这个名字听起来很帅，但这项工作实际上是由虚拟机在后台自动发起并完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。</p>
</blockquote>
<p>也就是说，在重平衡期间，消费者组中的消费者实例都会停止消费，等待重平衡的完成。而且重平衡这个过程很慢……</p>
<h3 id="创建消费者"><a href="#创建消费者" class="headerlink" title="创建消费者"></a>创建消费者</h3><p>上面的理论说的有点多，下面就通过代码来讲解一下消费者是如何消费的</p>
<p>在读取消息之前，需要先创建一个 <code>KafkaConsumer</code> 对象。创建 KafkaConsumer 对象与创建 KafkaProducer 对象十分相似 — 把需要传递给消费者的属性放在 <code>properties</code> 对象中，后面我们会着重讨论 Kafka 的一些配置，这里我们先简单的创建一下，使用3个属性就足矣，分别是 <code>bootstrap.server</code>，<code>key.deserializer</code>，<code>value.deserializer</code> 。</p>
<p>这三个属性我们已经用过很多次了，如果你还不是很清楚的话，可以参考 <a class="link"   href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s/Br0_DQ854n-Is0W88DbPOg" >带你涨姿势是认识一下Kafka Producer <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>还有一个属性是 <code>group.id</code> 这个属性不是必须的，它指定了 KafkaConsumer 是属于哪个消费者群组。创建不属于任何一个群组的消费者也是可以的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制代码Properties properties = new Properties();</span><br><span class="line">        properties.put(&quot;bootstrap.server&quot;,&quot;192.168.1.9:9092&quot;);     properties.put(&quot;key.serializer&quot;,&quot;org.apache.kafka.common.serialization.StringSerializer&quot;);   properties.put(&quot;value.serializer&quot;,&quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">KafkaConsumer&lt;String,String&gt; consumer = new KafkaConsumer&lt;&gt;(properties);</span><br></pre></td></tr></table></figure></div>

<h4 id="主题订阅"><a href="#主题订阅" class="headerlink" title="主题订阅"></a>主题订阅</h4><p>创建好消费者之后，下一步就开始订阅主题了。<code>subscribe()</code> 方法接受一个主题列表作为参数，使用起来比较简单</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制代码consumer.subscribe(Collections.singletonList(&quot;customerTopic&quot;));</span><br></pre></td></tr></table></figure></div>

<p>为了简单我们只订阅了一个主题 <code>customerTopic</code>，参数传入的是一个正则表达式，正则表达式可以匹配多个主题，如果有人创建了新的主题，并且主题的名字与正则表达式相匹配，那么会立即触发一次重平衡，消费者就可以读取新的主题。</p>
<p>要订阅所有与 test 相关的主题，可以这样做</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制代码consumer.subscribe(&quot;test.*&quot;);</span><br></pre></td></tr></table></figure></div>

<h4 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h4><p>我们知道，Kafka 是支持订阅&#x2F;发布模式的，生产者发送数据给 Kafka Broker，那么消费者是如何知道生产者发送了数据呢？其实生产者产生的数据消费者是不知道的，KafkaConsumer 采用轮询的方式定期去 Kafka Broker 中进行数据的检索，如果有数据就用来消费，如果没有就再继续轮询等待，下面是轮询等待的具体实现</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制代码try &#123;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(100));</span><br><span class="line">    for (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">      int updateCount = 1;</span><br><span class="line">      if (map.containsKey(record.value())) &#123;</span><br><span class="line">        updateCount = (int) map.get(record.value() + 1);</span><br><span class="line">      &#125;</span><br><span class="line">      map.put(record.value(), updateCount);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">  consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>这是一个无限循环。消费者实际上是一个长期运行的应用程序，它通过轮询的方式向 Kafka 请求数据。</li>
<li>第三行代码非常重要，Kafka 必须定期循环请求数据，否则就会认为该 Consumer 已经挂了，会触发重平衡，它的分区会移交给群组中的其它消费者。传给 <code>poll()</code> 方法的是一个超市时间，用 <code>java.time.Duration</code> 类来表示，如果该参数被设置为 0 ，poll() 方法会立刻返回，否则就会在指定的毫秒数内一直等待 broker 返回数据。</li>
<li>poll() 方法会返回一个记录列表。每条记录都包含了记录所属主题的信息，记录所在分区的信息、记录在分区中的偏移量，以及记录的键值对。我们一般会遍历这个列表，逐条处理每条记录。</li>
<li>在退出应用程序之前使用 <code>close()</code> 方法关闭消费者。网络连接和 socket 也会随之关闭，并立即触发一次重平衡，而不是等待群组协调器发现它不再发送心跳并认定它已经死亡。</li>
</ul>
<blockquote>
<p><strong>线程安全性</strong></p>
<p>在同一个群组中，我们无法让一个线程运行多个消费者，也无法让多个线程安全的共享一个消费者。按照规则，一个消费者使用一个线程，如果一个消费者群组中多个消费者都想要运行的话，那么必须让每个消费者在自己的线程中运行，可以使用 Java 中的 <code>ExecutorService</code> 启动多个消费者进行进行处理。</p>
</blockquote>
<h3 id="消费者配置"><a href="#消费者配置" class="headerlink" title="消费者配置"></a>消费者配置</h3><p>到目前为止，我们学习了如何使用消费者 API，不过只介绍了几个最基本的属性，Kafka 文档列出了所有与消费者相关的配置说明。大部分参数都有合理的默认值，一般不需要修改它们，下面我们就来介绍一下这些参数。</p>
<ul>
<li>fetch.min.bytes</li>
</ul>
<p>该属性指定了消费者从服务器获取记录的最小字节数。broker 在收到消费者的数据请求时，如果可用的数据量小于 <code>fetch.min.bytes</code> 指定的大小，那么它会等到有足够的可用数据时才把它返回给消费者。这样可以降低消费者和 broker 的工作负载，因为它们在主题使用频率不是很高的时候就不用来回处理消息。如果没有很多可用数据，但消费者的 CPU 使用率很高，那么就需要把该属性的值设得比默认值大。如果消费者的数量比较多，把该属性的值调大可以降低 broker 的工作负载。</p>
<ul>
<li>fetch.max.wait.ms</li>
</ul>
<p>我们通过上面的 <strong>fetch.min.bytes</strong> 告诉 Kafka，等到有足够的数据时才会把它返回给消费者。而 <strong>fetch.max.wait.ms</strong> 则用于指定 broker 的等待时间，默认是 500 毫秒。如果没有足够的数据流入 kafka 的话，消费者获取的最小数据量要求就得不到满足，最终导致 500 毫秒的延迟。如果要降低潜在的延迟，就可以把参数值设置的小一些。如果 fetch.max.wait.ms 被设置为 100 毫秒的延迟，而 fetch.min.bytes 的值设置为 1MB，那么 Kafka 在收到消费者请求后，要么返回 1MB 的数据，要么在 100 ms 后返回所有可用的数据。就看哪个条件首先被满足。</p>
<ul>
<li>max.partition.fetch.bytes</li>
</ul>
<p>该属性指定了服务器从每个分区里返回给消费者的<code>最大字节数</code>。它的默认值时 1MB，也就是说，<code>KafkaConsumer.poll()</code> 方法从每个分区里返回的记录最多不超过 max.partition.fetch.bytes 指定的字节。如果一个主题有20个分区和5个消费者，那么每个消费者需要<code>至少</code>4 MB的可用内存来接收记录。在为消费者分配内存时，可以给它们多分配一些，因为如果群组里有消费者发生崩溃，剩下的消费者需要处理更多的分区。max.partition.fetch.bytes 的值必须比 broker 能够接收的最大消息的字节数(通过 max.message.size 属性配置大)，<strong>否则消费者可能无法读取这些消息，导致消费者一直挂起重试</strong>。 在设置该属性时，另外一个考量的因素是消费者处理数据的时间。消费者需要频繁的调用 poll() 方法来避免会话过期和发生分区再平衡，如果单次调用poll() 返回的数据太多，消费者需要更多的时间进行处理，可能无法及时进行下一个轮询来避免会话过期。如果出现这种情况，可以把 max.partition.fetch.bytes 值改小，或者延长会话过期时间。</p>
<ul>
<li>session.timeout.ms</li>
</ul>
<p>这个属性指定了消费者在被认为死亡之前可以与服务器断开连接的时间，默认是 3s。如果消费者没有在 <strong>session.timeout.ms</strong> 指定的时间内发送心跳给群组协调器，就会被认定为死亡，协调器就会触发重平衡。把它的分区分配给消费者群组中的其它消费者，此属性与 <code>heartbeat.interval.ms</code> 紧密相关。heartbeat.interval.ms 指定了 poll() 方法向群组协调器发送心跳的频率，session.timeout.ms 则指定了消费者可以多久不发送心跳。所以，这两个属性一般需要同时修改，heartbeat.interval.ms 必须比 session.timeout.ms 小，一般是 session.timeout.ms 的三分之一。如果 session.timeout.ms 是 3s，那么 heartbeat.interval.ms 应该是 1s。把 session.timeout.ms 值设置的比默认值小，可以更快地检测和恢复崩愤的节点，不过长时间的轮询或垃圾收集可能导致非预期的重平衡。把该属性的值设置得大一些，可以减少意外的重平衡，不过检测节点崩溃需要更长的时间。</p>
<ul>
<li>auto.offset.reset</li>
</ul>
<p>该属性指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下的该如何处理。它的默认值是 <code>latest</code>，意思指的是，在偏移量无效的情况下，消费者将从最新的记录开始读取数据。另一个值是 <code>earliest</code>，意思指的是在偏移量无效的情况下，消费者将从起始位置处开始读取分区的记录。</p>
<ul>
<li>enable.auto.commit</li>
</ul>
<p>我们稍后将介绍几种不同的提交偏移量的方式。该属性指定了消费者是否自动提交偏移量，默认值是 true，为了尽量避免出现重复数据和数据丢失，可以把它设置为 false，由自己控制何时提交偏移量。如果把它设置为 true，还可以通过 <strong>auto.commit.interval.ms</strong> 属性来控制提交的频率</p>
<ul>
<li>partition.assignment.strategy</li>
</ul>
<p>我们知道，分区会分配给群组中的消费者。<code>PartitionAssignor</code> 会根据给定的消费者和主题，决定哪些分区应该被分配给哪个消费者，Kafka 有两个默认的分配策略<code>Range</code> 和 <code>RoundRobin</code></p>
<ul>
<li>client.id</li>
</ul>
<p>该属性可以是任意字符串，broker 用他来标识从客户端发送过来的消息，通常被用在日志、度量指标和配额中</p>
<ul>
<li>max.poll.records</li>
</ul>
<p>该属性用于控制单次调用 call() 方法能够返回的记录数量，可以帮你控制在轮询中需要处理的数据量。</p>
<ul>
<li>receive.buffer.bytes 和 send.buffer.bytes</li>
</ul>
<p>socket 在读写数据时用到的 TCP 缓冲区也可以设置大小。如果它们被设置为 -1，就使用操作系统默认值。如果生产者或消费者与 broker 处于不同的数据中心内，可以适当增大这些值，因为跨数据中心的网络一般都有比较高的延迟和比较低的带宽。</p>
<h3 id="提交和偏移量的概念"><a href="#提交和偏移量的概念" class="headerlink" title="提交和偏移量的概念"></a>提交和偏移量的概念</h3><h4 id="特殊偏移"><a href="#特殊偏移" class="headerlink" title="特殊偏移"></a>特殊偏移</h4><p>我们上面提到，消费者在每次调用<code>poll()</code> 方法进行定时轮询的时候，会返回由生产者写入 Kafka 但是还没有被消费者消费的记录，因此我们可以追踪到哪些记录是被群组里的哪个消费者读取的。消费者可以使用 Kafka 来追踪消息在分区中的位置（偏移量）</p>
<p>消费者会向一个叫做 <code>_consumer_offset</code> 的特殊主题中发送消息，这个主题会保存每次所发送消息中的分区偏移量，这个主题的主要作用就是消费者触发重平衡后记录偏移使用的，消费者每次向这个主题发送消息，正常情况下不触发重平衡，这个主题是不起作用的，当触发重平衡后，消费者停止工作，每个消费者可能会分到对应的分区，这个主题就是让消费者能够继续处理消息所设置的。</p>
<p>如果提交的偏移量小于客户端最后一次处理的偏移量，那么位于两个偏移量之间的消息就会被重复处理</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb0690b6721d0d~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<p>如果提交的偏移量大于最后一次消费时的偏移量，那么处于两个偏移量中间的消息将会丢失</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/28/16eb0691023e677e~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"
                      alt="img"
                ></p>
<p>既然<code>_consumer_offset</code> 如此重要，那么它的提交方式是怎样的呢？下面我们就来说一下####提交方式</p>
<p>KafkaConsumer API 提供了多种方式来提交偏移量</p>
<h4 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h4><p>最简单的方式就是让消费者自动提交偏移量。如果 <code>enable.auto.commit</code> 被设置为true，那么每过 5s，消费者会自动把从 poll() 方法轮询到的最大偏移量提交上去。提交时间间隔由 <code>auto.commit.interval.ms</code> 控制，默认是 5s。与消费者里的其他东西一样，自动提交也是在轮询中进行的。消费者在每次轮询中会检查是否提交该偏移量了，如果是，那么就会提交从上一次轮询中返回的偏移量。</p>
<h4 id="提交当前偏移量"><a href="#提交当前偏移量" class="headerlink" title="提交当前偏移量"></a>提交当前偏移量</h4><p>把 <code>auto.commit.offset</code> 设置为 false，可以让应用程序决定何时提交偏移量。使用 <code>commitSync()</code> 提交偏移量。这个 API 会提交由 poll() 方法返回的最新偏移量，提交成功后马上返回，如果提交失败就抛出异常。</p>
<p>commitSync() 将会提交由 poll() 返回的最新偏移量，如果处理完所有记录后要确保调用了 commitSync()，否则还是会有丢失消息的风险，如果发生了在均衡，从最近一批消息到发生在均衡之间的所有消息都将被重复处理。</p>
<h4 id="异步提交"><a href="#异步提交" class="headerlink" title="异步提交"></a>异步提交</h4><p>异步提交 <code>commitAsync()</code> 与同步提交 <code>commitSync()</code> 最大的区别在于异步提交不会进行重试，同步提交会一致进行重试。</p>
<h4 id="同步和异步组合提交"><a href="#同步和异步组合提交" class="headerlink" title="同步和异步组合提交"></a>同步和异步组合提交</h4><p>一般情况下，针对偶尔出现的提交失败，不进行重试不会有太大的问题，因为如果提交失败是因为临时问题导致的，那么后续的提交总会有成功的。但是如果在关闭消费者或再均衡前的最后一次提交，就要确保提交成功。</p>
<p>因此，<strong>在消费者关闭之前一般会组合使用commitAsync和commitSync提交偏移量</strong>。</p>
<h4 id="提交特定的偏移量"><a href="#提交特定的偏移量" class="headerlink" title="提交特定的偏移量"></a>提交特定的偏移量</h4><p>消费者API允许调用 commitSync() 和 commitAsync() 方法时传入希望提交的 partition 和 offset 的 map，即提交特定的偏移量。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据技术</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>天梯赛总结</title>
    <url>/2024/04/20/%E5%A4%A9%E6%A2%AF%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ul>
<li>刚打完天梯赛，先来安慰一下自己，结果不重要，享受过程即可</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">总结一下：</span><br><span class="line">	①基础不够牢靠，一百分的基础题，扣了13分，语文还需要加强理解</span><br><span class="line">	②心态不够好，比赛期间走神了，同时虽然外部环境干扰很多，但自己的心态还需要练</span><br><span class="line">	③进阶题目写的不足，一道鸭蛋，导致肯定与国三无缘了</span><br><span class="line">唉，唉</span><br><span class="line">距离国三还有20分的差距，同时写题还是太慢</span><br><span class="line">加油吧，加油吧</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>杂文</tag>
        <tag>比赛</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2022/04/01/%E6%88%91%E7%9A%84%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="冬日随笔"><a href="#冬日随笔" class="headerlink" title="冬日随笔"></a>冬日随笔</h3><h4 id="小年"><a href="#小年" class="headerlink" title="小年"></a>小年</h4><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">只觉的年纪渐渐变大，一路走来，丢掉了许多东西，也放弃了很多儿时心血来潮的<span class="string">&#x27;梦想&#x27;</span>，其中一个就是成为作家；犹记得高中迷上了各种各样的小说，有雨果的，有村上春树的，还有东野圭吾的，当然也少不了鲁迅先生的，对于鲁迅先生尤其想多说两句，不仅仅是先生的文笔犀利的原因，也不仅仅是先生写小说写的有<span class="string">&#x27;趣&#x27;</span>的原因，最让我在对先生印象深刻的主要原因就是，读不懂先生写的文章，短篇小说还好，但是每次读起先生的散文时，着实令我头疼，甚至于连这篇散文的题目有几层涵义都难以明白，加之从小学便经常听起先生的大名，所以，对鲁迅先生尤其印象深刻。近日也是闲来无事，天气寒冷也懒得外出，便在家突然想写些什么，思来想去，便写下这些文字，也就算是对我已经放弃的梦想的缅怀吧。</span><br><span class="line">已然不记得，自己初中还是高中写的一篇作文，算是抒情，也算是描景，也可能是四不像。其中写道：我最喜欢四季中的冬季，冰天雪地、银装素裹的冬季。想起今年的冬季，自己还一场雪也没遇到呢，但可能是要马上过年，老天爷便实现了我的心愿，看一场雪。没错，今日小年，早醒之后，穿衣，拉开窗帘，忽然被眼前的冰天雪地、银装素裹的冬季所愣到了，然后惊喜，便不顾寒冷，打开窗，抓了一小撮窗沿上的雪，凉凉的，又赶紧用手搓了搓雪，还是那个沙沙的感觉。心中就感叹到雪没变！望向远处，村庄的高楼也好，瓦舍也罢，都被这忽然而来的雪所点缀，所覆盖，只剩下几棵光秃秃的树，没被这白雪所包裹，不过，倒也是别有一番风味。</span><br><span class="line">今日小年，吃了母亲包的饺子，东嘴八舌也吃了很多称自己心意的年货，（东嘴八舌哈哈哈，自己造的成语，就想形容自己吃了好多种）饭后心情格外愉悦，便想出门观雪，观景，想起友人，家旁边便有自己很多发小，但自己想了一下，还是决定独自去看，一来天气寒冷，马上新年，得疾却是不好;二来考虑自己，独行和同行，观雪心境总是不同。换衣，戴帽，开门，迈腿，收腿，关门，抬头一看，我的心愿仍然在下，不过小了很多，不影响出门，便在小年这天出门观雪。步行走了几十丈，竟有些喘气......</span><br></pre></td></tr></table></figure></div>

<h4 id="回忆吧，回忆吧"><a href="#回忆吧，回忆吧" class="headerlink" title="回忆吧，回忆吧"></a>回忆吧，回忆吧</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.......	</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-130d33539f8282b444835674b590b482_720w.webp"
                     
                ></p>
<h4 id="有感"><a href="#有感" class="headerlink" title="有感"></a>有感</h4><p>今天读到一段话，感觉挺有趣，便记录下来，仔细研学</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">全文如下:</span><br><span class="line">	当一个风姿绰约的女人走在街上，和她擦肩而过你会想到什么？有人想到她是一个天使，有人想到她是一个荡妇，有人会看到诱惑，有人会看到鄙夷，有人会自卑，有人会欣赏……</span><br><span class="line">女人本身没有任何变化，但不同的人却看出了截然不同的感受，没有一个人了解真实完整的她，所有人只看到了自己对她的想法、期待和判断。</span><br><span class="line">从心理学上来讲，这叫投射。</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line">	罗永浩有一段话，话糙理不糙：“妓女的眼中，这个世界上没有女人是不卖的，她们听到一个女人不卖的传闻，能理解的上限就是，是不是价格谈不拢？”</span><br><span class="line">	你怎么评价一个人，反应的其实是你自己的内心，是你对这个世界的理解和预期。你心里有什么，就会看到什么。三毛说：“你对我的百般注解，并不构成万分之一的我，却是一览无余的你。”</span><br><span class="line">很多时候，我们从未看到事物真实的本质，我们看到的只是自己的信念系统，自己对事物所贴上的标签和解释。你信念中所信奉的一切，会像手电筒一样打在别人身上。</span><br><span class="line"></span><br><span class="line">你眼中的你不是真的你，</span><br><span class="line">别人眼中的你也不是真的你，</span><br><span class="line">你眼中的别人才是真的你。</span><br><span class="line"></span><br><span class="line">	人自己看自己都是主观的，别人看你的时候是他内心的投射，而你眼中的别人才是你内心投影出来的镜子，是你的人格阴影。</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line">	怎么了解一个女人选择男人的标准？和她去看爱情电影，然后问她对男主人公的评价，她对男主人公的评价就是她对男人的评价标准。</span><br><span class="line">	借助对第三方的评价，了解一个人真实的内心世界。</span><br><span class="line">	老练的面试官会营造轻松的气氛，然后东拉西扯地闲聊，不经意间，问问你对某个人、某件事的看法，这个时候，你的防御系统松懈，回答的真实性会大大提升。用查户口的方式问，谁会真心话大冒险？</span><br><span class="line">	如果你一上班，看谁都不顺眼，张三脑袋进水了，李四脑袋被门夹了，王二麻子脑袋被驴踢了……真正的问题可能是：你的上头，投射到了别人身上。</span><br><span class="line">	你讨厌一个同事，就会给他贴上恶人的标签，面对他时，你自然特别容易动气，这其实是你刻意制造或放大了冲突。人生中<span class="number">99</span>%的烦恼都来源于人际关系，处理人际关系真正的起点，不是人和人的关系，是你自己和自己的关系。</span><br><span class="line">	网络上那么多莫名其妙的恶意攻击，其本质是当事人的生活过得不如意，混得越差，脾气越大。</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line">	心理学家波尔斯曾说：“我们以为，我们活在一个四周都是玻璃的房子，我们看到的都是全世界，其实，我们活在一个四周都是镜子的房子，我们所看到的都是自己。”</span><br><span class="line">	明白了这个投射机制之后，你就知道了，你所遇到的所有人都是你自己，这个世界的主角从来都只有你自己。只有理解自己才是一切问题的根源，你才能找到解决问题的根本方法。</span><br><span class="line">	人痛苦的根源是，总在用自己的标准去要求别人。</span><br><span class="line">	他怎么不按我说的去做？王五太蠢了！赵六不讲究！当你总在用自己的标准去要求别人时，你会发现，你就是和别人相处不来。你要改变别人，只有一个办法就是改变自己，只有你自己变得没那么多标准，没那么多框架和要求，你和任何人相处都是可以的。</span><br><span class="line">	如果你有感情方面的烦恼，送你一句话：你怎么爱自己，就是在教别人怎么爱你。你细品，这是解决感情问题的关键，别再当演唱会上的沸羊羊了。</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line">	人生的道理浓缩一下就两个字：内观。所有的圣贤书讲的都是这个道理，我是一切的根源，我的思维导致了我的选择，我的选择决定了今天的因果。</span><br><span class="line"> </span><br><span class="line">	《心经》开篇第一句就是：“观自在菩萨”；《六祖坛经》的精髓是：“心平何须持戒，身正何须坐禅”；《金刚经》的要义是：“应无所住，而生其心”；禅宗说：“明心见性，见性成佛”；王阳明龙场悟道，悟出了八个字：“吾性自足，不假外求”……</span><br><span class="line"></span><br><span class="line">	人生最大的敌人就是自己，只有把自己看清楚，才能把世界看清楚。把一切外部的事物都当自己的镜子，时刻照见自己的内心，破除执念和障碍，你才能成为更好的自己。</span><br><span class="line"></span><br><span class="line">万千法门，修心为上。</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">个人所悟、皆为所得、吾思之，想之，爱之。</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>杂文</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>杂文</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>再学HiveSQL-详解版笔记</title>
    <url>/2024/06/06/%E5%86%8D%E5%AD%A6HiveSQL-%E8%AF%A6%E8%A7%A3%E7%89%88%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Hive-Sql-大全"><a href="#Hive-Sql-大全" class="headerlink" title="Hive Sql 大全"></a>Hive Sql 大全</h1><blockquote>
<p>本文基本涵盖了Hive日常使用的所有SQL，因为SQL太多，所以将SQL进行了如下分类： 一、DDL语句（数据定义语句）：<br> 对数据库的操作：包含创建、修改数据库<br> 对数据表的操作：分为内部表及外部表，分区表和分桶表<br> 二、DQL语句（数据查询语句）：<br> 单表查询、关联查询<br> hive函数：包含聚合函数，条件函数，日期函数，字符串函数等<br> 行转列及列转行：lateral view 与 explode 以及 reflect<br> 窗口函数与分析函数<br> 其他一些窗口函数</p>
</blockquote>
<h2 id="hive的DDL语法"><a href="#hive的DDL语法" class="headerlink" title="hive的DDL语法"></a>hive的DDL语法</h2><h3 id="对数据库的操作"><a href="#对数据库的操作" class="headerlink" title="对数据库的操作"></a>对数据库的操作</h3><ul>
<li>创建数据库:</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> myhive;</span><br><span class="line"># 说明：hive的表存放位置模式是由hive<span class="operator">-</span>site.xml当中的一个属性指定的</span><br><span class="line"># hive.metastore.warehouse.dir</span><br><span class="line"></span><br><span class="line"># 创建数据库并指定hdfs存储位置:</span><br><span class="line"><span class="keyword">create</span> database myhive2 location <span class="string">&#x27;/myhive2&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>修改数据库:</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span>  database  myhive2  <span class="keyword">set</span>  dbproperties(<span class="string">&#x27;createtime&#x27;</span><span class="operator">=</span><span class="string">&#x27;20210329&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>说明：可以使用alter  database 命令来修改数据库的一些属性。但是数据库的元数据信息是不可更改的，包括数据库的名称以及数据库所在的位置</p>
</blockquote>
<ul>
<li>查看数据库详细信息</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">#查看数据库基本信息</span><br><span class="line">hive (myhive)<span class="operator">&gt;</span> <span class="keyword">desc</span>  database  myhive2;</span><br><span class="line"></span><br><span class="line"># 查看数据库更多详细信息</span><br><span class="line">hive (myhive)<span class="operator">&gt;</span> <span class="keyword">desc</span> database extended  myhive2;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>删除数据库</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 删除一个空数据库，如果数据库下面有数据表，那么就会报错</span><br><span class="line"><span class="keyword">drop</span>  database  myhive2;</span><br><span class="line"></span><br><span class="line"># 强制删除数据库，包含数据库下面的表一起删除</span><br><span class="line"><span class="keyword">drop</span>  database  myhive  cascade; </span><br></pre></td></tr></table></figure></div>

<h3 id="对数据表的操作"><a href="#对数据表的操作" class="headerlink" title="对数据表的操作"></a>对数据表的操作</h3><h4 id="对管理表-内部表-的操作"><a href="#对管理表-内部表-的操作" class="headerlink" title="对管理表(内部表)的操作:"></a>对管理表(内部表)的操作:</h4><ul>
<li>建内部表:</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">hive (myhive)<span class="operator">&gt;</span> use myhive; <span class="comment">-- 使用myhive数据库</span></span><br><span class="line">hive (myhive)<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> stu(id <span class="type">int</span>,name string);</span><br><span class="line">hive (myhive)<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> stu <span class="keyword">values</span> (<span class="number">1</span>,&quot;zhangsan&quot;);</span><br><span class="line"> <span class="comment">-- 一次插入多条数据</span></span><br><span class="line">hive (myhive)<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> stu <span class="keyword">values</span> (<span class="number">1</span>,&quot;zhangsan&quot;),(<span class="number">2</span>,&quot;lisi&quot;); </span><br><span class="line">hive (myhive)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>hive建表时候的字段类型:</li>
</ul>
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>类型</strong></th>
<th><strong>描述</strong></th>
<th><strong>字面量示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>原始类型</td>
<td>BOOLEAN</td>
<td>true&#x2F;false</td>
<td>TRUE</td>
</tr>
<tr>
<td></td>
<td>TINYINT</td>
<td>1字节的有符号整数 -128~127</td>
<td>1Y</td>
</tr>
<tr>
<td></td>
<td>SMALLINT</td>
<td>2个字节的有符号整数，-32768~32767</td>
<td>1S</td>
</tr>
<tr>
<td></td>
<td><strong>INT</strong></td>
<td>4个字节的带符号整数</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>BIGINT</td>
<td>8字节带符号整数</td>
<td>1L</td>
</tr>
<tr>
<td></td>
<td>FLOAT</td>
<td>4字节单精度浮点数1.0</td>
<td></td>
</tr>
<tr>
<td></td>
<td>DOUBLE</td>
<td>8字节双精度浮点数</td>
<td>1.0</td>
</tr>
<tr>
<td></td>
<td>DEICIMAL</td>
<td>任意精度的带符号小数</td>
<td>1.0</td>
</tr>
<tr>
<td></td>
<td><strong>STRING</strong></td>
<td>字符串，变长</td>
<td>“a”,’b’</td>
</tr>
<tr>
<td></td>
<td>VARCHAR</td>
<td>变长字符串</td>
<td>“a”,’b’</td>
</tr>
<tr>
<td></td>
<td>CHAR</td>
<td>固定长度字符串</td>
<td>“a”,’b’</td>
</tr>
<tr>
<td></td>
<td>BINARY</td>
<td>字节数组</td>
<td>无法表示</td>
</tr>
<tr>
<td></td>
<td>TIMESTAMP</td>
<td>时间戳，毫秒值精度</td>
<td>122327493795</td>
</tr>
<tr>
<td></td>
<td><strong>DATE</strong></td>
<td>日期</td>
<td>‘2016-03-29’</td>
</tr>
<tr>
<td></td>
<td>INTERVAL</td>
<td>时间频率间隔</td>
<td></td>
</tr>
<tr>
<td>复杂类型</td>
<td>ARRAY</td>
<td>有序的的同类型的集合</td>
<td>array(1,2)</td>
</tr>
<tr>
<td></td>
<td>MAP</td>
<td>key-value,key必须为原始类型，value可以任意类型</td>
<td>map(‘a’,1,’b’,2)</td>
</tr>
<tr>
<td></td>
<td>STRUCT</td>
<td>字段集合,类型可以不同</td>
<td>struct(‘1’,1,1.0), named_stract(‘col1’,’1’,’col2’,1,’clo3’,1.0)</td>
</tr>
<tr>
<td></td>
<td>UNION</td>
<td>在有限取值范围内的一个值</td>
<td>create_union(1,’a’,63)</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>对decimal类型简单解释下</strong>：<br> 用法：decimal(11,2) 代表最多有11位数字，其中后2位是小数，整数部分是9位；如果整数部分超过9位，则这个字段就会变成null；如果小数部分不足2位，则后面用0补齐两位，如果小数部分超过两位，则超出部分四舍五入<br> 也可直接写 decimal，后面不指定位数，默认是 decimal(10,0)  整数10位，没有小数</p>
</blockquote>
<ul>
<li>创建表并指定字段之间的分隔符</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span>  <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> stu2(id <span class="type">int</span> ,name string) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span> stored <span class="keyword">as</span> textfile location <span class="string">&#x27;/user/stu2&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>row format delimited fields terminated by ‘\t’  指定字段分隔符，默认分隔符为 ‘\001’<br> stored as 指定存储格式<br> location 指定存储位置</p>
</blockquote>
<ul>
<li>根据查询结果创建表</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu3 <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu2;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>根据已经存在的表结构创建表</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu4 <span class="keyword">like</span> stu2;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查询表的结构</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 只查询表内字段及属性</span><br><span class="line"><span class="keyword">desc</span> stu2;</span><br><span class="line"></span><br><span class="line"># 详细查询</span><br><span class="line"><span class="keyword">desc</span> formatted  stu2;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查询创建表的语句</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> stu2;</span><br></pre></td></tr></table></figure></div>

<h4 id="对外部表操作"><a href="#对外部表操作" class="headerlink" title="对外部表操作"></a>对外部表操作</h4><blockquote>
<p>外部表因为是指定其他的hdfs路径的数据加载到表当中来，所以hive表会认为自己不完全独占这份数据，所以删除hive表的时候，数据仍然存放在hdfs当中，不会删掉，只会删除表的元数据</p>
</blockquote>
<ul>
<li>构建外部表</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> student (s_id string,s_name string) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>从本地文件系统向表中加载数据</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 追加操作</span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/export/servers/hivedatas/student.csv&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> student;</span><br><span class="line"></span><br><span class="line"># 覆盖操作</span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/export/servers/hivedatas/student.csv&#x27;</span> overwrite  <span class="keyword">into</span> <span class="keyword">table</span> student;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>从hdfs文件系统向表中加载数据</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"> load data inpath <span class="string">&#x27;/hivedatas/techer.csv&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> techer;</span><br><span class="line"></span><br><span class="line"># 加载数据到指定分区</span><br><span class="line">load data inpath <span class="string">&#x27;/hivedatas/techer.csv&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> techer <span class="keyword">partition</span>(cur_date<span class="operator">=</span><span class="number">20201210</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<ul>
<li><strong>注意</strong>：<br> 1.使用 load data local 表示从本地文件系统加载，文件会拷贝到hdfs上<br> 2.使用 load data 表示从hdfs文件系统加载，文件会直接移动到hive相关目录下，注意不是拷贝过去，因为hive认为hdfs文件已经有3副本了，没必要再次拷贝了<br> 3.如果表是分区表，load 时不指定分区会报错<br> 4.如果加载相同文件名的文件，会被自动重命名</li>
</ul>
</blockquote>
<h4 id="对分区表的操作"><a href="#对分区表的操作" class="headerlink" title="对分区表的操作"></a>对分区表的操作</h4><ul>
<li>创建分区表的语法</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> score(s_id string, s_score <span class="type">int</span>) partitioned <span class="keyword">by</span> (<span class="keyword">month</span> string);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建一个表带多个分区</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> score2 (s_id string, s_score <span class="type">int</span>) partitioned <span class="keyword">by</span> (<span class="keyword">year</span> string,<span class="keyword">month</span> string,<span class="keyword">day</span> string);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>注意：<br> hive表创建的时候可以用 location 指定一个文件或者文件夹，当指定文件夹时，hive会加载文件夹下的所有文件，当表中无分区时，这个文件夹下不能再有文件夹，否则报错<br> 当表是分区表时，比如 partitioned by (day string)， 则这个文件夹下的每一个文件夹就是一个分区，且文件夹名为 day&#x3D;20201123 这种格式，然后使用：msck  repair   table  score; 修复表结构，成功之后即可看到数据已经全部加载到表当中去了</strong></p>
</blockquote>
<ul>
<li>加载数据到一个分区的表中</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/export/servers/hivedatas/score.csv&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> score <span class="keyword">partition</span> (<span class="keyword">month</span><span class="operator">=</span><span class="string">&#x27;201806&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>加载数据到一个多分区的表中去</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/export/servers/hivedatas/score.csv&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> score2 <span class="keyword">partition</span>(<span class="keyword">year</span><span class="operator">=</span><span class="string">&#x27;2018&#x27;</span>,<span class="keyword">month</span><span class="operator">=</span><span class="string">&#x27;06&#x27;</span>,<span class="keyword">day</span><span class="operator">=</span><span class="string">&#x27;01&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看分区</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span>  partitions  score;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>添加一个分区</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> score <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">month</span><span class="operator">=</span><span class="string">&#x27;201805&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>同时添加多个分区</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> score <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">month</span><span class="operator">=</span><span class="string">&#x27;201804&#x27;</span>) <span class="keyword">partition</span>(<span class="keyword">month</span> <span class="operator">=</span> <span class="string">&#x27;201803&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意：添加分区之后就可以在hdfs文件系统当中看到表下面多了一个文件夹</p>
</blockquote>
<ul>
<li>删除分区</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> score <span class="keyword">drop</span> <span class="keyword">partition</span>(<span class="keyword">month</span> <span class="operator">=</span> <span class="string">&#x27;201806&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="对分桶表操作"><a href="#对分桶表操作" class="headerlink" title="对分桶表操作"></a>对分桶表操作</h4><blockquote>
<p>将数据按照指定的字段进行分成多个桶中去，就是按照分桶字段进行哈希划分到多个文件当中去<br> 分区就是分文件夹，分桶就是分文件</p>
</blockquote>
<blockquote>
<p>分桶优点：<br> \1. 提高join查询效率<br> \2. 提高抽样效率</p>
</blockquote>
<ul>
<li>开启hive的捅表功能</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.enforce.bucketing<span class="operator">=</span><span class="literal">true</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>设置reduce的个数</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> mapreduce.job.reduces<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建桶表</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course (c_id string,c_name string) clustered <span class="keyword">by</span>(c_id) <span class="keyword">into</span> <span class="number">3</span> buckets;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>桶表的数据加载：由于桶表的数据加载通过hdfs  dfs  -put文件或者通过load  data均不可以，只能通过insert  overwrite 进行加载<br> 所以把文件加载到桶表中，需要先创建普通表，并通过insert  overwrite的方式将普通表的数据通过查询的方式加载到桶表当中去</p>
</blockquote>
<ul>
<li>通过insert  overwrite给桶表中加载数据</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> course <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> course_common cluster <span class="keyword">by</span>(c_id);  <span class="comment">-- 最后指定桶字段</span></span><br></pre></td></tr></table></figure></div>

<h4 id="修改表和删除表"><a href="#修改表和删除表" class="headerlink" title="修改表和删除表"></a>修改表和删除表</h4><ul>
<li>修改表名称</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span>  <span class="keyword">table</span>  old_table_name  rename  <span class="keyword">to</span>  new_table_name;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>增加&#x2F;修改列信息</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询表结构</span><br><span class="line"><span class="keyword">desc</span> score5;</span><br><span class="line"></span><br><span class="line"># 添加列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> score5 <span class="keyword">add</span> columns (mycol string, mysco string);</span><br><span class="line"></span><br><span class="line"># 更新列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> score5 change <span class="keyword">column</span> mysco mysconew <span class="type">int</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>删除表操作</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> score5;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>清空表操作</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">truncate</span> <span class="keyword">table</span> score6;</span><br><span class="line"># 说明：只能清空管理表，也就是内部表；清空外部表，会产生错误</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>注意：truncate 和 drop：<br> 如果 hdfs 开启了回收站，drop 删除的表数据是可以从回收站恢复的，表结构恢复不了，需要自己重新创建；truncate 清空的表是不进回收站的，所以无法恢复truncate清空的表<br> 所以 truncate 一定慎用，一旦清空将无力回天</strong></p>
</blockquote>
<h4 id="向hive表中加载数据"><a href="#向hive表中加载数据" class="headerlink" title="向hive表中加载数据"></a>向hive表中加载数据</h4><ul>
<li>直接向分区表中插入数据</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> score <span class="keyword">partition</span>(<span class="keyword">month</span> <span class="operator">=</span><span class="string">&#x27;201807&#x27;</span>) <span class="keyword">values</span> (<span class="string">&#x27;001&#x27;</span>,<span class="string">&#x27;002&#x27;</span>,<span class="string">&#x27;100&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>通过load方式加载数据</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/export/servers/hivedatas/score.csv&#x27;</span> overwrite <span class="keyword">into</span> <span class="keyword">table</span> score <span class="keyword">partition</span>(<span class="keyword">month</span><span class="operator">=</span><span class="string">&#x27;201806&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>通过查询方式加载数据</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> score2 <span class="keyword">partition</span>(<span class="keyword">month</span> <span class="operator">=</span> <span class="string">&#x27;201806&#x27;</span>) <span class="keyword">select</span> s_id,c_id,s_score <span class="keyword">from</span> score1;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查询语句中创建表并加载数据</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> score2 <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> score1;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在创建表是通过location指定加载数据的路径</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> score6 (s_id string,c_id string,s_score <span class="type">int</span>) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> location <span class="string">&#x27;/myscore&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>export导出与import 导入 hive表数据（内部表操作）</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> techer2 <span class="keyword">like</span> techer; <span class="comment">--依据已有表结构创建表</span></span><br><span class="line"></span><br><span class="line">export <span class="keyword">table</span> techer <span class="keyword">to</span>  <span class="string">&#x27;/export/techer&#x27;</span>;</span><br><span class="line"></span><br><span class="line">import <span class="keyword">table</span> techer2 <span class="keyword">from</span> <span class="string">&#x27;/export/techer&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="hive表中数据导出"><a href="#hive表中数据导出" class="headerlink" title="hive表中数据导出"></a>hive表中数据导出</h4><ul>
<li>insert导出</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 将查询的结果导出到本地</span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">local</span> directory <span class="string">&#x27;/export/servers/exporthive&#x27;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> score;</span><br><span class="line"></span><br><span class="line"># 将查询的结果格式化导出到本地</span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">local</span> directory <span class="string">&#x27;/export/servers/exporthive&#x27;</span> <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span> collection items terminated <span class="keyword">by</span> <span class="string">&#x27;#&#x27;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"># 将查询的结果导出到HDFS上(没有<span class="keyword">local</span>)</span><br><span class="line"><span class="keyword">insert</span> overwrite directory <span class="string">&#x27;/export/servers/exporthive&#x27;</span> <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span> collection items terminated <span class="keyword">by</span> <span class="string">&#x27;#&#x27;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> score;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Hadoop命令导出到本地</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">dfs <span class="operator">-</span><span class="keyword">get</span> <span class="operator">/</span>export<span class="operator">/</span>servers<span class="operator">/</span>exporthive<span class="operator">/</span><span class="number">000000</span>_0 <span class="operator">/</span>export<span class="operator">/</span>servers<span class="operator">/</span>exporthive<span class="operator">/</span>local.txt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>hive shell 命令导出</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 基本语法：（hive <span class="operator">-</span>f<span class="operator">/</span><span class="operator">-</span>e 执行语句或者脚本 <span class="operator">&gt;</span> file）</span><br><span class="line"></span><br><span class="line">hive <span class="operator">-</span>e &quot;select * from myhive.score;&quot; <span class="operator">&gt;</span> <span class="operator">/</span>export<span class="operator">/</span>servers<span class="operator">/</span>exporthive<span class="operator">/</span>score.txt</span><br><span class="line"></span><br><span class="line">hive <span class="operator">-</span>f export.sh <span class="operator">&gt;</span> <span class="operator">/</span>export<span class="operator">/</span>servers<span class="operator">/</span>exporthive<span class="operator">/</span>score.txt</span><br></pre></td></tr></table></figure></div>

<ul>
<li>export导出到HDFS上</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">export <span class="keyword">table</span> score <span class="keyword">to</span> <span class="string">&#x27;/export/exporthive/score&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="hive的DQL查询语法"><a href="#hive的DQL查询语法" class="headerlink" title="hive的DQL查询语法"></a>hive的DQL查询语法</h2><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] select_expr, select_expr, ... </span><br><span class="line"><span class="keyword">FROM</span> table_reference</span><br><span class="line">[<span class="keyword">WHERE</span> where_condition] </span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> col_list [<span class="keyword">HAVING</span> <span class="keyword">condition</span>]] </span><br><span class="line">[CLUSTER <span class="keyword">BY</span> col_list </span><br><span class="line">  <span class="operator">|</span> [DISTRIBUTE <span class="keyword">BY</span> col_list] [SORT <span class="keyword">BY</span><span class="operator">|</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> col_list] </span><br><span class="line">] </span><br><span class="line">[LIMIT number]</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意：<br> 1、order by 会对输入做全局排序，因此只有一个reducer，会导致当输入规模较大时，需要较长的计算时间。<br> 2、sort by不是全局排序，其在数据进入reducer前完成排序。因此，如果用sort by进行排序，并且设置mapred.reduce.tasks&gt;1，则sort by只保证每个reducer的输出有序，不保证全局有序。<br> 3、distribute by(字段)根据指定的字段将数据分到不同的reducer，且分发算法是hash散列。<br> 4、Cluster by(字段) 除了具有Distribute by的功能外，还会对该字段进行排序。<br> 因此，如果分桶和sort字段是同一个时，此时，cluster by &#x3D; distribute by + sort by</p>
</blockquote>
<ul>
<li>WHERE语句</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> score <span class="keyword">where</span> s_score <span class="operator">&lt;</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意：<br> 小于某个值是不包含null的，如上查询结果是把 s_score 为 null 的行剔除的</p>
</blockquote>
<ul>
<li>GROUP BY 分组</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">select</span> s_id ,<span class="built_in">avg</span>(s_score) <span class="keyword">from</span> score <span class="keyword">group</span> <span class="keyword">by</span> s_id;</span><br><span class="line"></span><br><span class="line">分组后对数据进行筛选，使用<span class="keyword">having</span></span><br><span class="line"> <span class="keyword">select</span> s_id ,<span class="built_in">avg</span>(s_score) avgscore <span class="keyword">from</span> score <span class="keyword">group</span> <span class="keyword">by</span> s_id <span class="keyword">having</span> avgscore <span class="operator">&gt;</span> <span class="number">85</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意：<br> 如果使用 group by 分组，则 select 后面只能写分组的字段或者聚合函数<br> where和having区别：<br> 1 having是在 group by 分完组之后再对数据进行筛选，所以having 要筛选的字段只能是分组字段或者聚合函数<br> 2 where 是从数据表中的字段直接进行的筛选的，所以不能跟在gruop by后面，也不能使用聚合函数</p>
</blockquote>
<ul>
<li>join 连接</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 内连接：只有进行连接的两个表中都存在与连接条件相匹配的数据才会被保留下来</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> techer t [<span class="keyword">inner</span>] <span class="keyword">join</span> course c <span class="keyword">on</span> t.t_id <span class="operator">=</span> c.t_id; <span class="comment">-- inner 可省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> 左外连接：左边所有数据会被返回，右边符合条件的被返回</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> techer t <span class="keyword">left</span> <span class="keyword">join</span> course c <span class="keyword">on</span> t.t_id <span class="operator">=</span> c.t_id; <span class="comment">-- outer可省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> 右外连接：右边所有数据会被返回，左边符合条件的被返回、</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> techer t <span class="keyword">right</span> <span class="keyword">join</span> course c <span class="keyword">on</span> t.t_id <span class="operator">=</span> c.t_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> 满外(全外)连接: 将会返回所有表中符合条件的所有记录。如果任一表的指定字段没有符合条件的值的话，那么就使用<span class="keyword">NULL</span>值替代。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> techer t <span class="keyword">FULL</span> <span class="keyword">JOIN</span> course c <span class="keyword">ON</span> t.t_id <span class="operator">=</span> c.t_id ;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注：1. hive2版本已经支持不等值连接，就是 join on条件后面可以使用大于小于符号了;并且也支持 join on 条件后跟or (早前版本 on 后只支持 &#x3D; 和 and，不支持 &gt; &lt; 和 or)<br> 2.如hive执行引擎使用MapReduce，一个join就会启动一个job，一条sql语句中如有多个join，则会启动多个job</p>
</blockquote>
<blockquote>
<p>注意：表之间用逗号(,)连接和 inner join 是一样的<br> select * from table_a,table_b where table_a.id&#x3D;table_b.id;<br> 它们的执行效率没有区别，只是书写方式不同，用逗号是sql 89标准，join 是sql 92标准。用逗号连接后面过滤条件用 where ，用 join 连接后面过滤条件是 on。</p>
</blockquote>
<ul>
<li>order by 排序</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 全局排序，只会有一个reduce</span><br><span class="line"><span class="keyword">ASC</span>（ascend）: 升序（默认） <span class="keyword">DESC</span>（descend）: 降序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student s <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sco <span class="keyword">ON</span> s.s_id <span class="operator">=</span> sco.s_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> sco.s_score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意：order by 是全局排序，所以最后只有一个reduce，也就是在一个节点执行，如果数据量太大，就会耗费较长时间</p>
</blockquote>
<ul>
<li>sort by 局部排序</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 每个MapReduce内部进行排序，对全局结果集来说不是排序。</span><br><span class="line"></span><br><span class="line"># 设置reduce个数</span><br><span class="line"><span class="keyword">set</span> mapreduce.job.reduces<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"># 查看设置reduce个数</span><br><span class="line"><span class="keyword">set</span> mapreduce.job.reduces;</span><br><span class="line"></span><br><span class="line"># 查询成绩按照成绩降序排列</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> score sort <span class="keyword">by</span> s_score;</span><br><span class="line"> </span><br><span class="line"># 将查询结果导入到文件中（按照成绩降序排列）</span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">local</span> directory <span class="string">&#x27;/export/servers/hivedatas/sort&#x27;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> score sort <span class="keyword">by</span> s_score;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>distribute by  分区排序</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># distribute <span class="keyword">by</span>：类似MR中<span class="keyword">partition</span>，进行分区，结合sort <span class="keyword">by</span>使用</span><br><span class="line"></span><br><span class="line"># 设置reduce的个数，将我们对应的s_id划分到对应的reduce当中去</span><br><span class="line"><span class="keyword">set</span> mapreduce.job.reduces<span class="operator">=</span><span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"># 通过distribute <span class="keyword">by</span>  进行数据的分区</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> score distribute <span class="keyword">by</span> s_id sort <span class="keyword">by</span> s_score;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意：Hive要求 distribute by 语句要写在 sort by 语句之前</p>
</blockquote>
<ul>
<li>cluster by</li>
</ul>
<div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line">当distribute <span class="keyword">by</span>和sort <span class="keyword">by</span>字段相同时，可以使用cluster <span class="keyword">by</span>方式.</span><br><span class="line">cluster <span class="keyword">by</span>除了具有distribute <span class="keyword">by</span>的功能外还兼具sort <span class="keyword">by</span>的功能。但是排序只能是正序排序，不能指定排序规则为ASC或者DESC。</span><br><span class="line"></span><br><span class="line">以下两种写法等价</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score cluster <span class="keyword">by</span> s_id;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score distribute <span class="keyword">by</span> s_id sort <span class="keyword">by</span> s_id;</span><br></pre></td></tr></table></figure></div>

<h2 id="Hive函数"><a href="#Hive函数" class="headerlink" title="Hive函数"></a>Hive函数</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">hive支持 <span class="built_in">count</span>(),<span class="built_in">max</span>(),<span class="built_in">min</span>(),<span class="built_in">sum</span>(),<span class="built_in">avg</span>() 等常用的聚合函数</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意：<br> 聚合操作时要注意null值<br> count(*) 包含null值，统计所有行数<br> count(id) 不包含null值<br> min 求最小值是不包含null，除非所有值都是null<br> avg 求平均值也是不包含null</p>
</blockquote>
<ul>
<li>非空集合总体变量函数: var_pop</li>
</ul>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">语法: var_pop(col)</span></span><br><span class="line"><span class="section">返回值: double</span></span><br><span class="line"><span class="section">说明: 统计结果集中col非空集合的总体变量（忽略null）</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>非空集合样本变量函数: var_samp</li>
</ul>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">语法: var_samp (col)</span></span><br><span class="line"><span class="section">返回值: double</span></span><br><span class="line"><span class="section">说明: 统计结果集中col非空集合的样本变量（忽略null）</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>总体标准偏离函数: stddev_pop</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: <span class="built_in">stddev_pop</span>(col)</span><br><span class="line">返回值: <span class="keyword">double</span></span><br><span class="line">说明: 该函数计算总体标准偏离，并返回总体变量的平方根，其返回值与VAR_POP函数的平方根相同</span><br></pre></td></tr></table></figure></div>

<ul>
<li>中位数函数: percentile</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: percentile(<span class="type">BIGINT</span> col, p)</span><br><span class="line">返回值: <span class="keyword">double</span></span><br><span class="line">说明: 求准确的第pth个百分位数，p必须介于<span class="number">0</span>和<span class="number">1</span>之间，但是col字段目前只支持整数，不支持浮点数类型</span><br></pre></td></tr></table></figure></div>

<h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">支持：等值(<span class="operator">=</span>)、不等值(<span class="operator">!=</span> 或 <span class="operator">&lt;&gt;</span>)、小于(<span class="operator">&lt;</span>)、小于等于(<span class="operator">&lt;=</span>)、大于(<span class="operator">&gt;</span>)、大于等于(<span class="operator">&gt;=</span>)</span><br><span class="line"></span><br><span class="line">空值判断(<span class="keyword">is</span> <span class="keyword">null</span>)、非空判断(<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>LIKE比较: LIKE</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: A <span class="keyword">LIKE</span> B</span><br><span class="line">操作类型: strings</span><br><span class="line">描述: 如果字符串A或者字符串B为<span class="keyword">NULL</span>，则返回<span class="keyword">NULL</span>；如果字符串A符合表达式B 的正则语法，则为<span class="literal">TRUE</span>；否则为<span class="literal">FALSE</span>。B中字符”_”表示任意单个字符，而字符”<span class="operator">%</span>”表示任意数量的字符。</span><br></pre></td></tr></table></figure></div>

<ul>
<li>JAVA的LIKE操作: RLIKE</li>
</ul>
<div class="highlight-container" data-rel="Less"><figure class="iseeu highlight less"><table><tr><td class="code"><pre><span class="line">语法: <span class="selector-tag">A</span> <span class="selector-tag">RLIKE</span> <span class="selector-tag">B</span></span><br><span class="line">操作类型: <span class="selector-tag">strings</span></span><br><span class="line">描述: 如果字符串<span class="selector-tag">A</span>或者字符串<span class="selector-tag">B</span>为<span class="selector-tag">NULL</span>，则返回<span class="selector-tag">NULL</span>；如果字符串<span class="selector-tag">A</span>符合<span class="selector-tag">JAVA</span>正则表达式<span class="selector-tag">B</span>的正则语法，则为<span class="selector-tag">TRUE</span>；否则为<span class="selector-tag">FALSE</span>。</span><br></pre></td></tr></table></figure></div>

<ul>
<li>REGEXP操作: REGEXP</li>
</ul>
<div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line">语法: A REGEXP B</span><br><span class="line">操作类型: strings</span><br><span class="line">描述: 功能与RLIKE相同</span><br><span class="line">示例：<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> tableName <span class="keyword">where</span> <span class="string">&#x27;footbar&#x27;</span> REGEXP <span class="string">&#x27;^f.*r$&#x27;</span>;</span><br><span class="line">结果：<span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">支持所有数值类型：加(<span class="operator">+</span>)、减(<span class="operator">-</span>)、乘(<span class="operator">*</span>)、除(<span class="operator">/</span>)、取余(<span class="operator">%</span>)、位与(<span class="operator">&amp;</span>)、位或(<span class="operator">|</span>)、位异或(<span class="operator">^</span>)、位取反(<span class="operator">~</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">支持：逻辑与(<span class="keyword">and</span>)、逻辑或(<span class="keyword">or</span>)、逻辑非(<span class="keyword">not</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h3><ul>
<li>取整函数: round</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: round(<span class="keyword">double</span> a)</span><br><span class="line">返回值: <span class="type">BIGINT</span></span><br><span class="line">说明: 返回<span class="keyword">double</span>类型的整数值部分 （遵循四舍五入）</span><br><span class="line">示例：<span class="keyword">select</span> round(<span class="number">3.1415926</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">结果：<span class="number">3</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>指定精度取整函数: round</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: round(<span class="keyword">double</span> a, <span class="type">int</span> d)</span><br><span class="line">返回值: <span class="keyword">DOUBLE</span></span><br><span class="line">说明: 返回指定精度d的<span class="keyword">double</span>类型</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> round(<span class="number">3.1415926</span>,<span class="number">4</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">3.1416</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>向下取整函数: floor</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: <span class="built_in">floor</span>(<span class="keyword">double</span> a)</span><br><span class="line">返回值: <span class="type">BIGINT</span></span><br><span class="line">说明: 返回等于或者小于该<span class="keyword">double</span>变量的最大的整数</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">floor</span>(<span class="number">3.641</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>向上取整函数: ceil</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: <span class="built_in">ceil</span>(<span class="keyword">double</span> a)</span><br><span class="line">返回值: <span class="type">BIGINT</span></span><br><span class="line">说明: 返回等于或者大于该<span class="keyword">double</span>变量的最小的整数</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">ceil</span>(<span class="number">3.1415926</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>取随机数函数: rand</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: rand(),rand(<span class="type">int</span> seed)</span><br><span class="line">返回值: <span class="keyword">double</span></span><br><span class="line">说明: 返回一个<span class="number">0</span>到<span class="number">1</span>范围内的随机数。如果指定种子seed，则会等到一个稳定的随机数序列</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> rand() <span class="keyword">from</span> tableName; <span class="comment">-- 每次执行此语句得到的结果都不同</span></span><br><span class="line"><span class="number">0.5577432776034763</span></span><br><span class="line"></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> rand(<span class="number">100</span>) ;  <span class="comment">-- 只要指定种子，每次执行此语句得到的结果一样的</span></span><br><span class="line"><span class="number">0.7220096548596434</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>自然指数函数: exp</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: <span class="built_in">exp</span>(<span class="keyword">double</span> a)</span><br><span class="line">返回值: <span class="keyword">double</span></span><br><span class="line">说明: 返回自然对数e的a次方</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">exp</span>(<span class="number">2</span>) ;</span><br><span class="line"><span class="number">7.38905609893065</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>以10为底对数函数: log10</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: <span class="built_in">log10</span>(<span class="keyword">double</span> a)</span><br><span class="line">返回值: <span class="keyword">double</span></span><br><span class="line">说明: 返回以<span class="number">10</span>为底的a的对数</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">log10</span>(<span class="number">100</span>) ;</span><br><span class="line"><span class="number">2.0</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>此外还有：以2为底对数函数: log2()、对数函数: log()</p>
</blockquote>
<ul>
<li>幂运算函数: pow</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: pow(<span class="keyword">double</span> a, <span class="keyword">double</span> p)</span><br><span class="line">返回值: <span class="keyword">double</span></span><br><span class="line">说明: 返回a的p次幂</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> pow(<span class="number">2</span>,<span class="number">4</span>) ;</span><br><span class="line"><span class="number">16.0</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>开平方函数: sqrt</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: <span class="built_in">sqrt</span>(<span class="keyword">double</span> a)</span><br><span class="line">返回值: <span class="keyword">double</span></span><br><span class="line">说明: 返回a的平方根</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">sqrt</span>(<span class="number">16</span>) ;</span><br><span class="line"><span class="number">4.0</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>二进制函数: bin</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: bin(<span class="type">BIGINT</span> a)</span><br><span class="line">返回值: string</span><br><span class="line">说明: 返回a的二进制代码表示</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> bin(<span class="number">7</span>) ;</span><br><span class="line"><span class="number">111</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>十六进制函数: hex()、将十六进制转化为字符串函数: unhex()<br> 进制转换函数: conv(bigint num, int from_base, int to_base) 说明: 将数值num从from_base进制转化到to_base进制</p>
</blockquote>
<blockquote>
<p>此外还有很多数学函数： 绝对值函数: abs()、正取余函数: pmod()、正弦函数: sin()、反正弦函数: asin()、余弦函数: cos()、反余弦函数: acos()、positive函数: positive()、negative函数: negative()</p>
</blockquote>
<h3 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h3><ul>
<li>If函数: if</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: if(<span class="type">boolean</span> testCondition, T valueTrue, T valueFalseOrNull)</span><br><span class="line">返回值: T</span><br><span class="line">说明: 当条件testCondition为<span class="literal">TRUE</span>时，返回valueTrue；否则返回valueFalseOrNull</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> if(<span class="number">1</span><span class="operator">=</span><span class="number">2</span>,<span class="number">100</span>,<span class="number">200</span>) ;</span><br><span class="line"><span class="number">200</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> if(<span class="number">1</span><span class="operator">=</span><span class="number">1</span>,<span class="number">100</span>,<span class="number">200</span>) ;</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>非空查找函数: coalesce</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: <span class="built_in">coalesce</span>(T v1, T v2, …)</span><br><span class="line">返回值: T</span><br><span class="line">说明: 返回参数中的第一个非空值；如果所有值都为<span class="keyword">NULL</span>，那么返回<span class="keyword">NULL</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">coalesce</span>(<span class="keyword">null</span>,<span class="string">&#x27;100&#x27;</span>,<span class="string">&#x27;50&#x27;</span>) ;</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>条件判断函数：case when (两种写法，其一)</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: <span class="keyword">case</span> <span class="keyword">when</span> a <span class="keyword">then</span> b [<span class="keyword">when</span> c <span class="keyword">then</span> d]<span class="operator">*</span> [<span class="keyword">else</span> e] <span class="keyword">end</span></span><br><span class="line">返回值: T</span><br><span class="line">说明：如果a为<span class="literal">TRUE</span>,则返回b；如果c为<span class="literal">TRUE</span>，则返回d；否则返回e</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span> <span class="keyword">then</span> <span class="string">&#x27;tom&#x27;</span> <span class="keyword">when</span> <span class="number">2</span><span class="operator">=</span><span class="number">2</span> <span class="keyword">then</span> <span class="string">&#x27;mary&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;tim&#x27;</span> <span class="keyword">end</span> <span class="keyword">from</span> tableName;</span><br><span class="line">mary</span><br></pre></td></tr></table></figure></div>

<ul>
<li>条件判断函数：case when (两种写法，其二)</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: <span class="keyword">case</span> a <span class="keyword">when</span> b <span class="keyword">then</span> c [<span class="keyword">when</span> d <span class="keyword">then</span> e]<span class="operator">*</span> [<span class="keyword">else</span> f] <span class="keyword">end</span></span><br><span class="line">返回值: T</span><br><span class="line">说明：如果a等于b，那么返回c；如果a等于d，那么返回e；否则返回f</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">Select</span> <span class="keyword">case</span> <span class="number">100</span> <span class="keyword">when</span> <span class="number">50</span> <span class="keyword">then</span> <span class="string">&#x27;tom&#x27;</span> <span class="keyword">when</span> <span class="number">100</span> <span class="keyword">then</span> <span class="string">&#x27;mary&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;tim&#x27;</span> <span class="keyword">end</span> <span class="keyword">from</span> tableName;</span><br><span class="line">mary</span><br></pre></td></tr></table></figure></div>

<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><blockquote>
<p>注：以下SQL语句中的 from tableName 可去掉，不影响查询结果</p>
</blockquote>
<ul>
<li><ol>
<li>获取当前UNIX时间戳函数: unix_timestamp</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: unix_timestamp()</span><br><span class="line">返回值: <span class="type">bigint</span></span><br><span class="line">说明: 获得当前时区的UNIX时间戳</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> unix_timestamp() <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">1616906976</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>UNIX时间戳转日期函数: from_unixtime</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: from_unixtime(<span class="type">bigint</span> unixtime[, string format])</span><br><span class="line">返回值: string</span><br><span class="line">说明: 转化UNIX时间戳（从<span class="number">1970</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> UTC到指定时间的秒数）到当前时区的时间格式</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> from_unixtime(<span class="number">1616906976</span>,<span class="string">&#x27;yyyyMMdd&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">20210328</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>日期转UNIX时间戳函数: unix_timestamp</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: unix_timestamp(string <span class="type">date</span>)</span><br><span class="line">返回值: <span class="type">bigint</span></span><br><span class="line">说明: 转换格式为&quot;yyyy-MM-dd HH:mm:ss&quot;的日期到UNIX时间戳。如果转化失败，则返回<span class="number">0</span>。</span><br><span class="line">hive<span class="operator">&gt;</span>  <span class="keyword">select</span> unix_timestamp(<span class="string">&#x27;2021-03-08 14:21:15&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">1615184475</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>指定格式日期转UNIX时间戳函数: unix_timestamp</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: unix_timestamp(string <span class="type">date</span>, string <span class="keyword">pattern</span>)</span><br><span class="line">返回值: <span class="type">bigint</span></span><br><span class="line">说明: 转换<span class="keyword">pattern</span>格式的日期到UNIX时间戳。如果转化失败，则返回<span class="number">0</span>。</span><br><span class="line">hive<span class="operator">&gt;</span>  <span class="keyword">select</span> unix_timestamp(<span class="string">&#x27;2021-03-08 14:21:15&#x27;</span>,<span class="string">&#x27;yyyyMMdd HH:mm:ss&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">1615184475</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>日期时间转日期函数: to_date</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: to_date(string <span class="type">timestamp</span>)</span><br><span class="line">返回值: string</span><br><span class="line">说明: 返回日期时间字段中的日期部分。</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> to_date(<span class="string">&#x27;2021-03-28 14:03:01&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">2021</span><span class="number">-03</span><span class="number">-28</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>日期转年函数: year</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: <span class="keyword">year</span>(string <span class="type">date</span>)</span><br><span class="line">返回值: <span class="type">int</span></span><br><span class="line">说明: 返回日期中的年。</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">year</span>(<span class="string">&#x27;2021-03-28 10:03:01&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">2021</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">year</span>(<span class="string">&#x27;2021-03-28&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">2021</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>日期转月函数: month</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: <span class="keyword">month</span> (string <span class="type">date</span>)</span><br><span class="line">返回值: <span class="type">int</span></span><br><span class="line">说明: 返回日期中的月份。</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">month</span>(<span class="string">&#x27;2020-12-28 12:03:01&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">12</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">month</span>(<span class="string">&#x27;2021-03-08&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>日期转天函数: day</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: <span class="keyword">day</span> (string <span class="type">date</span>)</span><br><span class="line">返回值: <span class="type">int</span></span><br><span class="line">说明: 返回日期中的天。</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">day</span>(<span class="string">&#x27;2020-12-08 10:03:01&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">8</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">day</span>(<span class="string">&#x27;2020-12-24&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>日期转小时函数: hour</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: <span class="keyword">hour</span> (string <span class="type">date</span>)</span><br><span class="line">返回值: <span class="type">int</span></span><br><span class="line">说明: 返回日期中的小时。</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">hour</span>(<span class="string">&#x27;2020-12-08 10:03:01&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>日期转分钟函数: minute</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: <span class="keyword">minute</span> (string <span class="type">date</span>)</span><br><span class="line">返回值: <span class="type">int</span></span><br><span class="line">说明: 返回日期中的分钟。</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">minute</span>(<span class="string">&#x27;2020-12-08 10:03:01&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>日期转秒函数: second</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: <span class="keyword">second</span> (string <span class="type">date</span>)</span><br><span class="line">返回值: <span class="type">int</span></span><br><span class="line">说明: 返回日期中的秒。</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">second</span>(<span class="string">&#x27;2020-12-08 10:03:01&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>日期转周函数: weekofyear</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: weekofyear (string <span class="type">date</span>)</span><br><span class="line">返回值: <span class="type">int</span></span><br><span class="line">说明: 返回日期在当前的周数。</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> weekofyear(<span class="string">&#x27;2020-12-08 10:03:01&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">49</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>日期比较函数: datediff</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: datediff(string enddate, string startdate)</span><br><span class="line">返回值: <span class="type">int</span></span><br><span class="line">说明: 返回结束日期减去开始日期的天数。</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> datediff(<span class="string">&#x27;2020-12-08&#x27;</span>,<span class="string">&#x27;2012-05-09&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">213</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>日期增加函数: date_add</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: date_add(string startdate, <span class="type">int</span> days)</span><br><span class="line">返回值: string</span><br><span class="line">说明: 返回开始日期startdate增加days天后的日期。</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> date_add(<span class="string">&#x27;2020-12-08&#x27;</span>,<span class="number">10</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">2020</span><span class="number">-12</span><span class="number">-18</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>日期减少函数: date_sub</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: date_sub (string startdate, <span class="type">int</span> days)</span><br><span class="line">返回值: string</span><br><span class="line">说明: 返回开始日期startdate减少days天后的日期。</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> date_sub(<span class="string">&#x27;2020-12-08&#x27;</span>,<span class="number">10</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">2020</span><span class="number">-11</span><span class="number">-28</span></span><br></pre></td></tr></table></figure></div>

<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><ul>
<li><ol>
<li>字符串长度函数：length</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: length(string A)</span><br><span class="line">返回值: <span class="type">int</span></span><br><span class="line">说明：返回字符串A的长度</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> length(<span class="string">&#x27;abcedfg&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>字符串反转函数：reverse</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: reverse(string A)</span><br><span class="line">返回值: string</span><br><span class="line">说明：返回字符串A的反转结果</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> reverse(<span class="string">&#x27;abcedfg&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">gfdecba</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>字符串连接函数：concat</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: concat(string A, string B…)</span><br><span class="line">返回值: string</span><br><span class="line">说明：返回输入字符串连接后的结果，支持任意个输入字符串</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> concat(<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;def’,&#x27;</span>gh<span class="string">&#x27;)from tableName;</span></span><br><span class="line"><span class="string">abcdefgh</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>带分隔符字符串连接函数：concat_ws</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: concat_ws(string SEP, string A, string B…)</span><br><span class="line">返回值: string</span><br><span class="line">说明：返回输入字符串连接后的结果，SEP表示各个字符串间的分隔符</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> concat_ws(<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;def&#x27;</span>,<span class="string">&#x27;gh&#x27;</span>)<span class="keyword">from</span> tableName;</span><br><span class="line">abc,def,gh</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>字符串截取函数：substr,substring</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: substr(string A, <span class="type">int</span> <span class="keyword">start</span>),<span class="built_in">substring</span>(string A, <span class="type">int</span> <span class="keyword">start</span>)</span><br><span class="line">返回值: string</span><br><span class="line">说明：返回字符串A从<span class="keyword">start</span>位置到结尾的字符串</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> substr(<span class="string">&#x27;abcde&#x27;</span>,<span class="number">3</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">cde</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">substring</span>(<span class="string">&#x27;abcde&#x27;</span>,<span class="number">3</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">cde</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> substr(<span class="string">&#x27;abcde&#x27;</span>,<span class="number">-1</span>) <span class="keyword">from</span> tableName; （和ORACLE相同）</span><br><span class="line">e</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>字符串截取函数：substr,substring</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: substr(string A, <span class="type">int</span> <span class="keyword">start</span>, <span class="type">int</span> len),<span class="built_in">substring</span>(string A, <span class="type">int</span> <span class="keyword">start</span>, <span class="type">int</span> len)</span><br><span class="line">返回值: string</span><br><span class="line">说明：返回字符串A从<span class="keyword">start</span>位置开始，长度为len的字符串</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> substr(<span class="string">&#x27;abcde&#x27;</span>,<span class="number">3</span>,<span class="number">2</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">cd</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">substring</span>(<span class="string">&#x27;abcde&#x27;</span>,<span class="number">3</span>,<span class="number">2</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">cd</span><br><span class="line">hive<span class="operator">&gt;</span><span class="keyword">select</span> <span class="built_in">substring</span>(<span class="string">&#x27;abcde&#x27;</span>,<span class="number">-2</span>,<span class="number">2</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">de</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>字符串转大写函数：upper,ucase</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: <span class="built_in">upper</span>(string A) ucase(string A)</span><br><span class="line">返回值: string</span><br><span class="line">说明：返回字符串A的大写格式</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">upper</span>(<span class="string">&#x27;abSEd&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">ABSED</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> ucase(<span class="string">&#x27;abSEd&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">ABSED</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>字符串转小写函数：lower,lcase</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: <span class="built_in">lower</span>(string A) lcase(string A)</span><br><span class="line">返回值: string</span><br><span class="line">说明：返回字符串A的小写格式</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">lower</span>(<span class="string">&#x27;abSEd&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">absed</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> lcase(<span class="string">&#x27;abSEd&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">absed</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>去空格函数：trim</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: <span class="built_in">trim</span>(string A)</span><br><span class="line">返回值: string</span><br><span class="line">说明：去除字符串两边的空格</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">trim</span>(<span class="string">&#x27; abc &#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">abc</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>左边去空格函数：ltrim</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: ltrim(string A)</span><br><span class="line">返回值: string</span><br><span class="line">说明：去除字符串左边的空格</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> ltrim(<span class="string">&#x27; abc &#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">abc</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>右边去空格函数：rtrim</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: rtrim(string A)</span><br><span class="line">返回值: string</span><br><span class="line">说明：去除字符串右边的空格</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> rtrim(<span class="string">&#x27; abc &#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">abc</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>正则表达式替换函数：regexp_replace</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: regexp_replace(string A, string B, string C)</span><br><span class="line">返回值: string</span><br><span class="line">说明：将字符串A中的符合java正则表达式B的部分替换为C。注意，在有些情况下要使用转义字符,类似oracle中的regexp_replace函数。</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> regexp_replace(<span class="string">&#x27;foobar&#x27;</span>, <span class="string">&#x27;oo|ar&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">fb</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>正则表达式解析函数：regexp_extract</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: regexp_extract(string subject, string <span class="keyword">pattern</span>, <span class="type">int</span> index)</span><br><span class="line">返回值: string</span><br><span class="line">说明：将字符串subject按照<span class="keyword">pattern</span>正则表达式的规则拆分，返回index指定的字符。</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> regexp_extract(<span class="string">&#x27;foothebar&#x27;</span>, <span class="string">&#x27;foo(.*?)(bar)&#x27;</span>, <span class="number">1</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">the</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> regexp_extract(<span class="string">&#x27;foothebar&#x27;</span>, <span class="string">&#x27;foo(.*?)(bar)&#x27;</span>, <span class="number">2</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">bar</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> regexp_extract(<span class="string">&#x27;foothebar&#x27;</span>, <span class="string">&#x27;foo(.*?)(bar)&#x27;</span>, <span class="number">0</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">foothebar</span><br><span class="line">strong<span class="operator">&gt;</span>注意，在有些情况下要使用转义字符，下面的等号要用双竖线转义，这是java正则表达式的规则。</span><br><span class="line"><span class="keyword">select</span> data_field,</span><br><span class="line">regexp_extract(data_field,<span class="string">&#x27;.*?bgStart\\=([^&amp;]+)&#x27;</span>,<span class="number">1</span>) <span class="keyword">as</span> aaa,</span><br><span class="line">regexp_extract(data_field,<span class="string">&#x27;.*?contentLoaded_headStart\\=([^&amp;]+)&#x27;</span>,<span class="number">1</span>) <span class="keyword">as</span> bbb,</span><br><span class="line">regexp_extract(data_field,<span class="string">&#x27;.*?AppLoad2Req\\=([^&amp;]+)&#x27;</span>,<span class="number">1</span>) <span class="keyword">as</span> ccc </span><br><span class="line"><span class="keyword">from</span> pt_nginx_loginlog_st </span><br><span class="line"><span class="keyword">where</span> pt <span class="operator">=</span> <span class="string">&#x27;2021-03-28&#x27;</span> limit <span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>URL解析函数：parse_url</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: parse_url(string urlString, string partToExtract [, string keyToExtract])</span><br><span class="line">返回值: string</span><br><span class="line">说明：返回URL中指定的部分。partToExtract的有效值为：HOST, PATH, QUERY, <span class="keyword">REF</span>, PROTOCOL, AUTHORITY, FILE, <span class="keyword">and</span> USERINFO.</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> parse_url</span><br><span class="line">(<span class="string">&#x27;https://www.tableName.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#x27;</span>, <span class="string">&#x27;HOST&#x27;</span>) </span><br><span class="line"><span class="keyword">from</span> tableName;</span><br><span class="line">www.tableName.com </span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> parse_url</span><br><span class="line">(<span class="string">&#x27;https://www.tableName.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#x27;</span>, <span class="string">&#x27;QUERY&#x27;</span>, <span class="string">&#x27;k1&#x27;</span>)</span><br><span class="line"> <span class="keyword">from</span> tableName;</span><br><span class="line">v1</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>json解析函数：get_json_object</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: get_json_object(string json_string, string path)</span><br><span class="line">返回值: string</span><br><span class="line">说明：解析json的字符串json_string,返回path指定的内容。如果输入的json字符串无效，那么返回<span class="keyword">NULL</span>。</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span>  get_json_object(<span class="string">&#x27;&#123;&quot;store&quot;:&#123;&quot;fruit&quot;:\[&#123;&quot;weight&quot;:8,&quot;type&quot;:&quot;apple&quot;&#125;,&#123;&quot;weight&quot;:9,&quot;type&quot;:&quot;pear&quot;&#125;], &quot;bicycle&quot;:&#123;&quot;price&quot;:19.95,&quot;color&quot;:&quot;red&quot;&#125; &#125;,&quot;email&quot;:&quot;amy@only_for_json_udf_test.net&quot;,&quot;owner&quot;:&quot;amy&quot;&#125;&#x27;</span>,<span class="string">&#x27;$.owner&#x27;</span>) <span class="keyword">from</span> tableName;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>空格字符串函数：space</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: space(<span class="type">int</span> n)</span><br><span class="line">返回值: string</span><br><span class="line">说明：返回长度为n的字符串</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> space(<span class="number">10</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> length(space(<span class="number">10</span>)) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>重复字符串函数：repeat</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: repeat(string str, <span class="type">int</span> n)</span><br><span class="line">返回值: string</span><br><span class="line">说明：返回重复n次后的str字符串</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> repeat(<span class="string">&#x27;abc&#x27;</span>,<span class="number">5</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">abcabcabcabcabc</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>首字符ascii函数：ascii</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: ascii(string str)</span><br><span class="line">返回值: <span class="type">int</span></span><br><span class="line">说明：返回字符串str第一个字符的ascii码</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> ascii(<span class="string">&#x27;abcde&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">97</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>左补足函数：lpad</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: lpad(string str, <span class="type">int</span> len, string pad)</span><br><span class="line">返回值: string</span><br><span class="line">说明：将str进行用pad进行左补足到len位</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> lpad(<span class="string">&#x27;abc&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;td&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">tdtdtdtabc</span><br><span class="line">注意：与GP，ORACLE不同，pad 不能默认</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>右补足函数：rpad</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: rpad(string str, <span class="type">int</span> len, string pad)</span><br><span class="line">返回值: string</span><br><span class="line">说明：将str进行用pad进行右补足到len位</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> rpad(<span class="string">&#x27;abc&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;td&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">abctdtdtdt</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>分割字符串函数: split</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: split(string str, string pat)</span><br><span class="line">返回值: <span class="keyword">array</span></span><br><span class="line">说明: 按照pat字符串分割str，会返回分割后的字符串数组</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> split(<span class="string">&#x27;abtcdtef&#x27;</span>,<span class="string">&#x27;t&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line">[&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>集合查找函数: find_in_set</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: find_in_set(string str, string strList)</span><br><span class="line">返回值: <span class="type">int</span></span><br><span class="line">说明: 返回str在strlist第一次出现的位置，strlist是用逗号分割的字符串。如果没有找该str字符，则返回<span class="number">0</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> find_in_set(<span class="string">&#x27;ab&#x27;</span>,<span class="string">&#x27;ef,ab,de&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">2</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> find_in_set(<span class="string">&#x27;at&#x27;</span>,<span class="string">&#x27;ef,ab,de&#x27;</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<h3 id="复合类型构建操作"><a href="#复合类型构建操作" class="headerlink" title="复合类型构建操作"></a>复合类型构建操作</h3><ul>
<li>Map类型构建: map</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: map (key1, value1, key2, value2, …)</span><br><span class="line">说明：根据输入的key和<span class="keyword">value</span>对构建map类型</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">Create</span> <span class="keyword">table</span> mapTable <span class="keyword">as</span> <span class="keyword">select</span> map(<span class="string">&#x27;100&#x27;</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;200&#x27;</span>,<span class="string">&#x27;mary&#x27;</span>) <span class="keyword">as</span> t <span class="keyword">from</span> tableName;</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">describe</span> mapTable;</span><br><span class="line">t       map<span class="operator">&lt;</span>string ,string<span class="operator">&gt;</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> t <span class="keyword">from</span> tableName;</span><br><span class="line">&#123;&quot;100&quot;:&quot;tom&quot;,&quot;200&quot;:&quot;mary&quot;&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>Struct类型构建: struct</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: struct(val1, val2, val3, …)</span><br><span class="line">说明：根据输入的参数构建结构体struct类型</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> struct_table <span class="keyword">as</span> <span class="keyword">select</span> struct(<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;mary&#x27;</span>,<span class="string">&#x27;tim&#x27;</span>) <span class="keyword">as</span> t <span class="keyword">from</span> tableName;</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">describe</span> struct_table;</span><br><span class="line">t       struct<span class="operator">&lt;</span>col1:string ,col2:string,col3:string<span class="operator">&gt;</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> t <span class="keyword">from</span> tableName;</span><br><span class="line">&#123;&quot;col1&quot;:&quot;tom&quot;,&quot;col2&quot;:&quot;mary&quot;,&quot;col3&quot;:&quot;tim&quot;&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>array类型构建: array</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: <span class="keyword">array</span>(val1, val2, …)</span><br><span class="line">说明：根据输入的参数构建数组<span class="keyword">array</span>类型</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> arr_table <span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">array</span>(&quot;tom&quot;,&quot;mary&quot;,&quot;tim&quot;) <span class="keyword">as</span> t <span class="keyword">from</span> tableName;</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">describe</span> tableName;</span><br><span class="line">t       <span class="keyword">array</span><span class="operator">&lt;</span>string<span class="operator">&gt;</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> t <span class="keyword">from</span> tableName;</span><br><span class="line">[&quot;tom&quot;,&quot;mary&quot;,&quot;tim&quot;]</span><br></pre></td></tr></table></figure></div>

<h3 id="复杂类型访问操作"><a href="#复杂类型访问操作" class="headerlink" title="复杂类型访问操作"></a>复杂类型访问操作</h3><ul>
<li><ol>
<li>array类型访问: A[n]</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: A[n]</span><br><span class="line">操作类型: A为<span class="keyword">array</span>类型，n为<span class="type">int</span>类型</span><br><span class="line">说明：返回数组A中的第n个变量值。数组的起始下标为<span class="number">0</span>。比如，A是个值为[<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>]的数组类型，那么A[<span class="number">0</span>]将返回<span class="string">&#x27;foo&#x27;</span>,而A[<span class="number">1</span>]将返回<span class="string">&#x27;bar&#x27;</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> arr_table2 <span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">array</span>(&quot;tom&quot;,&quot;mary&quot;,&quot;tim&quot;) <span class="keyword">as</span> t</span><br><span class="line"> <span class="keyword">from</span> tableName;</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> t[<span class="number">0</span>],t[<span class="number">1</span>] <span class="keyword">from</span> arr_table2;</span><br><span class="line">tom     mary    tim</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>map类型访问: M[key]</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: M[key]</span><br><span class="line">操作类型: M为map类型，key为map中的key值</span><br><span class="line">说明：返回map类型M中，key值为指定值的<span class="keyword">value</span>值。比如，M是值为&#123;<span class="string">&#x27;f&#x27;</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;b&#x27;</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;all&#x27;</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;foobar&#x27;</span>&#125;的map类型，那么M[<span class="string">&#x27;all&#x27;</span>]将会返回<span class="string">&#x27;foobar&#x27;</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">Create</span> <span class="keyword">table</span> map_table2 <span class="keyword">as</span> <span class="keyword">select</span> map(<span class="string">&#x27;100&#x27;</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;200&#x27;</span>,<span class="string">&#x27;mary&#x27;</span>) <span class="keyword">as</span> t <span class="keyword">from</span> tableName;</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> t[<span class="string">&#x27;200&#x27;</span>],t[<span class="string">&#x27;100&#x27;</span>] <span class="keyword">from</span> map_table2;</span><br><span class="line">mary    tom</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>struct类型访问: S.x</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: S.x</span><br><span class="line">操作类型: S为struct类型</span><br><span class="line">说明：返回结构体S中的x字段。比如，对于结构体struct foobar &#123;<span class="type">int</span> foo, <span class="type">int</span> bar&#125;，foobar.foo返回结构体中的foo字段</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> str_table2 <span class="keyword">as</span> <span class="keyword">select</span> struct(<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;mary&#x27;</span>,<span class="string">&#x27;tim&#x27;</span>) <span class="keyword">as</span> t <span class="keyword">from</span> tableName;</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">describe</span> tableName;</span><br><span class="line">t       struct<span class="operator">&lt;</span>col1:string ,col2:string,col3:string<span class="operator">&gt;</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> t.col1,t.col3 <span class="keyword">from</span> str_table2;</span><br><span class="line">tom     tim</span><br></pre></td></tr></table></figure></div>

<h3 id="复杂类型长度统计函数"><a href="#复杂类型长度统计函数" class="headerlink" title="复杂类型长度统计函数"></a>复杂类型长度统计函数</h3><ul>
<li><ol>
<li>Map类型长度函数: size(Map&lt;k .V&gt;)</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: size(Map<span class="operator">&lt;</span>k .V<span class="operator">&gt;</span>)</span><br><span class="line">返回值: <span class="type">int</span></span><br><span class="line">说明: 返回map类型的长度</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> size(t) <span class="keyword">from</span> map_table2;</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>array类型长度函数: size(Array)</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">语法: size(<span class="keyword">Array</span><span class="operator">&lt;</span>T<span class="operator">&gt;</span>)</span><br><span class="line">返回值: <span class="type">int</span></span><br><span class="line">说明: 返回<span class="keyword">array</span>类型的长度</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> size(t) <span class="keyword">from</span> arr_table2;</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>类型转换函数  ***</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">类型转换函数: cast</span><br><span class="line">语法: <span class="built_in">cast</span>(expr <span class="keyword">as</span> <span class="operator">&lt;</span>type<span class="operator">&gt;</span>)</span><br><span class="line">返回值: Expected &quot;=&quot; <span class="keyword">to</span> follow &quot;type&quot;</span><br><span class="line">说明: 返回转换后的数据类型</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">cast</span>(<span class="string">&#x27;1&#x27;</span> <span class="keyword">as</span> <span class="type">bigint</span>) <span class="keyword">from</span> tableName;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<h2 id="hive当中的lateral-view-与-explode以及reflect和窗口函数"><a href="#hive当中的lateral-view-与-explode以及reflect和窗口函数" class="headerlink" title="hive当中的lateral view 与 explode以及reflect和窗口函数"></a>hive当中的lateral view 与 explode以及reflect和窗口函数</h2><h3 id="使用explode函数将hive表中的Map和Array字段数据进行拆分"><a href="#使用explode函数将hive表中的Map和Array字段数据进行拆分" class="headerlink" title="使用explode函数将hive表中的Map和Array字段数据进行拆分"></a>使用explode函数将hive表中的Map和Array字段数据进行拆分</h3><p>​	lateral view用于和split、explode等UDTF一起使用的，能将一行数据拆分成多行数据，在此基础上可以对拆分的数据进行聚合，lateral view首先为原始表的每行调用UDTF，UDTF会把一行拆分成一行或者多行，lateral view在把结果组合，产生一个支持别名表的虚拟表。</p>
<p>​	其中explode还可以用于将hive一列中复杂的array或者map结构拆分成多行</p>
<p>需求：现在有数据格式如下</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">zhangsan	child1,child2,child3,child4	k1:v1,k2:v2</span><br><span class="line"></span><br><span class="line">lisi	child5,child6,child7,child8	k3:v3,k4:v4</span><br></pre></td></tr></table></figure></div>

<p>​	字段之间使用\t分割，需求将所有的child进行拆开成为一列</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----------+--+</span></span><br><span class="line"><span class="operator">|</span> mychild  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+--+</span></span><br><span class="line"><span class="operator">|</span> child1   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> child2   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> child3   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> child4   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> child5   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> child6   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> child7   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> child8   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+--+</span></span><br></pre></td></tr></table></figure></div>

<p>​	将map的key和value也进行拆开，成为如下结果</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-----------+-------------+--+</span></span><br><span class="line"><span class="operator">|</span> mymapkey  <span class="operator">|</span> mymapvalue  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------------+--+</span></span><br><span class="line"><span class="operator">|</span> k1        <span class="operator">|</span> v1          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> k2        <span class="operator">|</span> v2          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> k3        <span class="operator">|</span> v3          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> k4        <span class="operator">|</span> v4          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------------+--+</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>创建hive数据库</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">创建hive数据库</span><br><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">create</span> database hive_explode;</span><br><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> use hive_explode;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>创建hive表，然后使用explode拆分map和array</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">hive (hive_explode)<span class="operator">&gt;</span> <span class="keyword">create</span>  <span class="keyword">table</span> t3(name string,children <span class="keyword">array</span><span class="operator">&lt;</span>string<span class="operator">&gt;</span>,address Map<span class="operator">&lt;</span>string,string<span class="operator">&gt;</span>) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span>  collection items terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> map keys terminated <span class="keyword">by</span> <span class="string">&#x27;:&#x27;</span> stored <span class="keyword">as</span> textFile;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>加载数据</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">node03执行以下命令创建表数据文件</span><br><span class="line">	mkdir <span class="operator">-</span>p <span class="operator">/</span>export<span class="operator">/</span>servers<span class="operator">/</span>hivedatas<span class="operator">/</span></span><br><span class="line">	cd <span class="operator">/</span>export<span class="operator">/</span>servers<span class="operator">/</span>hivedatas<span class="operator">/</span></span><br><span class="line">	vim maparray</span><br><span class="line">内容如下:</span><br><span class="line">zhangsan	child1,child2,child3,child4	k1:v1,k2:v2</span><br><span class="line">lisi	child5,child6,child7,child8	k3:v3,k4:v4</span><br><span class="line"></span><br><span class="line">hive表当中加载数据</span><br><span class="line">hive (hive_explode)<span class="operator">&gt;</span> load data <span class="keyword">local</span> inpath <span class="string">&#x27;/export/servers/hivedatas/maparray&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> t3;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>使用explode将hive当中数据拆开</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">将<span class="keyword">array</span>当中的数据拆分开</span><br><span class="line">hive (hive_explode)<span class="operator">&gt;</span> <span class="keyword">SELECT</span> explode(children) <span class="keyword">AS</span> myChild <span class="keyword">FROM</span> t3;</span><br><span class="line"></span><br><span class="line">将map当中的数据拆分开</span><br><span class="line"></span><br><span class="line">hive (hive_explode)<span class="operator">&gt;</span> <span class="keyword">SELECT</span> explode(address) <span class="keyword">AS</span> (myMapKey, myMapValue) <span class="keyword">FROM</span> t3;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用explode拆分json字符串"><a href="#使用explode拆分json字符串" class="headerlink" title="使用explode拆分json字符串"></a>使用explode拆分json字符串</h3><p>需求: 需求：现在有一些数据格式如下：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">a:shandong,b:beijing,c:hebei<span class="operator">|</span><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span><span class="operator">|</span>[&#123;&quot;source&quot;:&quot;7fresh&quot;,&quot;monthSales&quot;:<span class="number">4900</span>,&quot;userCount&quot;:<span class="number">1900</span>,&quot;score&quot;:&quot;9.9&quot;&#125;,&#123;&quot;source&quot;:&quot;jd&quot;,&quot;monthSales&quot;:<span class="number">2090</span>,&quot;userCount&quot;:<span class="number">78981</span>,&quot;score&quot;:&quot;9.8&quot;&#125;,&#123;&quot;source&quot;:&quot;jdmart&quot;,&quot;monthSales&quot;:<span class="number">6987</span>,&quot;userCount&quot;:<span class="number">1600</span>,&quot;score&quot;:&quot;9.0&quot;&#125;]</span><br></pre></td></tr></table></figure></div>

<p>其中字段与字段之间的分隔符是 |</p>
<p>我们要解析得到所有的monthSales对应的值为以下这一列（行转列）</p>
<p>4900</p>
<p>2090</p>
<p>6987</p>
<ul>
<li><ol>
<li>创建hive表</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">hive (hive_explode)<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> explode_lateral_view</span><br><span class="line">                   <span class="operator">&gt;</span> (`area` string,</span><br><span class="line">                   <span class="operator">&gt;</span> `goods_id` string,</span><br><span class="line">                   <span class="operator">&gt;</span> `sale_info` string)</span><br><span class="line">                   <span class="operator">&gt;</span> <span class="type">ROW</span> FORMAT DELIMITED</span><br><span class="line">                   <span class="operator">&gt;</span> FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;|&#x27;</span></span><br><span class="line">                   <span class="operator">&gt;</span> STORED <span class="keyword">AS</span> textfile;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>准备数据并加载数据</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">准备数据如下</span><br><span class="line">cd <span class="operator">/</span>export<span class="operator">/</span>servers<span class="operator">/</span>hivedatas</span><br><span class="line">vim explode_json</span><br><span class="line"></span><br><span class="line">a:shandong,b:beijing,c:hebei<span class="operator">|</span><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span><span class="operator">|</span>[&#123;&quot;source&quot;:&quot;7fresh&quot;,&quot;monthSales&quot;:<span class="number">4900</span>,&quot;userCount&quot;:<span class="number">1900</span>,&quot;score&quot;:&quot;9.9&quot;&#125;,&#123;&quot;source&quot;:&quot;jd&quot;,&quot;monthSales&quot;:<span class="number">2090</span>,&quot;userCount&quot;:<span class="number">78981</span>,&quot;score&quot;:&quot;9.8&quot;&#125;,&#123;&quot;source&quot;:&quot;jdmart&quot;,&quot;monthSales&quot;:<span class="number">6987</span>,&quot;userCount&quot;:<span class="number">1600</span>,&quot;score&quot;:&quot;9.0&quot;&#125;]</span><br><span class="line"></span><br><span class="line">加载数据到hive表当中去</span><br><span class="line">hive (hive_explode)<span class="operator">&gt;</span> load data <span class="keyword">local</span> inpath <span class="string">&#x27;/export/servers/hivedatas/explode_json&#x27;</span> overwrite <span class="keyword">into</span> <span class="keyword">table</span> explode_lateral_view;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>使用explode拆分Array</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">hive (hive_explode)<span class="operator">&gt;</span> <span class="keyword">select</span> explode(split(goods_id,<span class="string">&#x27;,&#x27;</span>)) <span class="keyword">as</span> goods_id <span class="keyword">from</span> explode_lateral_view;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>使用explode拆解Map</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">hive (hive_explode)<span class="operator">&gt;</span> <span class="keyword">select</span> explode(split(area,<span class="string">&#x27;,&#x27;</span>)) <span class="keyword">as</span> area <span class="keyword">from</span> explode_lateral_view;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>拆解json字段</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">hive (hive_explode)<span class="operator">&gt;</span> <span class="keyword">select</span> explode(split(regexp_replace(regexp_replace(sale_info,<span class="string">&#x27;\\[\\&#123;&#x27;</span>,<span class="string">&#x27;&#x27;</span>),<span class="string">&#x27;&#125;]&#x27;</span>,<span class="string">&#x27;&#x27;</span>),<span class="string">&#x27;&#125;,\\&#123;&#x27;</span>)) <span class="keyword">as</span>  sale_info <span class="keyword">from</span> explode_lateral_view;</span><br><span class="line"></span><br><span class="line">然后我们想用get_json_object来获取key为monthSales的数据：</span><br><span class="line"></span><br><span class="line">hive (hive_explode)<span class="operator">&gt;</span> <span class="keyword">select</span> get_json_object(explode(split(regexp_replace(regexp_replace(sale_info,<span class="string">&#x27;\\[\\&#123;&#x27;</span>,<span class="string">&#x27;&#x27;</span>),<span class="string">&#x27;&#125;]&#x27;</span>,<span class="string">&#x27;&#x27;</span>),<span class="string">&#x27;&#125;,\\&#123;&#x27;</span>)),<span class="string">&#x27;$.monthSales&#x27;</span>) <span class="keyword">as</span>  sale_info <span class="keyword">from</span> explode_lateral_view;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">然后挂了FAILED: SemanticException [Error <span class="number">10081</span>]: UDTF<span class="string">&#x27;s are not supported outside the SELECT clause, nor nested in expressions</span></span><br><span class="line"><span class="string">UDTF explode不能写在别的函数内</span></span><br><span class="line"><span class="string">如果你这么写，想查两个字段，select explode(split(area,&#x27;</span>,<span class="string">&#x27;)) as area,good_id from explode_lateral_view;</span></span><br><span class="line"><span class="string">会报错FAILED: SemanticException 1:40 Only a single expression in the SELECT clause is supported with UDTF&#x27;</span>s. Error encountered near token <span class="string">&#x27;good_id&#x27;</span></span><br><span class="line">使用UDTF的时候，只支持一个字段，这时候就需要<span class="keyword">LATERAL</span> <span class="keyword">VIEW</span>出场了</span><br></pre></td></tr></table></figure></div>

<h3 id="配合LATERAL-VIEW使用"><a href="#配合LATERAL-VIEW使用" class="headerlink" title="配合LATERAL  VIEW使用"></a>配合LATERAL  VIEW使用</h3><p>​	配合lateral view查询多个字段</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">hive (hive_explode)<span class="operator">&gt;</span> <span class="keyword">select</span> goods_id2,sale_info <span class="keyword">from</span> explode_lateral_view <span class="keyword">LATERAL</span> <span class="keyword">VIEW</span> explode(split(goods_id,<span class="string">&#x27;,&#x27;</span>))goods <span class="keyword">as</span> goods_id2;</span><br><span class="line"></span><br><span class="line">其中<span class="keyword">LATERAL</span> <span class="keyword">VIEW</span> explode(split(goods_id,<span class="string">&#x27;,&#x27;</span>))goods相当于一个虚拟表，与原表explode_lateral_view笛卡尔积关联</span><br></pre></td></tr></table></figure></div>

<p>​	也可以多重使用</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">hive (hive_explode)<span class="operator">&gt;</span> <span class="keyword">select</span> goods_id2,sale_info,area2</span><br><span class="line">                    <span class="keyword">from</span> explode_lateral_view </span><br><span class="line">                    <span class="keyword">LATERAL</span> <span class="keyword">VIEW</span> explode(split(goods_id,<span class="string">&#x27;,&#x27;</span>))goods <span class="keyword">as</span> goods_id2 </span><br><span class="line">                    <span class="keyword">LATERAL</span> <span class="keyword">VIEW</span> explode(split(area,<span class="string">&#x27;,&#x27;</span>))area <span class="keyword">as</span> area2;也是三个表笛卡尔积的结果</span><br></pre></td></tr></table></figure></div>

<p>最终，我们可以通过下面的句子，把这个json格式的一行数据，完全转换成二维表的方式展现</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">hive (hive_explode)<span class="operator">&gt;</span> <span class="keyword">select</span> get_json_object(concat(<span class="string">&#x27;&#123;&#x27;</span>,sale_info_1,<span class="string">&#x27;&#125;&#x27;</span>),<span class="string">&#x27;$.source&#x27;</span>) <span class="keyword">as</span> source,get_json_object(concat(<span class="string">&#x27;&#123;&#x27;</span>,sale_info_1,<span class="string">&#x27;&#125;&#x27;</span>),<span class="string">&#x27;$.monthSales&#x27;</span>) <span class="keyword">as</span> monthSales,get_json_object(concat(<span class="string">&#x27;&#123;&#x27;</span>,sale_info_1,<span class="string">&#x27;&#125;&#x27;</span>),<span class="string">&#x27;$.userCount&#x27;</span>) <span class="keyword">as</span> monthSales,get_json_object(concat(<span class="string">&#x27;&#123;&#x27;</span>,sale_info_1,<span class="string">&#x27;&#125;&#x27;</span>),<span class="string">&#x27;$.score&#x27;</span>) <span class="keyword">as</span> monthSales <span class="keyword">from</span> explode_lateral_view <span class="keyword">LATERAL</span> <span class="keyword">VIEW</span> explode(split(regexp_replace(regexp_replace(sale_info,<span class="string">&#x27;\\[\\&#123;&#x27;</span>,<span class="string">&#x27;&#x27;</span>),<span class="string">&#x27;&#125;]&#x27;</span>,<span class="string">&#x27;&#x27;</span>),<span class="string">&#x27;&#125;,\\&#123;&#x27;</span>))sale_info <span class="keyword">as</span> sale_info_1;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<p>Lateral View通常和UDTF一起出现，为了解决UDTF不允许在select字段的问题。 Multiple Lateral View可以实现类似笛卡尔乘积。 Outer关键字可以把不输出的UDTF的空结果，输出成NULL，防止丢失数据。</p>
<h3 id="行转列"><a href="#行转列" class="headerlink" title="行转列"></a>行转列</h3><p>相关参数说明:</p>
<p>​	CONCAT(string A&#x2F;col, string B&#x2F;col…)：返回输入字符串连接后的结果，支持任意个输入字符串;</p>
<p>​	CONCAT_WS(separator, str1, str2,…)：它是一个特殊形式的 CONCAT()。第一个参数剩余参数间的分隔符。分隔符可以是与剩余参数一样的字符串。如果分隔符是 NULL，返回值也将为 NULL。这个函数会跳过分隔符参数后的任何 NULL 和空字符串。分隔符将被加到被连接的字符串之间;</p>
<p>​	COLLECT_SET(col)：函数只接受基本数据类型，它的主要作用是将某字段的值进行去重汇总，产生array类型字段。</p>
<p>数据准备:</p>
<table>
<thead>
<tr>
<th>name</th>
<th>constellation</th>
<th>blood_type</th>
</tr>
</thead>
<tbody><tr>
<td>孙悟空</td>
<td>白羊座</td>
<td>A</td>
</tr>
<tr>
<td>老王</td>
<td>射手座</td>
<td>A</td>
</tr>
<tr>
<td>宋宋</td>
<td>白羊座</td>
<td>B</td>
</tr>
<tr>
<td>猪八戒</td>
<td>白羊座</td>
<td>A</td>
</tr>
<tr>
<td>凤姐</td>
<td>射手座</td>
<td>A</td>
</tr>
</tbody></table>
<p>需求: 把星座和血型一样的人归类到一起。结果如下：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">射手座,A            老王<span class="operator">|</span>凤姐</span><br><span class="line">白羊座,A            孙悟空<span class="operator">|</span>猪八戒</span><br><span class="line">白羊座,B            宋宋</span><br></pre></td></tr></table></figure></div>

<p>实现步骤:</p>
<ul>
<li><ol>
<li>创建本地constellation.txt，导入数据</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">node03服务器执行以下命令创建文件，注意数据使用\t进行分割</span><br><span class="line">cd <span class="operator">/</span>export<span class="operator">/</span>servers<span class="operator">/</span>hivedatas</span><br><span class="line">vim constellation.txt</span><br><span class="line"></span><br><span class="line">数据如下: </span><br><span class="line">孙悟空	白羊座	A</span><br><span class="line">老王	射手座	A</span><br><span class="line">宋宋	白羊座	B       </span><br><span class="line">猪八戒	白羊座	A</span><br><span class="line">凤姐	射手座	A</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>创建hive表并导入数据</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">创建hive表并加载数据</span><br><span class="line">hive (hive_explode)<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> person_info(</span><br><span class="line">                    name string, </span><br><span class="line">                    constellation string, </span><br><span class="line">                    blood_type string) </span><br><span class="line">                    <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> &quot;\t&quot;;</span><br><span class="line">                    </span><br><span class="line">加载数据</span><br><span class="line">hive (hive_explode)<span class="operator">&gt;</span> load data <span class="keyword">local</span> inpath <span class="string">&#x27;/export/servers/hivedatas/constellation.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> person_info;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>按需求查询数据</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">hive (hive_explode)<span class="operator">&gt;</span> <span class="keyword">select</span></span><br><span class="line">                        t1.base,</span><br><span class="line">                        concat_ws(<span class="string">&#x27;|&#x27;</span>, collect_set(t1.name)) name</span><br><span class="line">                    <span class="keyword">from</span></span><br><span class="line">                        (<span class="keyword">select</span></span><br><span class="line">                            name,</span><br><span class="line">                            concat(constellation, &quot;,&quot; , blood_type) base</span><br><span class="line">                        <span class="keyword">from</span></span><br><span class="line">                            person_info) t1</span><br><span class="line">                    <span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">                        t1.base;</span><br></pre></td></tr></table></figure></div>

<h3 id="列转行"><a href="#列转行" class="headerlink" title="列转行"></a>列转行</h3><p>所需函数:</p>
<p>​	EXPLODE(col)：将hive一列中复杂的array或者map结构拆分成多行。</p>
<p>​	LATERAL VIEW</p>
<p>​		用法：LATERAL VIEW udtf(expression) tableAlias AS columnAlias</p>
<p>​		解释：用于和split, explode等UDTF一起使用，它能够将一列数据拆成多行数据，在此基础上可以对拆分后的数据进行聚合。</p>
<p>数据准备:</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">cd <span class="operator">/</span>export<span class="operator">/</span>servers<span class="operator">/</span>hivedatas</span><br><span class="line">vim movie.txt</span><br><span class="line">文件内容如下:  数据字段之间使用\t进行分割</span><br><span class="line">《疑犯追踪》	悬疑,动作,科幻,剧情</span><br><span class="line">《Lie <span class="keyword">to</span> me》	悬疑,警匪,动作,心理,剧情</span><br><span class="line">《战狼<span class="number">2</span>》	战争,动作,灾难</span><br></pre></td></tr></table></figure></div>

<p>需求: 将电影分类中的数组数据展开。结果如下：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">《疑犯追踪》	悬疑</span><br><span class="line">《疑犯追踪》	动作</span><br><span class="line">《疑犯追踪》	科幻</span><br><span class="line">《疑犯追踪》	剧情</span><br><span class="line">《Lie <span class="keyword">to</span> me》	悬疑</span><br><span class="line">《Lie <span class="keyword">to</span> me》	警匪</span><br><span class="line">《Lie <span class="keyword">to</span> me》	动作</span><br><span class="line">《Lie <span class="keyword">to</span> me》	心理</span><br><span class="line">《Lie <span class="keyword">to</span> me》	剧情</span><br><span class="line">《战狼<span class="number">2</span>》	战争</span><br><span class="line">《战狼<span class="number">2</span>》	动作</span><br><span class="line">《战狼<span class="number">2</span>》	灾难</span><br></pre></td></tr></table></figure></div>

<p>实现步骤:</p>
<ul>
<li><ol>
<li>创建hive表</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> movie_info(</span><br><span class="line">    movie string, </span><br><span class="line">    category <span class="keyword">array</span><span class="operator">&lt;</span>string<span class="operator">&gt;</span>) </span><br><span class="line"><span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> &quot;\t&quot;</span><br><span class="line">collection items terminated <span class="keyword">by</span> &quot;,&quot;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>加载数据</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">load data <span class="keyword">local</span> inpath &quot;/export/servers/hivedatas/movie.txt&quot; <span class="keyword">into</span> <span class="keyword">table</span> movie_info;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>按需求查询数据</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    movie,</span><br><span class="line">    category_name</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">    movie_info <span class="keyword">lateral</span> <span class="keyword">view</span> explode(category) table_tmp <span class="keyword">as</span> category_name;</span><br></pre></td></tr></table></figure></div>

<h3 id="reflect函数"><a href="#reflect函数" class="headerlink" title="reflect函数"></a>reflect函数</h3><p>​	reflect函数可以支持在sql中调用java中的自带函数，秒杀一切udf函数。</p>
<p>需求1: 使用java.lang.Math当中的Max求两列中最大值</p>
<p>实现步骤:</p>
<ul>
<li><ol>
<li>创建hive表</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_udf(col1 <span class="type">int</span>,col2 <span class="type">int</span>) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>准备数据并加载数据</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">cd <span class="operator">/</span>export<span class="operator">/</span>servers<span class="operator">/</span>hivedatas</span><br><span class="line">vim test_udf </span><br><span class="line"></span><br><span class="line">文件内容如下:</span><br><span class="line"><span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="number">4</span>,<span class="number">3</span></span><br><span class="line"><span class="number">6</span>,<span class="number">4</span></span><br><span class="line"><span class="number">7</span>,<span class="number">5</span></span><br><span class="line"><span class="number">5</span>,<span class="number">6</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>加载数据</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">hive (hive_explode)<span class="operator">&gt;</span> load data <span class="keyword">local</span> inpath <span class="string">&#x27;/export/servers/hivedatas/test_udf&#x27;</span> overwrite <span class="keyword">into</span> <span class="keyword">table</span> test_udf;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>使用java.lang.Math当中的Max求两列当中的最大值</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">hive (hive_explode)<span class="operator">&gt;</span> <span class="keyword">select</span> reflect(&quot;java.lang.Math&quot;,&quot;max&quot;,col1,col2) <span class="keyword">from</span> test_udf;</span><br></pre></td></tr></table></figure></div>

<p>需求2: 文件中不同的记录来执行不同的java的内置函数</p>
<p>实现步骤:</p>
<ul>
<li><ol>
<li>创建hive表</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">hive (hive_explode)<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> test_udf2(class_name string,method_name string,col1 <span class="type">int</span> , col2 <span class="type">int</span>) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>准备数据</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">cd <span class="operator">/</span>export<span class="operator">/</span>servers<span class="operator">/</span>hivedatas</span><br><span class="line">vim test_udf2</span><br><span class="line"></span><br><span class="line">文件内容如下:</span><br><span class="line">java.lang.Math,min,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">java.lang.Math,max,<span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>加载数据</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">hive (hive_explode)<span class="operator">&gt;</span> load data <span class="keyword">local</span> inpath <span class="string">&#x27;/export/servers/hivedatas/test_udf2&#x27;</span> overwrite <span class="keyword">into</span> <span class="keyword">table</span> test_udf2;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><ol>
<li>执行查询</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">hive (hive_explode)<span class="operator">&gt;</span> <span class="keyword">select</span> reflect(class_name,method_name,col1,col2) <span class="keyword">from</span> test_udf2;</span><br></pre></td></tr></table></figure></div>

<p>需求3: 判断是否为数字</p>
<p>实现方式:</p>
<p>​	使用apache commons中的函数，commons下的jar已经包含在hadoop的classpath中，所以可以直接使用。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> reflect(&quot;org.apache.commons.lang.math.NumberUtils&quot;,&quot;isNumber&quot;,&quot;123&quot;)</span><br></pre></td></tr></table></figure></div>

<h2 id="窗口函数与分析函数"><a href="#窗口函数与分析函数" class="headerlink" title="窗口函数与分析函数"></a>窗口函数与分析函数</h2><p>在sql中有一类函数叫做聚合函数,例如sum()、avg()、max()等等,这类函数可以将多行数据按照规则聚集为一行,一般来讲聚集后的行数是要少于聚集前的行数的。但是有时我们想要既显示聚集前的数据,又要显示聚集后的数据,这时我们便引入了窗口函数。窗口函数又叫OLAP函数&#x2F;分析函数，窗口函数兼具分组和排序功能。</p>
<p>窗口函数最重要的关键字是 <strong>partition by</strong> 和 <strong>order by。</strong></p>
<p>具体语法如下：<strong>over (partition by xxx order by xxx)</strong></p>
<h3 id="sum、avg、min、max"><a href="#sum、avg、min、max" class="headerlink" title="sum、avg、min、max"></a>sum、avg、min、max</h3><p>准备数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">建表语句:</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_t1(</span><br><span class="line">cookieid string,</span><br><span class="line">createtime string,   <span class="comment">--day </span></span><br><span class="line">pv <span class="type">int</span></span><br><span class="line">) <span class="type">row</span> format delimited </span><br><span class="line">fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"></span><br><span class="line">加载数据：</span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/root/hivedata/test_t1.dat&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> test_t1;</span><br><span class="line"></span><br><span class="line">cookie1,<span class="number">2020</span><span class="number">-04</span><span class="number">-10</span>,<span class="number">1</span></span><br><span class="line">cookie1,<span class="number">2020</span><span class="number">-04</span><span class="number">-11</span>,<span class="number">5</span></span><br><span class="line">cookie1,<span class="number">2020</span><span class="number">-04</span><span class="number">-12</span>,<span class="number">7</span></span><br><span class="line">cookie1,<span class="number">2020</span><span class="number">-04</span><span class="number">-13</span>,<span class="number">3</span></span><br><span class="line">cookie1,<span class="number">2020</span><span class="number">-04</span><span class="number">-14</span>,<span class="number">2</span></span><br><span class="line">cookie1,<span class="number">2020</span><span class="number">-04</span><span class="number">-15</span>,<span class="number">4</span></span><br><span class="line">cookie1,<span class="number">2020</span><span class="number">-04</span><span class="number">-16</span>,<span class="number">4</span></span><br><span class="line"></span><br><span class="line">开启智能本地模式</span><br><span class="line"><span class="keyword">SET</span> hive.exec.mode.local.auto<span class="operator">=</span><span class="literal">true</span>;</span><br></pre></td></tr></table></figure></div>

<p>SUM函数和窗口函数的配合使用：结果和ORDER BY相关,默认为升序。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> cookieid,createtime,pv,</span><br><span class="line"><span class="built_in">sum</span>(pv) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> cookieid <span class="keyword">order</span> <span class="keyword">by</span> createtime) <span class="keyword">as</span> pv1 </span><br><span class="line"><span class="keyword">from</span> test_t1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> cookieid,createtime,pv,</span><br><span class="line"><span class="built_in">sum</span>(pv) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> cookieid <span class="keyword">order</span> <span class="keyword">by</span> createtime <span class="keyword">rows</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span>) <span class="keyword">as</span> pv2</span><br><span class="line"><span class="keyword">from</span> test_t1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> cookieid,createtime,pv,</span><br><span class="line"><span class="built_in">sum</span>(pv) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> cookieid) <span class="keyword">as</span> pv3</span><br><span class="line"><span class="keyword">from</span> test_t1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> cookieid,createtime,pv,</span><br><span class="line"><span class="built_in">sum</span>(pv) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> cookieid <span class="keyword">order</span> <span class="keyword">by</span> createtime <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">3</span> preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span>) <span class="keyword">as</span> pv4</span><br><span class="line"><span class="keyword">from</span> test_t1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> cookieid,createtime,pv,</span><br><span class="line"><span class="built_in">sum</span>(pv) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> cookieid <span class="keyword">order</span> <span class="keyword">by</span> createtime <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">3</span> preceding <span class="keyword">and</span> <span class="number">1</span> following) <span class="keyword">as</span> pv5</span><br><span class="line"><span class="keyword">from</span> test_t1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> cookieid,createtime,pv,</span><br><span class="line"><span class="built_in">sum</span>(pv) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> cookieid <span class="keyword">order</span> <span class="keyword">by</span> createtime <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">current</span> <span class="type">row</span> <span class="keyword">and</span> unbounded following) <span class="keyword">as</span> pv6</span><br><span class="line"><span class="keyword">from</span> test_t1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pv1: 分组内从起点到当前行的pv累积，如，<span class="number">11</span>号的pv1<span class="operator">=</span><span class="number">10</span>号的pv<span class="operator">+</span><span class="number">11</span>号的pv, <span class="number">12</span>号<span class="operator">=</span><span class="number">10</span>号<span class="operator">+</span><span class="number">11</span>号<span class="operator">+</span><span class="number">12</span>号</span><br><span class="line">pv2: 同pv1</span><br><span class="line">pv3: 分组内(cookie1)所有的pv累加</span><br><span class="line">pv4: 分组内当前行<span class="operator">+</span>往前<span class="number">3</span>行，如，<span class="number">11</span>号<span class="operator">=</span><span class="number">10</span>号<span class="operator">+</span><span class="number">11</span>号， <span class="number">12</span>号<span class="operator">=</span><span class="number">10</span>号<span class="operator">+</span><span class="number">11</span>号<span class="operator">+</span><span class="number">12</span>号，</span><br><span class="line">	                       <span class="number">13</span>号<span class="operator">=</span><span class="number">10</span>号<span class="operator">+</span><span class="number">11</span>号<span class="operator">+</span><span class="number">12</span>号<span class="operator">+</span><span class="number">13</span>号， <span class="number">14</span>号<span class="operator">=</span><span class="number">11</span>号<span class="operator">+</span><span class="number">12</span>号<span class="operator">+</span><span class="number">13</span>号<span class="operator">+</span><span class="number">14</span>号</span><br><span class="line">pv5: 分组内当前行<span class="operator">+</span>往前<span class="number">3</span>行<span class="operator">+</span>往后<span class="number">1</span>行，如，<span class="number">14</span>号<span class="operator">=</span><span class="number">11</span>号<span class="operator">+</span><span class="number">12</span>号<span class="operator">+</span><span class="number">13</span>号<span class="operator">+</span><span class="number">14</span>号<span class="operator">+</span><span class="number">15</span>号<span class="operator">=</span><span class="number">5</span><span class="operator">+</span><span class="number">7</span><span class="operator">+</span><span class="number">3</span><span class="operator">+</span><span class="number">2</span><span class="operator">+</span><span class="number">4</span><span class="operator">=</span><span class="number">21</span></span><br><span class="line">pv6: 分组内当前行<span class="operator">+</span>往后所有行，如，<span class="number">13</span>号<span class="operator">=</span><span class="number">13</span>号<span class="operator">+</span><span class="number">14</span>号<span class="operator">+</span><span class="number">15</span>号<span class="operator">+</span><span class="number">16</span>号<span class="operator">=</span><span class="number">3</span><span class="operator">+</span><span class="number">2</span><span class="operator">+</span><span class="number">4</span><span class="operator">+</span><span class="number">4</span><span class="operator">=</span><span class="number">13</span>，</span><br><span class="line">							 <span class="number">14</span>号<span class="operator">=</span><span class="number">14</span>号<span class="operator">+</span><span class="number">15</span>号<span class="operator">+</span><span class="number">16</span>号<span class="operator">=</span><span class="number">2</span><span class="operator">+</span><span class="number">4</span><span class="operator">+</span><span class="number">4</span><span class="operator">=</span><span class="number">10</span></span><br></pre></td></tr></table></figure></div>

<p>​	如果不指定rows between,默认为从起点到当前行;</p>
<p>​	如果不指定order by，则将分组内所有值累加;</p>
<p>​	关键是理解rows between含义,也叫做window子句：</p>
<p>​		preceding：往前</p>
<p>​		following：往后</p>
<p>​		current row：当前行</p>
<p>​		unbounded：起点</p>
<p>​		unbounded preceding 表示从前面的起点</p>
<p>​		unbounded following：表示到后面的终点</p>
<p>​	AVG，MIN，MAX，和SUM用法一样。</p>
<h3 id="row-number、rank、dense-rank、ntile"><a href="#row-number、rank、dense-rank、ntile" class="headerlink" title="row_number、rank、dense_rank、ntile"></a>row_number、rank、dense_rank、ntile</h3><p>准备数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">cookie1,<span class="number">2020</span><span class="number">-04</span><span class="number">-10</span>,<span class="number">1</span></span><br><span class="line">cookie1,<span class="number">2020</span><span class="number">-04</span><span class="number">-11</span>,<span class="number">5</span></span><br><span class="line">cookie1,<span class="number">2020</span><span class="number">-04</span><span class="number">-12</span>,<span class="number">7</span></span><br><span class="line">cookie1,<span class="number">2020</span><span class="number">-04</span><span class="number">-13</span>,<span class="number">3</span></span><br><span class="line">cookie1,<span class="number">2020</span><span class="number">-04</span><span class="number">-14</span>,<span class="number">2</span></span><br><span class="line">cookie1,<span class="number">2020</span><span class="number">-04</span><span class="number">-15</span>,<span class="number">4</span></span><br><span class="line">cookie1,<span class="number">2020</span><span class="number">-04</span><span class="number">-16</span>,<span class="number">4</span></span><br><span class="line">cookie2,<span class="number">2020</span><span class="number">-04</span><span class="number">-10</span>,<span class="number">2</span></span><br><span class="line">cookie2,<span class="number">2020</span><span class="number">-04</span><span class="number">-11</span>,<span class="number">3</span></span><br><span class="line">cookie2,<span class="number">2020</span><span class="number">-04</span><span class="number">-12</span>,<span class="number">5</span></span><br><span class="line">cookie2,<span class="number">2020</span><span class="number">-04</span><span class="number">-13</span>,<span class="number">6</span></span><br><span class="line">cookie2,<span class="number">2020</span><span class="number">-04</span><span class="number">-14</span>,<span class="number">3</span></span><br><span class="line">cookie2,<span class="number">2020</span><span class="number">-04</span><span class="number">-15</span>,<span class="number">9</span></span><br><span class="line">cookie2,<span class="number">2020</span><span class="number">-04</span><span class="number">-16</span>,<span class="number">7</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_t2 (</span><br><span class="line">cookieid string,</span><br><span class="line">createtime string,   <span class="comment">--day </span></span><br><span class="line">pv <span class="type">INT</span></span><br><span class="line">) <span class="type">ROW</span> FORMAT DELIMITED </span><br><span class="line">FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span> </span><br><span class="line">stored <span class="keyword">as</span> textfile;</span><br><span class="line">  </span><br><span class="line">加载数据：</span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/root/hivedata/test_t2.dat&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> test_t2;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>ROW_NUMBER()使用</p>
<p>ROW_NUMBER()从1开始，按照顺序，生成分组内记录的序列。</p>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">cookieid,</span><br><span class="line">createtime,</span><br><span class="line">pv,</span><br><span class="line"><span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> pv <span class="keyword">desc</span>) <span class="keyword">AS</span> rn </span><br><span class="line"><span class="keyword">FROM</span> test_t2;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>RANK 和 DENSE_RANK使用</p>
<p>RANK() 生成数据项在分组中的排名，排名相等会在名次中留下空位 。</p>
<p>DENSE_RANK()生成数据项在分组中的排名，排名相等会在名次中不会留下空位。</p>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">cookieid,</span><br><span class="line">createtime,</span><br><span class="line">pv,</span><br><span class="line"><span class="built_in">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> pv <span class="keyword">desc</span>) <span class="keyword">AS</span> rn1,</span><br><span class="line"><span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> pv <span class="keyword">desc</span>) <span class="keyword">AS</span> rn2,</span><br><span class="line"><span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> pv <span class="keyword">DESC</span>) <span class="keyword">AS</span> rn3 </span><br><span class="line"><span class="keyword">FROM</span> test_t2 </span><br><span class="line"><span class="keyword">WHERE</span> cookieid <span class="operator">=</span> <span class="string">&#x27;cookie1&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>NTILE</p>
<p>有时会有这样的需求:如果数据排序后分为三部分，业务人员只关心其中的一部分，如何将这中间的三分之一数据拿出来呢?NTILE函数即可以满足。</p>
<p>ntile可以看成是：把有序的数据集合平均分配到指定的数量（num）个桶中, 将桶号分配给每一行。如果不能平均分配，则优先分配较小编号的桶，并且各个桶中能放的行数最多相差1。</p>
<p>然后可以根据桶号，选取前或后 n分之几的数据。数据会完整展示出来，只是给相应的数据打标签；具体要取几分之几的数据，需要再嵌套一层根据标签取出。</p>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">cookieid,</span><br><span class="line">createtime,</span><br><span class="line">pv,</span><br><span class="line"><span class="built_in">NTILE</span>(<span class="number">2</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime) <span class="keyword">AS</span> rn1,</span><br><span class="line"><span class="built_in">NTILE</span>(<span class="number">3</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime) <span class="keyword">AS</span> rn2,</span><br><span class="line"><span class="built_in">NTILE</span>(<span class="number">4</span>) <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime) <span class="keyword">AS</span> rn3</span><br><span class="line"><span class="keyword">FROM</span> test_t2 </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cookieid,createtime;</span><br></pre></td></tr></table></figure></div>

<h2 id="其他一些窗口函数"><a href="#其他一些窗口函数" class="headerlink" title="其他一些窗口函数"></a>其他一些窗口函数</h2><h3 id="lag-lead-first-value-last-value"><a href="#lag-lead-first-value-last-value" class="headerlink" title="lag,lead,first_value,last_value"></a>lag,lead,first_value,last_value</h3><ul>
<li>LAG<br> <strong>LAG(col,n,DEFAULT) 用于统计窗口内往上第n行值</strong>第一个参数为列名，第二个参数为往上第n行（可选，默认为1），第三个参数为默认值（当往上第n行为NULL时候，取默认值，如不指定，则为NULL）</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cookieid,</span><br><span class="line">createtime,</span><br><span class="line">url,</span><br><span class="line"><span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime) <span class="keyword">AS</span> rn,</span><br><span class="line"><span class="built_in">LAG</span>(createtime,<span class="number">1</span>,<span class="string">&#x27;1970-01-01 00:00:00&#x27;</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime) <span class="keyword">AS</span> last_1_time,</span><br><span class="line"><span class="built_in">LAG</span>(createtime,<span class="number">2</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime) <span class="keyword">AS</span> last_2_time </span><br><span class="line"><span class="keyword">FROM</span> test_t4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">last_1_time: 指定了往上第<span class="number">1</span>行的值，<span class="keyword">default</span>为<span class="string">&#x27;1970-01-01 00:00:00&#x27;</span>  </span><br><span class="line">             			 cookie1第一行，往上<span class="number">1</span>行为<span class="keyword">NULL</span>,因此取默认值 <span class="number">1970</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">             			 cookie1第三行，往上<span class="number">1</span>行值为第二行值，<span class="number">2015</span><span class="number">-04</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">02</span></span><br><span class="line">             			 cookie1第六行，往上<span class="number">1</span>行值为第五行值，<span class="number">2015</span><span class="number">-04</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">50</span>:<span class="number">01</span></span><br><span class="line">last_2_time: 指定了往上第<span class="number">2</span>行的值，为指定默认值</span><br><span class="line">  						 cookie1第一行，往上<span class="number">2</span>行为<span class="keyword">NULL</span></span><br><span class="line">  						 cookie1第二行，往上<span class="number">2</span>行为<span class="keyword">NULL</span></span><br><span class="line">  						 cookie1第四行，往上<span class="number">2</span>行为第二行值，<span class="number">2015</span><span class="number">-04</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">02</span></span><br><span class="line">  						 cookie1第七行，往上<span class="number">2</span>行为第五行值，<span class="number">2015</span><span class="number">-04</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">50</span>:<span class="number">01</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>LEAD</li>
</ul>
<p>与LAG相反 <strong>LEAD(col,n,DEFAULT) 用于统计窗口内往下第n行值</strong> 第一个参数为列名，第二个参数为往下第n行（可选，默认为1），第三个参数为默认值（当往下第n行为NULL时候，取默认值，如不指定，则为NULL）</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cookieid,</span><br><span class="line">createtime,</span><br><span class="line">url,</span><br><span class="line"><span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime) <span class="keyword">AS</span> rn,</span><br><span class="line"><span class="built_in">LEAD</span>(createtime,<span class="number">1</span>,<span class="string">&#x27;1970-01-01 00:00:00&#x27;</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime) <span class="keyword">AS</span> next_1_time,</span><br><span class="line"><span class="built_in">LEAD</span>(createtime,<span class="number">2</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime) <span class="keyword">AS</span> next_2_time </span><br><span class="line"><span class="keyword">FROM</span> test_t4;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>FIRST_VALUE</p>
<p>取分组内排序后，截止到当前行，第一个值</p>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cookieid,</span><br><span class="line">createtime,</span><br><span class="line">url,</span><br><span class="line"><span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime) <span class="keyword">AS</span> rn,</span><br><span class="line"><span class="built_in">FIRST_VALUE</span>(url) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime) <span class="keyword">AS</span> first1 </span><br><span class="line"><span class="keyword">FROM</span> test_t4;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>LAST_VALUE</li>
</ul>
<p>取分组内排序后，截止到当前行，最后一个值</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cookieid,</span><br><span class="line">createtime,</span><br><span class="line">url,</span><br><span class="line"><span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime) <span class="keyword">AS</span> rn,</span><br><span class="line"><span class="built_in">LAST_VALUE</span>(url) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime) <span class="keyword">AS</span> last1 </span><br><span class="line"><span class="keyword">FROM</span> test_t4;</span><br></pre></td></tr></table></figure></div>

<p>如果想要取分组内排序后最后一个值，则需要变通一下：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cookieid,</span><br><span class="line">createtime,</span><br><span class="line">url,</span><br><span class="line"><span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime) <span class="keyword">AS</span> rn,</span><br><span class="line"><span class="built_in">LAST_VALUE</span>(url) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime) <span class="keyword">AS</span> last1,</span><br><span class="line"><span class="built_in">FIRST_VALUE</span>(url) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime <span class="keyword">DESC</span>) <span class="keyword">AS</span> last2 </span><br><span class="line"><span class="keyword">FROM</span> test_t4 </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cookieid,createtime;</span><br></pre></td></tr></table></figure></div>

<p><strong>特别注意order  by</strong></p>
<p>如果不指定ORDER BY，则进行排序混乱，会出现错误的结果</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cookieid,</span><br><span class="line">createtime,</span><br><span class="line">url,</span><br><span class="line"><span class="built_in">FIRST_VALUE</span>(url) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid) <span class="keyword">AS</span> first2  </span><br><span class="line"><span class="keyword">FROM</span> test_t4;</span><br></pre></td></tr></table></figure></div>

<h3 id="cume-dist-percent-rank"><a href="#cume-dist-percent-rank" class="headerlink" title="cume_dist,percent_rank"></a>cume_dist,percent_rank</h3><p>这两个序列分析函数不是很常用，<strong>注意： 序列函数不支持WINDOW子句</strong></p>
<ul>
<li>数据准备</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">d1,user1,<span class="number">1000</span></span><br><span class="line">d1,user2,<span class="number">2000</span></span><br><span class="line">d1,user3,<span class="number">3000</span></span><br><span class="line">d2,user4,<span class="number">4000</span></span><br><span class="line">d2,user5,<span class="number">5000</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> test_t3 (</span><br><span class="line">dept STRING,</span><br><span class="line">userid string,</span><br><span class="line">sal <span class="type">INT</span></span><br><span class="line">) <span class="type">ROW</span> FORMAT DELIMITED </span><br><span class="line">FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span> </span><br><span class="line">stored <span class="keyword">as</span> textfile;</span><br><span class="line"></span><br><span class="line">加载数据：</span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/root/hivedata/test_t3.dat&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> test_t3;</span><br></pre></td></tr></table></figure></div>

<hr>
<ul>
<li><p>CUME_DIST  和order byd的排序顺序有关系</p>
<p>CUME_DIST 小于等于当前值的行数&#x2F;分组内总行数  order 默认顺序 正序 升序 比如，统计小于等于当前薪水的人数，所占总人数的比例</p>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"> dept,</span><br><span class="line"> userid,</span><br><span class="line"> sal,</span><br><span class="line"> <span class="built_in">CUME_DIST</span>() <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> sal) <span class="keyword">AS</span> rn1,</span><br><span class="line"> <span class="built_in">CUME_DIST</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> dept <span class="keyword">ORDER</span> <span class="keyword">BY</span> sal) <span class="keyword">AS</span> rn2 </span><br><span class="line"> <span class="keyword">FROM</span> test_t3;</span><br><span class="line"> </span><br><span class="line"> rn1: 没有<span class="keyword">partition</span>,所有数据均为<span class="number">1</span>组，总行数为<span class="number">5</span>，</span><br><span class="line">      第一行：小于等于<span class="number">1000</span>的行数为<span class="number">1</span>，因此，<span class="number">1</span><span class="operator">/</span><span class="number">5</span><span class="operator">=</span><span class="number">0.2</span></span><br><span class="line">      第三行：小于等于<span class="number">3000</span>的行数为<span class="number">3</span>，因此，<span class="number">3</span><span class="operator">/</span><span class="number">5</span><span class="operator">=</span><span class="number">0.6</span></span><br><span class="line"> rn2: 按照部门分组，dpet<span class="operator">=</span>d1的行数为<span class="number">3</span>,</span><br><span class="line">      第二行：小于等于<span class="number">2000</span>的行数为<span class="number">2</span>，因此，<span class="number">2</span><span class="operator">/</span><span class="number">3</span><span class="operator">=</span><span class="number">0.6666666666666666</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>PERCENT_RANK</p>
<p>PERCENT_RANK 分组内当前行的RANK值-1&#x2F;分组内总行数-1</p>
<p>经调研 该函数显示现实意义不明朗 有待于继续考证</p>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  dept,</span><br><span class="line">  userid,</span><br><span class="line">  sal,</span><br><span class="line">  <span class="built_in">PERCENT_RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> sal) <span class="keyword">AS</span> rn1,   <span class="comment">--分组内</span></span><br><span class="line">  <span class="built_in">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> sal) <span class="keyword">AS</span> rn11,          <span class="comment">--分组内RANK值</span></span><br><span class="line">  <span class="built_in">SUM</span>(<span class="number">1</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">NULL</span>) <span class="keyword">AS</span> rn12,     <span class="comment">--分组内总行数</span></span><br><span class="line">  <span class="built_in">PERCENT_RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> dept <span class="keyword">ORDER</span> <span class="keyword">BY</span> sal) <span class="keyword">AS</span> rn2 </span><br><span class="line">  <span class="keyword">FROM</span> test_t3;</span><br><span class="line">  </span><br><span class="line">  rn1: rn1 <span class="operator">=</span> (rn11<span class="number">-1</span>) <span class="operator">/</span> (rn12<span class="number">-1</span>) </span><br><span class="line">  	   第一行,(<span class="number">1</span><span class="number">-1</span>)<span class="operator">/</span>(<span class="number">5</span><span class="number">-1</span>)<span class="operator">=</span><span class="number">0</span><span class="operator">/</span><span class="number">4</span><span class="operator">=</span><span class="number">0</span></span><br><span class="line">  	   第二行,(<span class="number">2</span><span class="number">-1</span>)<span class="operator">/</span>(<span class="number">5</span><span class="number">-1</span>)<span class="operator">=</span><span class="number">1</span><span class="operator">/</span><span class="number">4</span><span class="operator">=</span><span class="number">0.25</span></span><br><span class="line">  	   第四行,(<span class="number">4</span><span class="number">-1</span>)<span class="operator">/</span>(<span class="number">5</span><span class="number">-1</span>)<span class="operator">=</span><span class="number">3</span><span class="operator">/</span><span class="number">4</span><span class="operator">=</span><span class="number">0.75</span></span><br><span class="line">  rn2: 按照dept分组，</span><br><span class="line">       dept<span class="operator">=</span>d1的总行数为<span class="number">3</span></span><br><span class="line">       第一行，(<span class="number">1</span><span class="number">-1</span>)<span class="operator">/</span>(<span class="number">3</span><span class="number">-1</span>)<span class="operator">=</span><span class="number">0</span></span><br><span class="line">       第三行，(<span class="number">3</span><span class="number">-1</span>)<span class="operator">/</span>(<span class="number">3</span><span class="number">-1</span>)<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<h3 id="grouping-sets-grouping-id-cube-rollup"><a href="#grouping-sets-grouping-id-cube-rollup" class="headerlink" title="grouping sets,grouping__id,cube,rollup"></a>grouping sets,grouping__id,cube,rollup</h3><p>​	这几个分析函数通常用于OLAP中，不能累加，而且需要根据不同维度上钻和下钻的指标统计，比如，分小时、天、月的UV数。</p>
<ul>
<li>数据准备</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-03</span>,<span class="number">2020</span><span class="number">-03</span><span class="number">-10</span>,cookie1</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span>,<span class="number">2020</span><span class="number">-03</span><span class="number">-10</span>,cookie5</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span>,<span class="number">2020</span><span class="number">-03</span><span class="number">-12</span>,cookie7</span><br><span class="line"><span class="number">2020</span><span class="number">-04</span>,<span class="number">2020</span><span class="number">-04</span><span class="number">-12</span>,cookie3</span><br><span class="line"><span class="number">2020</span><span class="number">-04</span>,<span class="number">2020</span><span class="number">-04</span><span class="number">-13</span>,cookie2</span><br><span class="line"><span class="number">2020</span><span class="number">-04</span>,<span class="number">2020</span><span class="number">-04</span><span class="number">-13</span>,cookie4</span><br><span class="line"><span class="number">2020</span><span class="number">-04</span>,<span class="number">2020</span><span class="number">-04</span><span class="number">-16</span>,cookie4</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span>,<span class="number">2020</span><span class="number">-03</span><span class="number">-10</span>,cookie2</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span>,<span class="number">2020</span><span class="number">-03</span><span class="number">-10</span>,cookie3</span><br><span class="line"><span class="number">2020</span><span class="number">-04</span>,<span class="number">2020</span><span class="number">-04</span><span class="number">-12</span>,cookie5</span><br><span class="line"><span class="number">2020</span><span class="number">-04</span>,<span class="number">2020</span><span class="number">-04</span><span class="number">-13</span>,cookie6</span><br><span class="line"><span class="number">2020</span><span class="number">-04</span>,<span class="number">2020</span><span class="number">-04</span><span class="number">-15</span>,cookie3</span><br><span class="line"><span class="number">2020</span><span class="number">-04</span>,<span class="number">2020</span><span class="number">-04</span><span class="number">-15</span>,cookie2</span><br><span class="line"><span class="number">2020</span><span class="number">-04</span>,<span class="number">2020</span><span class="number">-04</span><span class="number">-16</span>,cookie1</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_t5 (</span><br><span class="line"><span class="keyword">month</span> STRING,</span><br><span class="line"><span class="keyword">day</span> STRING, </span><br><span class="line">cookieid STRING </span><br><span class="line">) <span class="type">ROW</span> FORMAT DELIMITED </span><br><span class="line">FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span> </span><br><span class="line">stored <span class="keyword">as</span> textfile;</span><br><span class="line"></span><br><span class="line">加载数据：</span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/root/hivedata/test_t5.dat&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> test_t5;</span><br></pre></td></tr></table></figure></div>

<hr>
<ul>
<li>GROUPING SETS</li>
</ul>
<p>grouping sets是一种将多个group by 逻辑写在一个sql语句中的便利写法。</p>
<p>等价于将不同维度的GROUP BY结果集进行UNION ALL。</p>
<p><strong>GROUPING__ID</strong>，表示结果属于哪一个分组集合。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">month</span>,</span><br><span class="line"><span class="keyword">day</span>,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cookieid) <span class="keyword">AS</span> uv,</span><br><span class="line">GROUPING__ID </span><br><span class="line"><span class="keyword">FROM</span> test_t5 </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">month</span>,<span class="keyword">day</span> </span><br><span class="line"><span class="keyword">GROUPING</span> SETS (<span class="keyword">month</span>,<span class="keyword">day</span>) </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> GROUPING__ID;</span><br><span class="line"></span><br><span class="line">grouping_id表示这一组结果属于哪个分组集合，</span><br><span class="line">根据<span class="keyword">grouping</span> sets中的分组条件<span class="keyword">month</span>，<span class="keyword">day</span>，<span class="number">1</span>是代表<span class="keyword">month</span>，<span class="number">2</span>是代表<span class="keyword">day</span></span><br><span class="line"></span><br><span class="line">等价于 </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">month</span>,<span class="keyword">NULL</span>,<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cookieid) <span class="keyword">AS</span> uv,<span class="number">1</span> <span class="keyword">AS</span> GROUPING__ID <span class="keyword">FROM</span> test_t5 <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">month</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NULL</span> <span class="keyword">as</span> <span class="keyword">month</span>,<span class="keyword">day</span>,<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cookieid) <span class="keyword">AS</span> uv,<span class="number">2</span> <span class="keyword">AS</span> GROUPING__ID <span class="keyword">FROM</span> test_t5 <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">day</span>;</span><br></pre></td></tr></table></figure></div>

<p>再如：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">month</span>,</span><br><span class="line"><span class="keyword">day</span>,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cookieid) <span class="keyword">AS</span> uv,</span><br><span class="line">GROUPING__ID </span><br><span class="line"><span class="keyword">FROM</span> test_t5 </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">month</span>,<span class="keyword">day</span> </span><br><span class="line"><span class="keyword">GROUPING</span> SETS (<span class="keyword">month</span>,<span class="keyword">day</span>,(<span class="keyword">month</span>,<span class="keyword">day</span>)) </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> GROUPING__ID;</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">month</span>,<span class="keyword">NULL</span>,<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cookieid) <span class="keyword">AS</span> uv,<span class="number">1</span> <span class="keyword">AS</span> GROUPING__ID <span class="keyword">FROM</span> test_t5 <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">month</span> </span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NULL</span>,<span class="keyword">day</span>,<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cookieid) <span class="keyword">AS</span> uv,<span class="number">2</span> <span class="keyword">AS</span> GROUPING__ID <span class="keyword">FROM</span> test_t5 <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">day</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">month</span>,<span class="keyword">day</span>,<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cookieid) <span class="keyword">AS</span> uv,<span class="number">3</span> <span class="keyword">AS</span> GROUPING__ID <span class="keyword">FROM</span> test_t5 <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">month</span>,<span class="keyword">day</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>CUBE</li>
</ul>
<p>根据GROUP BY的维度的所有组合进行聚合。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">month</span>,</span><br><span class="line"><span class="keyword">day</span>,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cookieid) <span class="keyword">AS</span> uv,</span><br><span class="line">GROUPING__ID </span><br><span class="line"><span class="keyword">FROM</span> test_t5 </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">month</span>,<span class="keyword">day</span> </span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CUBE</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> GROUPING__ID;</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NULL</span>,<span class="keyword">NULL</span>,<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cookieid) <span class="keyword">AS</span> uv,<span class="number">0</span> <span class="keyword">AS</span> GROUPING__ID <span class="keyword">FROM</span> test_t5</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">month</span>,<span class="keyword">NULL</span>,<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cookieid) <span class="keyword">AS</span> uv,<span class="number">1</span> <span class="keyword">AS</span> GROUPING__ID <span class="keyword">FROM</span> test_t5 <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">month</span> </span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NULL</span>,<span class="keyword">day</span>,<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cookieid) <span class="keyword">AS</span> uv,<span class="number">2</span> <span class="keyword">AS</span> GROUPING__ID <span class="keyword">FROM</span> test_t5 <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">day</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">month</span>,<span class="keyword">day</span>,<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cookieid) <span class="keyword">AS</span> uv,<span class="number">3</span> <span class="keyword">AS</span> GROUPING__ID <span class="keyword">FROM</span> test_t5 <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">month</span>,<span class="keyword">day</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>ROLLUP</li>
</ul>
<p>是CUBE的子集，以最左侧的维度为主，从该维度进行层级聚合。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">比如，以<span class="keyword">month</span>维度进行层级聚合：</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">month</span>,</span><br><span class="line"><span class="keyword">day</span>,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cookieid) <span class="keyword">AS</span> uv,</span><br><span class="line">GROUPING__ID  </span><br><span class="line"><span class="keyword">FROM</span> test_t5 </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">month</span>,<span class="keyword">day</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">ROLLUP</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> GROUPING__ID;</span><br><span class="line"></span><br><span class="line"><span class="comment">--把month和day调换顺序，则以day维度进行层级聚合：</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">day</span>,</span><br><span class="line"><span class="keyword">month</span>,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cookieid) <span class="keyword">AS</span> uv,</span><br><span class="line">GROUPING__ID  </span><br><span class="line"><span class="keyword">FROM</span> test_t5 </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">day</span>,<span class="keyword">month</span> </span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">ROLLUP</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> GROUPING__ID;</span><br><span class="line">（这里，根据天和月进行聚合，和根据天聚合结果一样，因为有父子关系，如果是其他维度组合的话，就会不一样）</span><br></pre></td></tr></table></figure></div>



<hr>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">读书是易事、思索是难事、但两者缺一,便全无用处。</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据技术</tag>
        <tag>SQL</tag>
        <tag>Hive SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数仓项目</title>
    <url>/2024/04/16/%E6%95%B0%E4%BB%93%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p><a class="link"   href="https://www.bilibili.com/video/BV1xx421D7Dk/?spm_id_from=333.1007.tianma.4-1-11.click" >脱颖而出 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">那就停下来吧、关于你的一切</span><br></pre></td></tr></table></figure></div>



<h2 id="1-数据的采集"><a href="#1-数据的采集" class="headerlink" title="1. 数据的采集"></a>1. 数据的采集</h2><p>我们主要分析两种数据</p>
<ol>
<li><p>业务数据</p>
<p>简单的来说就是开发的内容中涉及的数据（站在开发者的角度来看）</p>
</li>
<li><p>行为数据</p>
<p>通过埋点收集和客户端产品交互过程中产生的数据（比如用户的点赞、收藏，评论、停留）</p>
</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">本项目收集和分析的用户行为数据主要有页面浏览信息、动作记录（商品收藏、）、曝光记录、启动记录、错误记录</span><br></pre></td></tr></table></figure></div>

<h3 id="1-1-数据同步的方式"><a href="#1-1-数据同步的方式" class="headerlink" title="1.1 数据同步的方式"></a>1.1 数据同步的方式</h3><ol>
<li>全量数据同步（DataX）</li>
<li>增量数据同步（Maxwell）</li>
</ol>
<p><a class="link"   href="https://blog.csdn.net/Morse_Chen/article/details/135418623" >Flume <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="1-2-数据流转到kafka"><a href="#1-2-数据流转到kafka" class="headerlink" title="1.2 数据流转到kafka"></a>1.2 数据流转到kafka</h3><ul>
<li><p>主要是为了进行实时（数据的处理以毫秒为单位）的处理</p>
</li>
<li><p>什么样的数据需要流转到kafka呢？（增量数据）</p>
</li>
</ul>
<ol>
<li>Maxwell</li>
</ol>
<p><a class="link"   href="https://blog.csdn.net/cxl_shelly/article/details/122132124?ops_request_misc=&request_id=&biz_id=102&utm_term=Maxwell%E6%95%99%E7%A8%8B&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-122132124.nonecase&spm=1018.2226.3001.4187" >博文 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://maxwells-daemon.io/quickstart/" >官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ol start="2">
<li>Maxwell ,  mysql的实现原理</li>
</ol>
<ul>
<li><p>主从复制</p>
</li>
<li><p>读写分离</p>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql的数据放在文件中、从文件中查询速度肯定很慢，所有mysql把经常查询的一部分1内容放到内存中，走内存进行查询，速率肯定快。而内存中也分几部分，有写缓存、和读缓存，当进行查询的时候，优先从写缓存中进行查询、查不到在从读缓存中进行查询。（此时用户新增的一个流程是，先将新增的数据写入写缓存中，达到一定的阈值之后写入文件，但此时出现一个问题，假如在向写缓存中的时候服务器突然挂掉、缓存中的数据就会丢失，这个时候就出现了数据丢失的问题）解决问题的方法：在写入缓存中先顺写到一个文件中、然后在向缓存中进行写入即可（注意：mysql在存储的时候是随机读写，效率不高，先写入一个文件，再写入缓存中是顺写，效率高）所以提高mysql的效率的一种方式就是使用更好的磁盘。同时还可以使用集群，而使用集群大致过程就是。向主节点进行写入，主节点将数据同步给集群中的其他节点（从节点），进行查询的时候只从从节点就行查询。这样保证了每台服务器职能比较单一，效率更好。而从节点进行数据同步的方式就是读取我们刚刚顺写的日志就可以保证从节点的数据同步了。</span><br><span class="line">而maxwell的实现就是将自己伪装成从节点，读取顺写日志（binlog），将增量数据进行同步</span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-两种数据同步的方式"><a href="#1-3-两种数据同步的方式" class="headerlink" title="1.3 两种数据同步的方式"></a>1.3 两种数据同步的方式</h3><ol>
<li>全量数据–也可以使用maxwell进行同步</li>
<li>增量数据-使用maxwell进行同步</li>
</ol>
<h3 id="1-4-hive分区的目的"><a href="#1-4-hive分区的目的" class="headerlink" title="1.4 hive分区的目的"></a>1.4 hive分区的目的</h3><ul>
<li>提高查询效率  –  假如根据首字母进行分区，查找张三，只需要查找z开头的文件夹即可</li>
<li>一般分区按照天来进行统计</li>
</ul>
<h3 id="1-5-业务数据采集-零点漂移问题"><a href="#1-5-业务数据采集-零点漂移问题" class="headerlink" title="1.5 业务数据采集-零点漂移问题"></a>1.5 业务数据采集-零点漂移问题</h3><p>出现在：将kafka中的数据通过flume同步给hdfs，然后给hive的过程中</p>
<p><a class="link"   href="https://blog.csdn.net/zznanyou/article/details/120583023" >相关解决方法1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用拦截器进行解决：</span><br><span class="line">	- 作用1 判断json格式的数据（body中的数据）有否有效（采集的日志数据是json格式，要保证传输过去的格式正确）</span><br><span class="line">	- 作用2 解决零点漂移问题-修改header中的时间戳 </span><br></pre></td></tr></table></figure></div>

<h3 id="1-6-全量数据同步-DataX"><a href="#1-6-全量数据同步-DataX" class="headerlink" title="1.6 全量数据同步-DataX"></a>1.6 全量数据同步-DataX</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-7d18a1288deaa9eacd864705025c3ade_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-2f7c72d6538b2a3bbda308f274605ba0_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-b76a8d9043c6c8a80ef6028c1b643b2c_720w.webp"
                     
                ></p>
<h4 id="1-6-1-DataX使用案例"><a href="#1-6-1-DataX使用案例" class="headerlink" title="1.6.1 DataX使用案例"></a>1.6.1 DataX使用案例</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-8c5e80fa10193830a70dc3acaa80f8c2_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-a34faded91918e000cd0d280957f5544_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-d6326aeeae1aa6809f379dcf5c840f6e_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-278544255d4af8be5175e6f50e430df0_720w.webp"
                     
                ></p>
<h2 id="2-数仓基础"><a href="#2-数仓基础" class="headerlink" title="2. 数仓基础"></a>2. 数仓基础</h2><h3 id="2-1-数据仓库和数据库的区别"><a href="#2-1-数据仓库和数据库的区别" class="headerlink" title="2.1 数据仓库和数据库的区别"></a>2.1 数据仓库和数据库的区别</h3><p>一：概念上来对别</p>
<ol>
<li>数据仓库的数据，进行加工，然后对外提供服务</li>
<li>数据库主要在于存储，仓库主要在于进行打工，计算</li>
</ol>
<p>二：数据来源对比</p>
<ol>
<li>数据库的数据主要是企业中基础核心的业务数据</li>
<li>数据仓库的数据有部分是来自于数据库中</li>
</ol>
<p>三：数据存储进行区分</p>
<ol>
<li>数据库核心在于查找业务数据</li>
<li>数据仓库核心在于统计分析数据</li>
</ol>
<p>四：数据价值进行区分</p>
<ol>
<li>数据仓库：将统计分析结果为企业的经营决策提供数据支撑</li>
</ol>
<h3 id="2-2-数据仓库内部结构-常见分层"><a href="#2-2-数据仓库内部结构-常见分层" class="headerlink" title="2.2 数据仓库内部结构-常见分层"></a>2.2 数据仓库内部结构-常见分层</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-c5ba09937d828e5fc80619ddb7a5b5b3_720w.webp"
                     
                ></p>
<h4 id="2-2-1-每层具体分析"><a href="#2-2-1-每层具体分析" class="headerlink" title="2.2.1 每层具体分析"></a>2.2.1 每层具体分析</h4><ol>
<li>数据源：对接日志服务器和业务数据库</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-9e179a651e31c0976786f772445264ba_720w.webp"
                     
                ></p>
<ol start="2">
<li>加工数据：对ODS层的数据进行加工处理，为后面的统计分析做准备</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-30d02e3c5f610a10333b10c199a793fb_720w.webp"
                     
                ></p>
<ol start="3">
<li>统计数据</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-d8b33ca830a1d3301b38ef3ee0017c4a_720w.webp"
                     
                ></p>
<ol start="4">
<li>分析数据</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-564b30bbc616afd49fc78b1ff4dc4ff7_720w.webp"
                     
                ></p>
<ol start="5">
<li>共通层</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-f8a516576cb7a2d781646024ae254e44_720w.webp"
                     
                ></p>
<ol start="6">
<li>任务调度器</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-bb891468318470c9f5d1b2f27dfec97f_720w.webp"
                     
                ></p>
<h3 id="2-3-数仓项目学习重点"><a href="#2-3-数仓项目学习重点" class="headerlink" title="2.3 数仓项目学习重点"></a>2.3 数仓项目学习重点</h3><ul>
<li>建表</li>
<li>Sql</li>
<li>任务调度器</li>
</ul>
<ol>
<li>建表（建模）直接影响于SQL文的查询效率快慢与否</li>
</ol>
<h2 id="3-数仓建模"><a href="#3-数仓建模" class="headerlink" title="3.  数仓建模"></a>3.  数仓建模</h2><h3 id="3-1-方法论"><a href="#3-1-方法论" class="headerlink" title="3.1 方法论"></a>3.1 方法论</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. ER模型</span><br><span class="line">2. 维度模型</span><br></pre></td></tr></table></figure></div>

<h3 id="3-2-ER模型"><a href="#3-2-ER模型" class="headerlink" title="3.2 ER模型"></a>3.2 ER模型</h3><ol>
<li><p>对象关系</p>
<ol>
<li>一对多</li>
<li>多对一</li>
<li>一对一</li>
<li>多对多</li>
</ol>
</li>
<li><p>函数依赖关系</p>
<ul>
<li>完全函数依赖 ： 根据id，确定一个唯一的姓名</li>
<li>部分函数依赖 ： 只需要传入的部分字段进行处理，就可以获得唯一的姓名（部分有用）</li>
<li>间接函数依赖 ： 根据学生id，获取学生老师id，根据老师id获得老师姓名</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picx.zhimg.com/80/v2-fe3d4e59ca29a82f66eab22c0dfa6c30_720w.png"
                     
                ></p>
</li>
<li><p>范式理论（我们只针对前三范式进行说明-范式等级越高、数据冗余性低，但效率较低）</p>
<ol>
<li>第一范式：属性不可切割</li>
<li>第二范式：不能存在部分函数依赖</li>
<li>第三范式：不能存在传递函数依赖</li>
</ol>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picx.zhimg.com/80/v2-d8ae982218509cb82819fcf7be48c6fd_720w.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-387ecd6f879ddf0eaacda3f1f345a35d_720w.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picx.zhimg.com/80/v2-634f2e2fed9d27b2ac0b82716e32c12d_720w.png"
                     
                ></p>
<ol start="4">
<li>ER模型的优缺点</li>
</ol>
<p>ER模型不适合数仓仓库的建模操作</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picx.zhimg.com/80/v2-824c5eeb10e8d91bb9cd4e1a28541480_720w.png"
                     
                ></p>
<h3 id="3-3-维度模型"><a href="#3-3-维度模型" class="headerlink" title="3.3 维度模型"></a>3.3 维度模型</h3><p>核心：数据的分析统计</p>
<ul>
<li>创建的表分为两大类：数据统计表（汇总什么样的数据）、数据分析表（从什么角度分析）</li>
<li>所谓维度就是分析数据的角度</li>
</ul>
<h2 id="4-数仓运行环境"><a href="#4-数仓运行环境" class="headerlink" title="4. 数仓运行环境"></a>4. 数仓运行环境</h2><ol>
<li><p>数仓构建流程</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picx.zhimg.com/80/v2-822ee7cc194f6a88953a9de848576cbe_720w.png?source=d16d100b"
                     
                ></p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picx.zhimg.com/80/v2-155b2063a63c21c1f994b8385863b83c_720w.png"
                     
                ></p>
<ol start="2">
<li>环境配置<ol>
<li>我们使用的环境是Hive on Spark (谁在on前面，就是谁来解释sql文)</li>
</ol>
</li>
</ol>
<h2 id="5-ODS层（数据源）开发"><a href="#5-ODS层（数据源）开发" class="headerlink" title="5. ODS层（数据源）开发"></a>5. <code>ODS</code>层（数据源）开发</h2><ul>
<li><p><code>ODS</code>层是<code>ER</code>模型，因为<code>mysql</code>是<code>ER</code>模型（实体、关系）</p>
</li>
<li><p>数据格式尽可能不变</p>
</li>
<li><p>压缩格式尽可能不变</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pica.zhimg.com/80/v2-3d3260497fe101a858881f8dec767c1b_720w.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picx.zhimg.com/80/v2-c49873d0b4f66c6e5f0d98284b4c7b19_720w.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picx.zhimg.com/80/v2-a9ebf2ad8126963d7a1984b41f7a658e_720w.png"
                     
                ></p>
<h4 id="5-1-Hive分区扩展"><a href="#5-1-Hive分区扩展" class="headerlink" title="5.1 Hive分区扩展"></a>5.1 Hive分区扩展</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-4bbc99cc226764a543134ae692111a4d_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-bafaaf7a9d6357b901700e87b5f1cdff_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-3b06c6c94a9fd32f0d202fefcb0300eb_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-a066040c9fb611ed3bd4aeed47c4d00e_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-6c952d08f00bc5d508d74cbd710a863d_720w.webp"
                     
                ></p>
<h4 id="5-2-Hive复杂数据类型"><a href="#5-2-Hive复杂数据类型" class="headerlink" title="5.2 Hive复杂数据类型"></a>5.2 Hive复杂数据类型</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于JSON数据，一般将最外层的JSON对象的属性作为JSON表的字段，然后里面使用复杂数据类型作为值，同时map，和struct的区别在于，map一般用于key，value里面类型一样的才可以使用map，struct里面的属性和值的类型可以不尽相同</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-6823e017202ff06b9affc5dd6f2fcb90_720w.webp"
                     
                ></p>
<h5 id="1-Array类型"><a href="#1-Array类型" class="headerlink" title="1. Array类型"></a>1. <code>Array</code>类型</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-ed1df799b57253281b03105c8bdd5657_720w.webp"
                     
                ></p>
<h5 id="2-Map类型"><a href="#2-Map类型" class="headerlink" title="2. Map类型"></a>2. <code>Map</code>类型</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-1fc0529aafe3b3ca53ebd409dca2d4dc_720w.webp"
                     
                ></p>
<h5 id="3-struct类型"><a href="#3-struct类型" class="headerlink" title="3. struct类型"></a>3. <code>struct</code>类型</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-0728649aab147940a8d54875afc591f3_720w.webp"
                     
                ></p>
<h4 id="5-3-日志数据同步"><a href="#5-3-日志数据同步" class="headerlink" title="5.3 日志数据同步"></a>5.3 日志数据同步</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-d322818230ea0f67bf178c3ceb7be343_720w.webp"
                     
                ></p>
<h4 id="5-4-业务数据同步"><a href="#5-4-业务数据同步" class="headerlink" title="5.4 业务数据同步"></a>5.4 业务数据同步</h4><ul>
<li><p>全量表</p>
<ol>
<li><code>TSV</code>格式</li>
<li><code>DataX</code></li>
<li>表结构和业务表保持一致即可</li>
</ol>
</li>
<li><p>增量表</p>
<ol>
<li><code>JSON</code>格式</li>
<li><code>Maxwell</code></li>
<li>对象最外层的属性作为表的字段</li>
</ol>
</li>
<li><p>使用脚本将数据进行批量导入</p>
</li>
</ul>
<h2 id="6-DIM层开发（共同维度层）"><a href="#6-DIM层开发（共同维度层）" class="headerlink" title="6. DIM层开发（共同维度层）"></a>6. <code>DIM</code>层开发（共同维度层）</h2><ul>
<li>维度（状态）表</li>
<li>事实（行为）表</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-b468e2067108992c285d6cd3d365014b_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-55e179daf2b9bee7ca498678b4bc7004_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-45fe64901f5114244b6c3220e39d668b_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-d6ac8e017cabc982fede449a64d5ad21_720w.webp"
                     
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.查询结果封装成指定属性的结构体，并且放到一个数组（返回一个数组类型，数组存放结构体）</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-f63efc75b21afc01c89217c81ae79436_720w.webp"
                     
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. 表查询的几个关联操作（针对列）</span><br><span class="line">行补齐使用union，列补齐使用join</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-653464fbbe16ef7ce6ab38b571e42229_720w.webp"
                     
                ></p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>大数据技术</tag>
        <tag>数据采集</tag>
        <tag>数据仓库</tag>
        <tag>大数据实战项目</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库-SQL</title>
    <url>/2024/04/10/%E6%95%B0%E6%8D%AE%E5%BA%93-SQL/</url>
    <content><![CDATA[<h1 id="1-杂七杂八"><a href="#1-杂七杂八" class="headerlink" title="1. 杂七杂八"></a>1. 杂七杂八</h1><h3 id="测试图片上传服务器功能"><a href="#测试图片上传服务器功能" class="headerlink" title="测试图片上传服务器功能"></a>测试图片上传服务器功能</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">老身今自由。心无疚，随意度春秋</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-c67b050921ab84a8a5188cb2559fe9ad_720w.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-626d786cd1bc9423942de0f829a8ab17_720w.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-5aac35005e06df7a489195614e4b4a23_720w.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-d15d1d5889e528fa16de49eac88cab10_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-6b96910eb06b006568a6043458c22aac_720w.webp"
                     
                ></p>
<h2 id="1-爆炸函数"><a href="#1-爆炸函数" class="headerlink" title="1.爆炸函数"></a>1.爆炸函数</h2><hr>
<ol>
<li><p>使用爆炸函数可以将数组转化为<strong>一列</strong>数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">select</span> explode(<span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sequence(<span class="number">1</span>,<span class="number">100</span>);  <span class="comment">-- 生成1到100，数组数据</span></span><br><span class="line"># 配合爆炸函数快速生成一列数据</span><br><span class="line"><span class="keyword">select</span> explode(sequence(<span class="number">1</span>,<span class="number">100</span>)) <span class="keyword">as</span> id  <span class="comment">-- 可以生成一列从1，到100的数组</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>快速生成表的数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> stack(</span><br><span class="line">	<span class="number">2</span>,   <span class="comment">-- 这个参数指定表中有几条数据</span></span><br><span class="line">	<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="number">23</span>,</span><br><span class="line">	<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">22</span>    <span class="comment">-- 这两行指定表的数据内容</span></span><br><span class="line">);</span><br><span class="line"># 也可以指定表中每一列的字段名称</span><br><span class="line"><span class="keyword">select</span> stack(</span><br><span class="line">	<span class="number">2</span>,   <span class="comment">-- 这个参数指定表中有几条数据</span></span><br><span class="line">	<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="number">23</span>,</span><br><span class="line">	<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">22</span>    <span class="comment">-- 这两行指定表的数据内容</span></span><br><span class="line">) <span class="keyword">as</span> (id , name , age);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>操作生成表的数据的方式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-96f65907b5db27165ac8a0c35ded999d_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-978c9ada3d323e31b62dc0f86cbdd2c3_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-b0c6c4532bbdbd9733312b1611ed9875_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-f957d4006d4d9ea8491601b5248e4d97_720w.webp"
                     
                ></p>
</li>
</ol>
<h2 id="2-SparkSQL的执行引擎"><a href="#2-SparkSQL的执行引擎" class="headerlink" title="2.SparkSQL的执行引擎"></a>2.SparkSQL的执行引擎</h2><ul>
<li>解析器 ： 将sql语句转化为语法树</li>
<li>分析器 ： 语法树中被查询的字段数据类型-读取元数据声明被查询的字段类型</li>
<li>优化器 ： 将语法树进行优化<ul>
<li>谓词下推 ： 比如先进行where的过滤条件，将过滤结果在进行join操作</li>
<li>列值裁减 ： 只查询需要的字段</li>
</ul>
</li>
<li>执行器 ： 将最终语法树转化为rdd，交给spark进行最终执行</li>
</ul>
<h2 id="3-电商案例"><a href="#3-电商案例" class="headerlink" title="3. 电商案例"></a>3. 电商案例</h2><ol>
<li>订单表字段说明</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-230eab3071260efdc00c1fe81eb4c71d_720w.webp"
                     
                ></p>
<ol start="2">
<li>对原数据进行数据清洗的时候假如存在int类型和string类型的空，过滤方法为：</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-82a74de1d91f0800e369bcf00f4dc736_720w.webp"
                      style="zoom:80%;" 
                >

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 注意点就是对于字符串过滤的时候，不能使用<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> 因为他不是<span class="keyword">null</span>，是空字符</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">and</span> name <span class="operator">!=</span> <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-c6075985d1d94348edd19ad555c21362_720w.webp"
                     
                ></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 然后将过滤之后的数据导入到下一层里面</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-ee58c48091a9b74721b019bb437fa1ec_720w.webp"
                      style="zoom:80%;" 
                >

<ol start="3">
<li>app层的计算指标</li>
</ol>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">1.</span>销量最高的<span class="number">10</span>个国家</span><br><span class="line"><span class="keyword">select</span> Country , <span class="built_in">sum</span>(Quantity) <span class="keyword">as</span> sum_data <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span> Country <span class="keyword">order</span> <span class="keyword">by</span> sum_data <span class="keyword">desc</span> limit(<span class="number">10</span>)</span><br><span class="line"># <span class="number">2.</span> 各个国家的总销售额分布情况</span><br><span class="line"><span class="keyword">select</span> Country , <span class="built_in">sum</span>(Quantity <span class="operator">*</span> Price)  <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span> Country</span><br><span class="line">        <span class="comment">-- 保留小数点两位使用round() 函数</span></span><br><span class="line"><span class="keyword">select</span> Country , round(<span class="built_in">sum</span>(Quantity <span class="operator">*</span> Price) , <span class="number">2</span>)  <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span> Country</span><br><span class="line"># <span class="number">3.</span> 销量最高的<span class="number">10</span>个商品</span><br><span class="line"><span class="keyword">select</span> InvoiceNo , <span class="built_in">sum</span>(Quantity) <span class="keyword">as</span> sum_data <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span> InvoiceNo </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> sum_data limit(<span class="number">10</span>)</span><br><span class="line"># <span class="number">4.</span> 商品描述的热门关键词Top300</span><br><span class="line"><span class="comment">-- 思路：首先将商品描述根据空格进行切割，然后得到sql里面的数组，借助爆炸函数，将数组中的数据转化为一列数组，并且重命名为word，然后在进行查询统计即可</span></span><br><span class="line"><span class="keyword">with</span> tb <span class="keyword">as</span>(</span><br><span class="line">	<span class="keyword">select</span> explode(split(Description , <span class="string">&#x27; &#x27;</span>)) <span class="keyword">as</span> word <span class="keyword">from</span> 表名 </span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> word , <span class="built_in">count</span>(word) <span class="keyword">as</span> count_data <span class="keyword">from</span> tb <span class="keyword">where</span> word <span class="operator">!=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> word </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> count_data <span class="keyword">desc</span> limit <span class="number">300</span></span><br><span class="line">	</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">5.</span> 退货订单数最多的<span class="number">10</span>个国家 <span class="comment">-- 求的是数量啊--使用内置函数--count()</span></span><br><span class="line"><span class="keyword">select</span> Country , <span class="built_in">count</span>(InvoiceNo)  <span class="keyword">from</span> 表名 <span class="keyword">where</span> <span class="built_in">substring</span>(InvoiceNo,<span class="number">1</span>,<span class="number">1</span>)<span class="operator">=</span><span class="operator">=</span><span class="string">&#x27;C&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> Country <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">count</span>(InvoiceNo) <span class="keyword">desc</span> limit <span class="number">10</span></span><br><span class="line"></span><br><span class="line">(答案)<span class="keyword">select</span> Country , <span class="built_in">count</span>(InvoiceNo) <span class="keyword">as</span> count_data  <span class="keyword">from</span> 表名 <span class="keyword">where</span> InvoiceNo <span class="keyword">like</span>  &quot;C%&quot; <span class="keyword">group</span> <span class="keyword">by</span> Country <span class="keyword">order</span> <span class="keyword">by</span> count_data <span class="keyword">desc</span> limit <span class="number">10</span></span><br><span class="line"># <span class="number">6.</span> 商品的平均单价和销量的关系</span><br><span class="line"><span class="keyword">select</span> StockCode round(<span class="built_in">avg</span>(price) , <span class="number">2</span>) <span class="keyword">as</span> avg_data , <span class="built_in">sum</span>(Quantity) <span class="keyword">as</span> sum_data <span class="keyword">from</span> 表名 </span><br></pre></td></tr></table></figure></div>

<h2 id="4-消息队列（MQ）"><a href="#4-消息队列（MQ）" class="headerlink" title="4. 消息队列（MQ）"></a>4. 消息队列（MQ）</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">突然有一天你会发现，你的思念不会因为长时间的不联系而消失，只会随着时间的流逝像野草般疯狂生长。</span><br></pre></td></tr></table></figure></div>



<ol>
<li>作用</li>
</ol>
<ul>
<li>进行实时计算需要</li>
<li>应用耦合  – 解耦  – 使用消息队列解耦</li>
<li>异步处理</li>
<li>限流削峰</li>
</ul>
<ol start="2">
<li>消息队列的两种模式</li>
</ol>
<ul>
<li>点对点</li>
</ul>
<p>​	</p>
<ul>
<li>发布与订阅</li>
</ul>
<hr>
<h1 id="2-数据库相关"><a href="#2-数据库相关" class="headerlink" title="2. 数据库相关"></a>2. 数据库相关</h1><h3 id="1-数据库-事务"><a href="#1-数据库-事务" class="headerlink" title="1. 数据库-事务"></a>1. 数据库-事务</h3><ul>
<li><p>事务是一组操作的集合，这组操作，要么全部执行成功，要么全部执行失败。</p>
</li>
<li><p>mysql的事务默认是自动提交，一条语句执行之后就自动提交了</p>
</li>
</ul>
<h4 id="1-1-事务的四大特性"><a href="#1-1-事务的四大特性" class="headerlink" title="1.1 事务的四大特性"></a>1.1 事务的四大特性</h4><ol>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-5c18b0e980eb3c0b462cba5f0b45c31f_720w.webp"
                     
                ></p>
<h4 id="1-2-并发事务问题"><a href="#1-2-并发事务问题" class="headerlink" title="1.2 并发事务问题"></a>1.2 并发事务问题</h4><p>多个并发事务在执行的过程当中出现的问题</p>
<ol>
<li>脏读</li>
<li>不可重复读</li>
<li>幻读</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-3f68066d7a76a739a1e0ccd9cbf525c5_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-f61c1f664cfa8f0a5aef3803985d284d_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-3195f8b3caf5261c5d385766753418da_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-a80aa4738bc26c2d8b216ed16c765d9c_720w.webp"
                     
                ></p>
<h5 id="1-2-1-如何解决"><a href="#1-2-1-如何解决" class="headerlink" title="1.2.1 如何解决"></a>1.2.1 如何解决</h5><p>通过事务不同的隔离级别进行解决（级别越高数据越安全、但效率越低）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-3e661825715813c1462142b154a69ca0_720w.webp"
                     
                ></p>
<h3 id="2-数据库-存储引擎"><a href="#2-数据库-存储引擎" class="headerlink" title="2. 数据库-存储引擎"></a>2. 数据库-存储引擎</h3><h4 id="2-1-mysql的四大体系结构"><a href="#2-1-mysql的四大体系结构" class="headerlink" title="2.1 mysql的四大体系结构"></a>2.1 mysql的四大体系结构</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-8d11c93068d9ea31134c9c54cd56f893_720w.webp"
                     
                ></p>
<h4 id="2-2-mysql的存储引擎"><a href="#2-2-mysql的存储引擎" class="headerlink" title="2.2 mysql的存储引擎"></a>2.2 mysql的存储引擎</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 存储引擎是基于表的，一个数据库下的不同表，可以有不同的存储引擎</span><br><span class="line">2. mysql 5.5 之后，表的默认存储引擎是InnoDB</span><br></pre></td></tr></table></figure></div>

<ol>
<li>如何使用</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-56ad047187644ebcaa1044bec4347e14_720w.webp"
                     
                ></p>
<h4 id="2-3-存储引擎的主要特点"><a href="#2-3-存储引擎的主要特点" class="headerlink" title="2.3 存储引擎的主要特点"></a>2.3 存储引擎的主要特点</h4><ul>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-6c4d14fc53daf0bb7c54d67db0acec6b_720w.webp"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-997639c1dc6b451ea9a7931375afa58b_720w.webp"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picx.zhimg.com/80/v2-7fd36a19700b2ce853bd13dabcc0add4_720w.png"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picx.zhimg.com/80/v2-fb2d8359f76bfae6fed2947504c8c922_720w.png"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picx.zhimg.com/80/v2-613645ff10d8e1f169402b85aaef6c2a_720w.png"
                     
                ></p>
</li>
</ul>
<h4 id="2-4-面试题：InnoDB和MyISAM区别"><a href="#2-4-面试题：InnoDB和MyISAM区别" class="headerlink" title="2. 4 面试题：InnoDB和MyISAM区别"></a>2. 4 面试题：InnoDB和MyISAM区别</h4><p>问InnoDB和MyISAM的区别？（两个存储引擎的区别）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">InnoDB：支持事务、行锁、支持外键</span><br><span class="line">MyISAM: 表锁，不支持事务、不支持外键</span><br></pre></td></tr></table></figure></div>

<h4 id="2-5-存储引擎如何选择"><a href="#2-5-存储引擎如何选择" class="headerlink" title="2.5 存储引擎如何选择"></a>2.5 存储引擎如何选择</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据系统应用特点，选择合适的存储引擎，一般用第一个，两外两个现在一般被MongoDB、redis代替</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-dc5521f08948280368776418ab349a49_720w.png"
                     
                ></p>
<h4 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a>2.6 总结</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-71e0fd8768c2bec30010d3dc35099d19_720w.png"
                     
                ></p>
<h3 id="3-数据库-索引"><a href="#3-数据库-索引" class="headerlink" title="3. 数据库-索引"></a>3. 数据库-索引</h3><h4 id="3-1-索引概述"><a href="#3-1-索引概述" class="headerlink" title="3.1 索引概述"></a>3.1 索引概述</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picx.zhimg.com/80/v2-e0cb42fd9940f50f2fe6e5d983553ff9_720w.png"
                     
                ></p>
<p>优缺点</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-2fcf4f7479bae0f51782b7f84a846421_720w.webp"
                     
                ></p>
<h4 id="3-2-索引结构-B-树"><a href="#3-2-索引结构-B-树" class="headerlink" title="3.2 索引结构-B+树"></a>3.2 索引结构-<code>B+</code>树</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-93f04ed6072173e2c5275587bb11c9e5_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-b3cbea991d04ba865aa05f013655ba8d_720w.webp"
                     
                ></p>
<ol>
<li>二叉树（二叉搜索树）和红黑树（自平衡的二叉搜索树）</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-68b767b81a0b10f40e24b310e03bdc96_720w.webp"
                     
                ></p>
<ol start="2">
<li>B树（多路平衡搜索树）</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-55a2384359a50d83dfe1cc8358203a52_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-b02db971f6ee7d5f269c6dc102b5b275_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-fefb2b8d4c9f005b6d49bb0f96f8d49f_720w.webp"
                     
                ></p>
<ol start="3">
<li>mysql中优化后的B+树</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-1c9c01683bf9bef3255d16e275dfc0ba_720w.webp"
                     
                ></p>
<h4 id="3-3-索引结构-Hash索引"><a href="#3-3-索引结构-Hash索引" class="headerlink" title="3.3 索引结构-Hash索引"></a>3.3 索引结构-<code>Hash</code>索引</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-e47999db77e42b614561f4b6438e11ea_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-159b077d852143068a03d45d399194ca_720w.webp"
                     
                ></p>
<h4 id="3-4-面试题：存储引擎为啥B-树"><a href="#3-4-面试题：存储引擎为啥B-树" class="headerlink" title="3.4 面试题：存储引擎为啥B+树"></a>3.4 面试题：存储引擎为啥B+树</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-2ec2b9a23a0a7851fff2349c30bf2567_720w.webp"
                     
                ></p>
<h4 id="3-5-索引分类"><a href="#3-5-索引分类" class="headerlink" title="3.5 索引分类"></a>3.5 索引分类</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-45fad34cff2f1c4ebc1cfe4476a05736_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-78fde613289e4bc6bf96fecb6d1cba75_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-80fda657f3ff70b352e2c0ef96514132_720w.webp"
                     
                ></p>
<ol>
<li>举例使用-回表查询</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-64468b11056744b7d10a492c5aa05bd0_720w.webp"
                     
                ></p>
<h4 id="3-6-索引的使用"><a href="#3-6-索引的使用" class="headerlink" title="3.6 索引的使用"></a>3.6 索引的使用</h4><h5 id="1-创建索引"><a href="#1-创建索引" class="headerlink" title="1. 创建索引"></a>1. 创建索引</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建索引 : </span></span><br><span class="line"><span class="keyword">create</span> index 索引名称 <span class="keyword">on</span> 表名（需要索引的字段）</span><br><span class="line"><span class="keyword">CREATE</span> index idx_user_email <span class="keyword">ON</span> `<span class="keyword">user</span>`(email)  		</span><br></pre></td></tr></table></figure></div>

<h5 id="2-查看索引"><a href="#2-查看索引" class="headerlink" title="2. 查看索引"></a>2. 查看索引</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看索引</span></span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="3-删除索引"><a href="#3-删除索引" class="headerlink" title="3. 删除索引"></a>3. 删除索引</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">drop</span> index 需要删除的索引名称 <span class="keyword">on</span> 该索引对应的表名;</span><br><span class="line"><span class="keyword">drop</span> index idx_user_email <span class="keyword">on</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="4-索引小案例"><a href="#4-索引小案例" class="headerlink" title="4. 索引小案例"></a>4. 索引小案例</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-bd9550afd0ff54085d147259dabb501a_720w.webp"
                     
                ></p>
<h4 id="3-7-Sql性能分析"><a href="#3-7-Sql性能分析" class="headerlink" title="3.7 Sql性能分析"></a>3.7 Sql性能分析</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. sql执行频率</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;  <span class="comment">-- 7个下划线哦</span></span><br><span class="line"><span class="comment">-- 2. 然后得到select执行频率比较高的sql语句，开始慢查询，设置时间，就可以得到执行时间比较慢的相关日志信息了</span></span><br><span class="line"><span class="comment">-- 3. 使用profile查看每一条sql的执行时间</span></span><br><span class="line"><span class="comment">-- 4. explain执行计划（主要使用这个）</span></span><br><span class="line">	<span class="comment">-- 目的：就是尽可能将type进行优化	</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-3ddaa3a2225b2f1d3d27e7da908a9cec_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-96333f01e4a552cf03b081df0f629fa0_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-92cda67a094c71422dfe4fd5e43ea417_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-3d920c8adaa46179d264658ac4724ad1_720w.webp"
                     
                ></p>
<p>explain的相关使用和优化点</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-ede4d35c236de77543ccc87886dc9b2e_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-88a3dc4b6408183a5f58f58cea631c0d_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-b3ae73ba65a38d38493f334a1c9f7438_720w.webp"
                     
                ></p>
<h4 id="3-8-索引使用的特殊情况"><a href="#3-8-索引使用的特殊情况" class="headerlink" title="3.8 索引使用的特殊情况"></a>3.8 索引使用的特殊情况</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-d90617e3742e37d416b4e80e311232f2_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-5d0687477b1fbacc3684103995c583fd_720w.webp"
                     
                ></p>
<hr>
<p>索引失效的几种情况：</p>
<ul>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-3800cdd447ac269c33be156d767658df_720w.webp"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-3daeb684631bb0042ccc00d23fe372e4_720w.webp"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-e47c902fa56d9627cd703e757cdf94ef_720w.webp"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-cb9e09870ab1c7201d532ec8e395d1c3_720w.webp"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-2635e5cfd60ed5c22873cf5e50366000_720w.webp"
                     
                ></p>
</li>
</ul>
<hr>
<ol>
<li>Sql提示</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-b0830d7c3fe3417cadf7c0884bffe52e_720w.webp"
                     
                ></p>
<ol start="2">
<li>覆盖索引</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-f58d0e805a273f611b3ce37fd7adf7fe_720w.webp"
                     
                ></p>
<ol start="3">
<li>前缀索引</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-43010cb80a3ac37747470c53bb0c576c_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-9351c1f6c44465597f41dac55b58ea68_720w.webp"
                     
                ></p>
<ol start="3">
<li>单列&#x2F;联合索引</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-c8cc019d3fb9e2df01ce79488b419a5e_720w.webp"
                     
                ></p>
<ol start="4">
<li>索引设计原则</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-0098837138c5e5e4150945df3eaebd9e_720w.webp"
                     
                ></p>
<hr>
<h4 id="3-9-索引总结"><a href="#3-9-索引总结" class="headerlink" title="3.9 索引总结"></a>3.9 索引总结</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-81aa193a09f0bd9290e4e55d59c4f7ee_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-aacf12ff64236bbf31bc503f8abe63d9_720w.webp"
                     
                ></p>
<h3 id="4-sql优化"><a href="#4-sql优化" class="headerlink" title="4. sql优化"></a>4. sql优化</h3><h4 id="1-插入优化"><a href="#1-插入优化" class="headerlink" title="1. 插入优化"></a>1. 插入优化</h4><ul>
<li>批量插入</li>
<li>手动提交事务</li>
<li>按照主键顺序插入</li>
<li>对于大批量插入数据不能使用insert，使用load进行加载插入</li>
</ul>
<h4 id="2-主键优化"><a href="#2-主键优化" class="headerlink" title="2. 主键优化"></a>2. 主键优化</h4><ul>
<li>主机顺序插入的效率高，在于不发生页分裂。也就是主键乱序插入的时候，可以发生页分裂</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li>页分裂-页合并：当某一页中的数据小于一个值（默认50%）就有可能发生页合并</li>
</ul>
<hr>
<p>主键设计原则：</p>
<pre><code>1. 尽可能将主键字段设计较短（二级索引存储的是主键，占内存）
1. 尽量选择主键顺序插入
1. 避免使用uuid，身份证号码等作为主键
1. 业务操作，尽量避免对主键的修改
</code></pre>
<h4 id="3-order-by优化"><a href="#3-order-by优化" class="headerlink" title="3. order by优化"></a>3. <code>order by</code>优化</h4><p>- </p>
<h4 id="4-group-by优化"><a href="#4-group-by优化" class="headerlink" title="4. group by优化"></a>4. <code>group by</code>优化</h4><h4 id="5-limit优化"><a href="#5-limit优化" class="headerlink" title="5. limit优化"></a>5. <code>limit</code>优化</h4><h4 id="6-count优化"><a href="#6-count优化" class="headerlink" title="6. count优化"></a>6. <code>count</code>优化</h4><h4 id="7-update优化"><a href="#7-update优化" class="headerlink" title="7. update优化"></a>7. <code>update</code>优化</h4>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据技术</tag>
        <tag>人生感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>比赛刷题总结</title>
    <url>/2024/04/18/%E6%AF%94%E8%B5%9B%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="1-图论题目"><a href="#1-图论题目" class="headerlink" title="1. 图论题目"></a>1. 图论题目</h2><h3 id="1-1-网红点打卡攻略"><a href="#1-1-网红点打卡攻略" class="headerlink" title="1.1 网红点打卡攻略"></a>1.1 网红点打卡攻略</h3><p><a class="link"   href="https://pintia.cn/problem-sets/1779778307878768640/exam/problems/1779778385079140363?type=7&page=0" >题目链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码如下：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假设你从家里出发，从 V1 开始打卡，最后从 Vn 回家</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        String[] split = in.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(split[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> Integer.parseInt(split[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span>[][] g = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>]; <span class="comment">// 标志是否访问过该点</span></span><br><span class="line">        <span class="comment">// 初始不同到达的地方为最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            Arrays.fill(g[i] , INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            String[] split1 = in.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> Integer.parseInt(split1[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Integer.parseInt(split1[<span class="number">1</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> Integer.parseInt(split1[<span class="number">2</span>]);</span><br><span class="line">            g[start][end] = cost;</span><br><span class="line">            g[end][start] = cost;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> Integer.parseInt(in.readLine());</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>  , res = Integer.MAX_VALUE  , mId = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= k; i++) &#123;         <span class="comment">// 一共有k个路线来需要进行 判断哦</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>]; <span class="comment">// 保证每一个网红点之访问一次</span></span><br><span class="line">            split = in.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 表示这条路线一共n个网红点</span></span><br><span class="line">            m = Integer.parseInt(split[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                ints[j] = Integer.parseInt(split[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (g[<span class="number">0</span>][ints[<span class="number">0</span>]] != INF)&#123;</span><br><span class="line">                sum += g[<span class="number">0</span>][ints[<span class="number">0</span>]];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 表示走不通，直接结束本次循环，判断一条路线</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> j ;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[ints[j]][ints[j+<span class="number">1</span>]] != INF &amp;&amp; !vis[ints[j]])&#123;</span><br><span class="line">                    sum += g[ints[j]][ints[j+<span class="number">1</span>]];</span><br><span class="line">                    <span class="comment">// 将当前节点标记为：访问过了</span></span><br><span class="line">                    vis[ints[j]] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 记录走过的网红点数量</span></span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j != m - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 表示非正常退出，中间走不通</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (g[ints[m - <span class="number">1</span>]][<span class="number">0</span>] != INF &amp;&amp; !vis[ints[m-<span class="number">1</span>]] )&#123;</span><br><span class="line">                <span class="comment">// 表示也可以从当前的最后一个景点到达回家中</span></span><br><span class="line">                sum += g[ints[m - <span class="number">1</span>]][<span class="number">0</span>];</span><br><span class="line">                vis[ints[m - <span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt != n)&#123;</span><br><span class="line">                <span class="comment">// 此时一共n个点，如果返回的景点数量不是n，则返回，不正确</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//走到这个地方表示满足了条件</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; res)&#123;</span><br><span class="line">                res = sum;</span><br><span class="line">                mId = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        System.out.println(mId+<span class="string">&quot; &quot;</span>+res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="1-2-记忆化搜索"><a href="#1-2-记忆化搜索" class="headerlink" title="1.2 记忆化搜索"></a>1.2 记忆化搜索</h3><p><a class="link"   href="https://pintia.cn/problem-sets/1779778307878768640/exam/problems/1779778385079140364?type=7&page=0" >题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>   						<a class="link"   href="https://www.cnblogs.com/AlexHoring/p/16068873.html" >相关博文1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; g = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">501</span>]; <span class="comment">// 坚决不浪费一点空间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] step ;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> a , b , u , v , n , m ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        String[] split = in.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        n = Integer.parseInt(split[<span class="number">0</span>]);</span><br><span class="line">        m = Integer.parseInt(split[<span class="number">1</span>]);</span><br><span class="line">        step = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>]; <span class="comment">//  step[i] : 用来表示 从i到目标节点的路径个数</span></span><br><span class="line">        <span class="comment">// 初始化g</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            g.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            split = in.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            u = Integer.parseInt(split[<span class="number">0</span>]);</span><br><span class="line">            v = Integer.parseInt(split[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 构建链接 ： 表示从u出发，下一步可以到达的地方，构成一个list存储</span></span><br><span class="line">            g.get(u).add(v);</span><br><span class="line">        &#125;</span><br><span class="line">        split = in.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        a = Integer.parseInt(split[<span class="number">0</span>]);</span><br><span class="line">        b = Integer.parseInt(split[<span class="number">1</span>]);</span><br><span class="line">        Arrays.fill(step , <span class="number">0</span>);</span><br><span class="line">        step[b] = <span class="number">1</span>;</span><br><span class="line">        vis[b] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 然后开始从a出发，计算到达b的路劲个数</span></span><br><span class="line">        dfs(a);</span><br><span class="line">        System.out.print(step[a]);</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; No&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; Yes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cur)</span> &#123;</span><br><span class="line">        vis[cur] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (g.get(cur).size() == <span class="number">0</span> &amp;&amp; cur != b)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> next : g.get(cur)) &#123;</span><br><span class="line">            <span class="comment">// 然后判断下一个是不是可以访问到</span></span><br><span class="line">            <span class="keyword">if</span> (!vis[next])&#123;</span><br><span class="line">                <span class="comment">// 表示下一个没有访问过，可以进行访问哦</span></span><br><span class="line">                dfs(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 本次结束之后，然后计算</span></span><br><span class="line">            step[cur] += step[next];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>算法</category>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>比赛</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>职业规划讲解</title>
    <url>/2024/04/01/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="职业规划讲解"><a href="#职业规划讲解" class="headerlink" title="职业规划讲解"></a>职业规划讲解</h2><h3 id="1-中国烟草"><a href="#1-中国烟草" class="headerlink" title="1. 中国烟草"></a>1. 中国烟草</h3><ul>
<li>报名时间每年4月份左右</li>
<li><a class="link"   href="https://hnyc.szqjsxh.com/" >官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>备选</li>
</ul>
<h3 id="2-省考公务员"><a href="#2-省考公务员" class="headerlink" title="2. 省考公务员"></a>2. 省考公务员</h3><ul>
<li><p>报名时间每年3-4月份左右</p>
</li>
<li><p>河南省公务员考试官网</p>
</li>
<li><p>备选</p>
</li>
<li><p>专业类别包含关系如下：专业要求为学科门类的，该门类所包含的专业类和一级学科均符合要求；专业要求为一级学科的，该一级学科所包含的二级学科均符合要求；专业要求为专业类的，该专业类所包含的具体专业均符合要求。</p>
</li>
<li><p>2024年1月24日17:00报名系统关闭：2024年3月12日9:00至3月17日9:30期间登录河南人事考试网自行下载打印准考证。</p>
</li>
<li><p>2024年3月16日上午9:00-11:00，行政职业能力测验。</p>
<p>2024年3月16日下午14:00-16:30，申论。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 报考者可于2024年4月中旬登录河南人事考试网查询本人笔试成绩和报考职位名次。</span><br><span class="line">2. 面试时间拟安排在2024年5月中旬</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>人工智能  电子信息类  工学   专业代码：080717T</p>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">26018021  周口市卫生健康委员会 - 电子信息类</span><br><span class="line">11006021  限制人工智能专业</span><br></pre></td></tr></table></figure></div>



<h3 id="4-银行招聘"><a href="#4-银行招聘" class="headerlink" title="4. 银行招聘"></a>4. 银行招聘</h3><ul>
<li>时间：每年3月份</li>
<li><a class="link"   href="https://job.icbc.com.cn/pc/index.html#/main/school/postDetail/00000000000004950584" >中国工商银行官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h3 id="5-中国银行招聘"><a href="#5-中国银行招聘" class="headerlink" title="5. 中国银行招聘"></a>5. 中国银行招聘</h3><ul>
<li>时间：3-4月</li>
<li><a class="link"   href="https://campus.chinahr.com/pages/2024-boc-spring/#/aboutus" >官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>投技术岗</li>
</ul>
<h3 id="6-三桶油"><a href="#6-三桶油" class="headerlink" title="6.三桶油"></a>6.三桶油</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 官网为主</span><br><span class="line"># 中石油、中石化、中海油</span><br></pre></td></tr></table></figure></div>

<h3 id="7-专业对口就业"><a href="#7-专业对口就业" class="headerlink" title="7. 专业对口就业"></a>7. 专业对口就业</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 大数据的就业方向主要有三个：大数据开发、大数据分析和系统研发。这些方向涵盖了从数据采集、存储、处理、分析到应用的全过程。在具体岗位上，主要有大数据开发工程师、大数据系统研发工程师和大数据分析师等。</span><br><span class="line"><span class="number">2.</span> 要抓住大数据领域的机遇，首先要了解市场需求和技术趋势，不断提升自己的技能和知识储备。同时，还应注重实践经验的积累，通过参与实际项目和案例分析来提升自己的实战能力。此外，还应关注行业动态和技术发展，及时跟进新技术和新应用，保持敏锐的市场洞察力。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 总的来说，大数据的就业前景十分美好。随着数据量的不断增长和技术的不断创新，大数据领域将迎来更多的发展机遇。对于有志于从事大数据领域的个人来说，不断提升自己的技能和实践经验，抓住机遇，定能在大数据领域取得成功。同时，企业也应重视大数据人才的培养和引进，打造专业、高效的大数据团队，以应对日益激烈的市场竞争。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 此外，随着人工智能、云计算等新兴技术的快速发展，大数据与这些技术的融合将进一步加速。因此，了解和掌握相关技术也是大数据从业者必备的技能之一。例如，机器学习、数据挖掘等技术在大数据分析中的应用将更加广泛，能够从海量数据中提取更准确、更有价值的信息；云计算技术则能够提供更高效、更灵活的大数据存储和处理服务，降低成本和提高效率。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 总之，大数据领域是一个充满机遇和挑战的领域。对于个人和企业来说，只有不断学习、实践和创新，才能在这个领域取得成功。同时，我们也期待更多的优秀人才和企业加入到大数据领域中来，共同推动这一领域的发展和进步。</span><br></pre></td></tr></table></figure></div>

<ul>
<li><a class="link"   href="https://cloud.tencent.com/developer/article/1797672" >相关博文参考 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>就业</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题总结</title>
    <url>/2024/04/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="面试题目总结"><a href="#面试题目总结" class="headerlink" title="面试题目总结"></a>面试题目总结</h2><h3 id="1-Java-算法"><a href="#1-Java-算法" class="headerlink" title="1. Java-算法"></a>1. Java-算法</h3><h4 id="1-1-运算符"><a href="#1-1-运算符" class="headerlink" title="1.1 &amp; 运算符"></a>1.1 &amp; 运算符</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="comment">// &amp;是是针对二进制的二目运算符。需要注意的是&amp;&amp;是java中判断条件之间表示“和”的标识符，&amp;是一个二目运算符，</span></span><br><span class="line"><span class="comment">// 两个二进制数值如果在同一位上都是1，则结果中该位为1，否则为0，可以认为两个都是true(1)，结果也为true(1)，比如1011 &amp; 0110 = 0010。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;还有一个比较重要的地方，也是面试中经常出现的问题，即该运算符可以计算余数。我们知道四则运算中速度最慢的就是除，而取余操作更加慢，因此可以通过&amp;来快速的求两个数的余数，来看例子：</span></span><br><span class="line"><span class="comment">// 想求45和12（45和8）的余数，只要求45 &amp; 11（45 &amp; 7）</span></span><br><span class="line"><span class="keyword">public</span> ModTest&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="number">45</span> &amp; <span class="number">11</span>);</span><br><span class="line">        System.out.println(<span class="number">45</span> &amp; <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="2-mysql底层索引存储原理"><a href="#2-mysql底层索引存储原理" class="headerlink" title="2. mysql底层索引存储原理"></a>2. mysql底层索引存储原理</h3><h3 id="3-数据库-事务"><a href="#3-数据库-事务" class="headerlink" title="3. 数据库-事务"></a>3. 数据库-事务</h3><ul>
<li><p>事务是一组操作的集合，这组操作，要么全部执行成功，要么全部执行失败。</p>
</li>
<li><p>mysql的事务默认是自动提交，一条语句执行之后就自动提交了</p>
</li>
</ul>
<h4 id="3-1-事务的四大特性"><a href="#3-1-事务的四大特性" class="headerlink" title="3.1 事务的四大特性"></a>3.1 事务的四大特性</h4><ol>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-5c18b0e980eb3c0b462cba5f0b45c31f_720w.webp"
                     
                ></p>
<h4 id="3-2-并发事务问题"><a href="#3-2-并发事务问题" class="headerlink" title="3.2 并发事务问题"></a>3.2 并发事务问题</h4><p>多个并发事务在执行的过程当中出现的问题</p>
<ol>
<li>脏读</li>
<li>不可重复读</li>
<li>幻读</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-3f68066d7a76a739a1e0ccd9cbf525c5_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-f61c1f664cfa8f0a5aef3803985d284d_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-3195f8b3caf5261c5d385766753418da_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-a80aa4738bc26c2d8b216ed16c765d9c_720w.webp"
                     
                ></p>
<h5 id="3-2-1-如何解决"><a href="#3-2-1-如何解决" class="headerlink" title="3.2.1 如何解决"></a>3.2.1 如何解决</h5><p>通过事务不同的隔离级别进行解决（级别越高数据越安全、但效率越低）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-3e661825715813c1462142b154a69ca0_720w.webp"
                     
                ></p>
<h3 id="4-数据库-存储引擎"><a href="#4-数据库-存储引擎" class="headerlink" title="4. 数据库-存储引擎"></a>4. 数据库-存储引擎</h3><h4 id="4-1-mysql的四大体系结构"><a href="#4-1-mysql的四大体系结构" class="headerlink" title="4.1 mysql的四大体系结构"></a>4.1 mysql的四大体系结构</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-8d11c93068d9ea31134c9c54cd56f893_720w.webp"
                     
                ></p>
<h4 id="4-2-mysql的存储引擎"><a href="#4-2-mysql的存储引擎" class="headerlink" title="4.2 mysql的存储引擎"></a>4.2 mysql的存储引擎</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 存储引擎是基于表的，一个数据库下的不同表，可以有不同的存储引擎</span><br><span class="line">2. mysql 5.5 之后，表的默认存储引擎是InnoDB</span><br></pre></td></tr></table></figure></div>

<ol>
<li>如何使用</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-56ad047187644ebcaa1044bec4347e14_720w.webp"
                     
                ></p>
<h4 id="4-3-存储引擎的主要特点"><a href="#4-3-存储引擎的主要特点" class="headerlink" title="4.3 存储引擎的主要特点"></a>4.3 存储引擎的主要特点</h4><ul>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-6c4d14fc53daf0bb7c54d67db0acec6b_720w.webp"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-997639c1dc6b451ea9a7931375afa58b_720w.webp"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picx.zhimg.com/80/v2-7fd36a19700b2ce853bd13dabcc0add4_720w.png"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picx.zhimg.com/80/v2-fb2d8359f76bfae6fed2947504c8c922_720w.png"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picx.zhimg.com/80/v2-613645ff10d8e1f169402b85aaef6c2a_720w.png"
                     
                ></p>
</li>
</ul>
<h4 id="4-4-面试题：InnoDB和MyISAM区别"><a href="#4-4-面试题：InnoDB和MyISAM区别" class="headerlink" title="4. 4 面试题：InnoDB和MyISAM区别"></a>4. 4 面试题：InnoDB和MyISAM区别</h4><p>问InnoDB和MyISAM的区别？（两个存储引擎的区别）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">InnoDB：支持事务、行锁、支持外键</span><br><span class="line">MyISAM: 表锁，不支持事务、不支持外键</span><br></pre></td></tr></table></figure></div>

<h4 id="4-5-存储引擎如何选择"><a href="#4-5-存储引擎如何选择" class="headerlink" title="4.5 存储引擎如何选择"></a>4.5 存储引擎如何选择</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据系统应用特点，选择合适的存储引擎，一般用第一个，两外两个现在一般被MongoDB、redis代替</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-dc5521f08948280368776418ab349a49_720w.png"
                     
                ></p>
<h4 id="4-6-总结"><a href="#4-6-总结" class="headerlink" title="4.6 总结"></a>4.6 总结</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-71e0fd8768c2bec30010d3dc35099d19_720w.png"
                     
                ></p>
<h3 id="5-数据库-索引"><a href="#5-数据库-索引" class="headerlink" title="5. 数据库-索引"></a>5. 数据库-索引</h3><h4 id="5-1-索引概述"><a href="#5-1-索引概述" class="headerlink" title="5.1 索引概述"></a>5.1 索引概述</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picx.zhimg.com/80/v2-e0cb42fd9940f50f2fe6e5d983553ff9_720w.png"
                     
                ></p>
<p>优缺点</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-2fcf4f7479bae0f51782b7f84a846421_720w.webp"
                     
                ></p>
<h4 id="5-2-索引结构-B-树"><a href="#5-2-索引结构-B-树" class="headerlink" title="5.2 索引结构-B+树"></a>5.2 索引结构-<code>B+</code>树</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-93f04ed6072173e2c5275587bb11c9e5_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-b3cbea991d04ba865aa05f013655ba8d_720w.webp"
                     
                ></p>
<ol>
<li>二叉树（二叉搜索树）和红黑树（自平衡的二叉搜索树）</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-68b767b81a0b10f40e24b310e03bdc96_720w.webp"
                     
                ></p>
<ol start="2">
<li>B树（多路平衡搜索树）</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-55a2384359a50d83dfe1cc8358203a52_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-b02db971f6ee7d5f269c6dc102b5b275_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-fefb2b8d4c9f005b6d49bb0f96f8d49f_720w.webp"
                     
                ></p>
<ol start="3">
<li>mysql中优化后的B+树</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-1c9c01683bf9bef3255d16e275dfc0ba_720w.webp"
                     
                ></p>
<h4 id="5-3-索引结构-Hash索引"><a href="#5-3-索引结构-Hash索引" class="headerlink" title="5.3 索引结构-Hash索引"></a>5.3 索引结构-<code>Hash</code>索引</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-e47999db77e42b614561f4b6438e11ea_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-159b077d852143068a03d45d399194ca_720w.webp"
                     
                ></p>
<h4 id="5-4-面试题：存储引擎为啥B-树"><a href="#5-4-面试题：存储引擎为啥B-树" class="headerlink" title="5.4 面试题：存储引擎为啥B+树"></a>5.4 面试题：存储引擎为啥B+树</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-2ec2b9a23a0a7851fff2349c30bf2567_720w.webp"
                     
                ></p>
<h4 id="5-5-索引分类"><a href="#5-5-索引分类" class="headerlink" title="5.5 索引分类"></a>5.5 索引分类</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-45fad34cff2f1c4ebc1cfe4476a05736_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-78fde613289e4bc6bf96fecb6d1cba75_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-80fda657f3ff70b352e2c0ef96514132_720w.webp"
                     
                ></p>
<ol>
<li>举例使用-回表查询</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-64468b11056744b7d10a492c5aa05bd0_720w.webp"
                     
                ></p>
<h4 id="5-6-索引的使用"><a href="#5-6-索引的使用" class="headerlink" title="5.6 索引的使用"></a>5.6 索引的使用</h4><h5 id="1-创建索引"><a href="#1-创建索引" class="headerlink" title="1. 创建索引"></a>1. 创建索引</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建索引 : </span></span><br><span class="line"><span class="keyword">create</span> index 索引名称 <span class="keyword">on</span> 表名（需要索引的字段）</span><br><span class="line"><span class="keyword">CREATE</span> index idx_user_email <span class="keyword">ON</span> `<span class="keyword">user</span>`(email)  		</span><br></pre></td></tr></table></figure></div>

<h5 id="2-查看索引"><a href="#2-查看索引" class="headerlink" title="2. 查看索引"></a>2. 查看索引</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看索引</span></span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="3-删除索引"><a href="#3-删除索引" class="headerlink" title="3. 删除索引"></a>3. 删除索引</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">drop</span> index 需要删除的索引名称 <span class="keyword">on</span> 该索引对应的表名;</span><br><span class="line"><span class="keyword">drop</span> index idx_user_email <span class="keyword">on</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="4-索引小案例"><a href="#4-索引小案例" class="headerlink" title="4. 索引小案例"></a>4. 索引小案例</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-bd9550afd0ff54085d147259dabb501a_720w.webp"
                     
                ></p>
<h4 id="5-7-Sql性能分析"><a href="#5-7-Sql性能分析" class="headerlink" title="5.7 Sql性能分析"></a>5.7 Sql性能分析</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. sql执行频率</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;  <span class="comment">-- 7个下划线哦</span></span><br><span class="line"><span class="comment">-- 2. 然后得到select执行频率比较高的sql语句，开始慢查询，设置时间，就可以得到执行时间比较慢的相关日志信息了</span></span><br><span class="line"><span class="comment">-- 3. 使用profile查看每一条sql的执行时间</span></span><br><span class="line"><span class="comment">-- 4. explain执行计划（主要使用这个）</span></span><br><span class="line">	<span class="comment">-- 目的：就是尽可能将type进行优化	</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-3ddaa3a2225b2f1d3d27e7da908a9cec_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-96333f01e4a552cf03b081df0f629fa0_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-92cda67a094c71422dfe4fd5e43ea417_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-3d920c8adaa46179d264658ac4724ad1_720w.webp"
                     
                ></p>
<p>explain的相关使用和优化点</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-ede4d35c236de77543ccc87886dc9b2e_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-88a3dc4b6408183a5f58f58cea631c0d_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-b3ae73ba65a38d38493f334a1c9f7438_720w.webp"
                     
                ></p>
<h4 id="5-8-索引使用的特殊情况"><a href="#5-8-索引使用的特殊情况" class="headerlink" title="5.8 索引使用的特殊情况"></a>5.8 索引使用的特殊情况</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-d90617e3742e37d416b4e80e311232f2_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-5d0687477b1fbacc3684103995c583fd_720w.webp"
                     
                ></p>
<hr>
<p>索引失效的几种情况：</p>
<ul>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-3800cdd447ac269c33be156d767658df_720w.webp"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-3daeb684631bb0042ccc00d23fe372e4_720w.webp"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-e47c902fa56d9627cd703e757cdf94ef_720w.webp"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-cb9e09870ab1c7201d532ec8e395d1c3_720w.webp"
                     
                ></p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-2635e5cfd60ed5c22873cf5e50366000_720w.webp"
                     
                ></p>
</li>
</ul>
<hr>
<h3 id="1-面试真题"><a href="#1-面试真题" class="headerlink" title="1. 面试真题"></a>1. 面试真题</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">5月28日-大数据开发</span><br><span class="line">	一、java基础部分</span><br><span class="line">        1.自我介绍</span><br><span class="line">        2.Java中==和equles的区别，方法重写、重载的区别</span><br><span class="line">        3.面型对象的三大特征、多态的体现</span><br><span class="line">        4.|和||的区别，使用</span><br><span class="line">        5.Java中的垃圾回收机制</span><br><span class="line">        6.</span><br><span class="line">    二、大数据部分（基础部分）</span><br><span class="line">        1.Hadoop架构、hdfs的上传原理、mr的执行原理</span><br><span class="line">        2.kafka原理，flume的三大核心组件，zookeeper的选举机制（半数原则）</span><br><span class="line">        3.hbase  ---不会这个</span><br><span class="line">        4.spark和mr区别</span><br><span class="line">        5.hivesql的作用，以及他的执行过程</span><br><span class="line">        （</span><br><span class="line">        解析器（SQLParser）：将 SQL 字符串转换成抽象语法树（AST）</span><br><span class="line">        语义分析（Semantic Analyzer）：将 AST 进一步划分为 QeuryBlock</span><br><span class="line">        逻辑计划生成器（Logical Plan Gen）：将语法树生成逻辑计划</span><br><span class="line">        逻辑优化器（Logical Optimizer）：对逻辑计划进行优化</span><br><span class="line">        物理计划生成器（Physical Plan Gen）：根据优化后的逻辑计划生成物理计划</span><br><span class="line">        物理优化器（Physical Optimizer）：对物理计划进行优化</span><br><span class="line">        执行器（Execution）：执行该计划，得到查询结果并返回给客户端</span><br><span class="line">        ）</span><br><span class="line">		6.数据倾斜原因，如何解决</span><br><span class="line">	三、数据库相关（基础部分）</span><br><span class="line">        1.sql优化的方式有哪些？</span><br><span class="line">        2.事务是什么</span><br><span class="line">        3.事务的四大特性</span><br><span class="line">        4.</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	四、项目相关</span><br><span class="line">        1. 讲一下你写的你认为最好的项目，并且遇到的问题，和如何解决</span><br><span class="line">        结尾：</span><br><span class="line">        2. 有什么想问的。</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>算法</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>重生之-我终于学会了Hbase</title>
    <url>/2024/05/06/%E9%87%8D%E7%94%9F%E4%B9%8B-%E6%88%91%E7%BB%88%E4%BA%8E%E5%AD%A6%E4%BC%9A%E4%BA%86Hbase/</url>
    <content><![CDATA[<h1 id="入门Hbase，看这一篇就够了"><a href="#入门Hbase，看这一篇就够了" class="headerlink" title="入门Hbase，看这一篇就够了"></a>入门Hbase，看这一篇就够了</h1><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>Hbase是一种NoSQL数据库，这意味着它不像传统的RDBMS数据库那样支持SQL作为查询语言。Hbase是一种分布式存储的数据库，技术上来讲，它更像是分布式存储而不是分布式数据库，它缺少很多RDBMS系统的特性，比如列类型，辅助索引，触发器，和高级查询语言等待。那Hbase有什么特性呢？如下：</p>
<ul>
<li>强读写一致，但是不是“最终一致性”的数据存储，这使得它非常适合高速的计算聚合</li>
<li>自动分片，通过Region分散在集群中，当行数增长的时候，Region也会自动的切分和再分配</li>
<li>自动的故障转移</li>
<li>Hadoop&#x2F;HDFS集成，和HDFS开箱即用，不用太麻烦的衔接</li>
<li>丰富的“简洁，高效”API，Thrift&#x2F;REST API，Java API</li>
<li>块缓存，布隆过滤器，可以高效的列查询优化</li>
<li>操作管理，Hbase提供了内置的web界面来操作，还可以监控JMX指标</li>
</ul>
<h4 id="什么时候用Hbase？"><a href="#什么时候用Hbase？" class="headerlink" title="什么时候用Hbase？"></a>什么时候用Hbase？</h4><p>Hbase不适合解决所有的问题：</p>
<ul>
<li>首先数据库量要足够多，如果有十亿及百亿行数据，那么Hbase是一个很好的选项，如果只有几百万行甚至不到的数据量，RDBMS是一个很好的选择。因为数据量小的话，真正能工作的机器量少，剩余的机器都处于空闲的状态</li>
<li>其次，如果你不需要辅助索引，静态类型的列，事务等特性，一个已经用RDBMS的系统想要切换到Hbase，则需要重新设计系统。</li>
<li>最后，保证硬件资源足够，每个HDFS集群在少于5个节点的时候，都不能表现的很好。因为HDFS默认的复制数量是3，再加上一个NameNode。</li>
</ul>
<p>Hbase在单机环境也能运行，但是请在开发环境的时候使用。</p>
<h3 id="内部应用"><a href="#内部应用" class="headerlink" title="内部应用"></a>内部应用</h3><ul>
<li>存储业务数据:车辆GPS信息，司机点位信息，用户操作信息，设备访问信息。。。</li>
<li>存储日志数据:架构监控数据（登录日志，中间件访问日志，推送日志，短信邮件发送记录。。。），业务操作日志信息</li>
<li>存储业务附件：UDFS系统存储图像，视频，文档等附件信息</li>
</ul>
<p>不过在公司使用的时候，一般不使用原生的Hbase API，使用原生的API会导致访问不可监控，影响系统稳定性，以致于版本升级的不可控。</p>
<h3 id="Hbase架构"><a href="#Hbase架构" class="headerlink" title="Hbase架构"></a>Hbase架构</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018b9dd013e4~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="img"
                ></p>
<ul>
<li>Zookeeper，作为分布式的协调。RegionServer也会把自己的信息写到ZooKeeper中。</li>
<li>HDFS是Hbase运行的底层文件系统</li>
<li>RegionServer，理解为数据节点，存储数据的。</li>
<li>Master RegionServer要实时的向Master报告信息。Master知道全局的RegionServer运行情况，可以控制RegionServer的故障转移和Region的切分。</li>
</ul>
<h4 id="架构细化"><a href="#架构细化" class="headerlink" title="架构细化"></a>架构细化</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018b9de8f9d3~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image.png"
                ></p>
<ul>
<li>HMaster是Master Server的实现，负责监控集群中的RegionServer实例，同时是所有metadata改变的接口，在集群中，通常运行在NameNode上面，<a class="link"   href="https://link.juejin.cn/?target=http://blog.zahoor.in/2012/08/hbase-hmaster-architecture/" >这里有一篇更细的HMaster介绍 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><ul>
<li>HMasterInterface暴露的接口，Table(createTable, modifyTable, removeTable, enable, disable),ColumnFamily (addColumn, modifyColumn, removeColumn),Region (move, assign, unassign)</li>
<li>Master运行的后台线程：LoadBalancer线程，控制region来平衡集群的负载。CatalogJanitor线程，周期性的检查hbase:meta表。</li>
</ul>
</li>
<li>HRegionServer是RegionServer的实现，服务和管理Regions，集群中RegionServer运行在DataNode<ul>
<li>HRegionRegionInterface暴露接口：Data (get, put, delete, next, etc.)，Region (splitRegion, compactRegion, etc.)</li>
<li>RegionServer后台线程：CompactSplitThread，MajorCompactionChecker，MemStoreFlusher，LogRoller</li>
</ul>
</li>
<li>Regions，代表table，Region有多个Store(列簇)，Store有一个Memstore和多个StoreFiles(HFiles)，StoreFiles的底层是Block。</li>
</ul>
<h4 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a>存储设计</h4><p>在Hbase中，表被分割成多个更小的块然后分散的存储在不同的服务器上，这些小块叫做Regions，存放Regions的地方叫做RegionServer。Master进程负责处理不同的RegionServer之间的Region的分发。在Hbase实现中HRegionServer和HRegion类代表RegionServer和Region。HRegionServer除了包含一些HRegions之外，还处理两种类型的文件用于数据存储</p>
<ul>
<li>HLog， 预写日志文件，也叫做WAL(write-ahead log)</li>
<li>HFile 真实的数据存储文件</li>
</ul>
<h5 id="HLog"><a href="#HLog" class="headerlink" title="HLog"></a>HLog</h5><ul>
<li><p>MasterProcWAL：HMaster记录管理操作，比如解决冲突的服务器，表创建和其它DDLs等操作到它的WAL文件中，这个WALs存储在MasterProcWALs目录下，它不像RegionServer的WALs，HMaster的WAL也支持弹性操作，就是如果Master服务器挂了，其它的Master接管的时候继续操作这个文件。</p>
</li>
<li><p>WAL记录所有的Hbase数据改变，如果一个RegionServer在MemStore进行FLush的时候挂掉了，WAL可以保证数据的改变被应用到。如果写WAL失败了，那么修改数据的完整操作就是失败的。</p>
<ul>
<li>通常情况，每个RegionServer只有一个WAL实例。在2.0之前，WAL的实现叫做HLog</li>
<li>WAL位于*&#x2F;hbase&#x2F;WALs&#x2F;*目录下</li>
<li>MultiWAL: 如果每个RegionServer只有一个WAL，由于HDFS必须是连续的，导致必须写WAL连续的，然后出现性能问题。MultiWAL可以让RegionServer同时写多个WAL并行的，通过HDFS底层的多管道，最终提升总的吞吐量，但是不会提升单个Region的吞吐量。</li>
</ul>
</li>
<li><p>WAL的配置：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line">// 启用multiwal</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.wal.provider<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>multiwal<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><a class="link"   href="https://link.juejin.cn/?target=https://en.wikipedia.org/wiki/Write-ahead_logging" >Wiki百科关于WAL <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h5 id="HFile"><a href="#HFile" class="headerlink" title="HFile"></a>HFile</h5><p>HFile是Hbase在HDFS中存储数据的格式，它包含多层的索引，这样在Hbase检索数据的时候就不用完全的加载整个文件。索引的大小(keys的大小，数据量的大小)影响block的大小，在大数据集的情况下，block的大小设置为每个RegionServer 1GB也是常见的。</p>
<blockquote>
<p>探讨数据库的数据存储方式，其实就是探讨数据如何在磁盘上进行有效的组织。因为我们通常以如何高效读取和消费数据为目的，而不是数据存储本身。</p>
</blockquote>
<h6 id="Hfile生成方式"><a href="#Hfile生成方式" class="headerlink" title="Hfile生成方式"></a>Hfile生成方式</h6><p>起初，HFile中并没有任何Block，数据还存在于MemStore中。</p>
<p>Flush发生时，创建HFile Writer，第一个空的Data Block出现，初始化后的Data Block中为Header部分预留了空间，Header部分用来存放一个Data Block的元数据信息。</p>
<p>而后，位于MemStore中的KeyValues被一个个append到位于内存中的第一个Data Block中：</p>
<p><strong>注</strong>：如果配置了Data Block Encoding，则会在Append KeyValue的时候进行同步编码，编码后的数据不再是单纯的KeyValue模式。Data Block Encoding是HBase为了降低KeyValue结构性膨胀而提供的内部编码机制。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018b9e40d3ed~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image.png"
                ></p>
<h6 id="读写简流程"><a href="#读写简流程" class="headerlink" title="读写简流程"></a>读写简流程</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018b9ef276ff~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image.png"
                ></p>
<h3 id="Hbase单机模式安装"><a href="#Hbase单机模式安装" class="headerlink" title="Hbase单机模式安装"></a>Hbase单机模式安装</h3><p>这一次来部署一个单机版的Hbase，单独的Hbase daemon(Master，RegionServers和ZooKeeper)运行在同一个JVM进程中，然后持久化存储到文件系统中。这是最简单的部署，但是却能帮助我们更好的理解Hbase。安装完成之后，我们在演示一下hbase命令行的用法。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018ba01e667a~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ul>
<li>CentOS 7</li>
<li>Hbase 1.2.8</li>
</ul>
<h4 id="安装单机"><a href="#安装单机" class="headerlink" title="安装单机"></a>安装单机</h4><ol>
<li>确保安装了jdk，在Linux上使用自带的包管理器直接安装就好，使用二进制也是一个不错的选择，我用的是CentOS</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk* -y</span><br></pre></td></tr></table></figure></div>

<ol>
<li>下载Hbase的二进制包，下载地址位于<a class="link"   href="https://link.juejin.cn/?target=http://mirror.bit.edu.cn/apache/hbase/hbase-1.2.8/%EF%BC%8C%E7%84%B6%E5%90%8E%E8%A7%A3%E5%8E%8B%E5%88%B0%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E5%BD%95%E3%80%82" >mirror.bit.edu.cn&#x2F;apache&#x2F;hbas… <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xf hbase-1.2.8-bin.tar.gz</span><br><span class="line"><span class="built_in">cd</span> hbase-1.2.8</span><br></pre></td></tr></table></figure></div>

<ol>
<li>配置hbase的环境变量，修改JAVA_HOME。注意看下自己的JAVA_HOME在什么位置</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018ba06048ac~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">vim conf/hbase-env.<span class="property">sh</span></span><br><span class="line"><span class="comment">// 注意这个是在CentOS上的java位置</span></span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">JAVA_HOME</span>=<span class="regexp">/etc/</span>alternatives/java_sdk_1<span class="number">.8</span><span class="number">.0</span>/</span><br></pre></td></tr></table></figure></div>

<ol>
<li>配置onf&#x2F;hbase-site.xml，这个是Hbase的主配置文件，你可以指定hbase和ZooKeeper数据写入的目录，当然也可以指定hbase的根目录在哪个位置。</li>
</ol>
<p>我将hbase的目录放在hadoop用户家目录的hbase目录下。我们不用事先创建好hbase的data目录，hbase会自动帮我们创建好的，如果已经存在了data目录，hbase会将存在的目录进行迁移。</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line">useradd -s /sbin/nologin -m hadoop</span><br><span class="line"></span><br><span class="line">vim conf/hbase-site.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///home/hadoop/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/zookeeper<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.unsafe.stream.capability.enforce<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">      Controls whether HBase will check for stream capabilities (hflush/hsync).</span><br><span class="line"></span><br><span class="line">      Disable this if you intend to run on LocalFileSystem, denoted by a rootdir</span><br><span class="line">      with the &#x27;file://&#x27; scheme, but be mindful of the NOTE below.</span><br><span class="line"></span><br><span class="line">      WARNING: Setting this to false blinds you to potential data loss and</span><br><span class="line">      inconsistent system state in the event of process and/or node failures. If</span><br><span class="line">      HBase is complaining of an inability to use hsync or hflush it&#x27;s most</span><br><span class="line">      likely not a false positive.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>Hbase二进制包下有start-hbase脚本，可以方便的启动hbase，如果我们的配置是正确的，那么会正常启动。</li>
</ol>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/start-hbase.sh</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018bd4dc319a~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<p>如果启动之后，可以打开<a class="link"   href="https://link.juejin.cn/?target=http://localhost:16010%E6%9F%A5%E7%9C%8BHbase%E7%9A%84Web" >http://localhost:16010查看Hbase的Web <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> UI</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018bdb5bdd93~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<h4 id="使用Hbase"><a href="#使用Hbase" class="headerlink" title="使用Hbase"></a>使用Hbase</h4><p>我们可以先用Hbase提供的命令行工具，位于hbase的&#x2F;bin&#x2F;目录下</p>
<ol>
<li>连接Hbase</li>
</ol>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./hbase shell</span><br></pre></td></tr></table></figure></div>

<ol>
<li>查看帮助信息, 敲</li>
</ol>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="built_in">help</span></span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018bf0d5f7ee~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<ol>
<li>创建一个表，必须要指定表名称和列簇名</li>
</ol>
<div class="highlight-container" data-rel="Ruby"><figure class="iseeu highlight ruby"><table><tr><td class="code"><pre><span class="line">ruby复制代码hbase(main)<span class="symbol">:</span><span class="number">003</span><span class="symbol">:</span><span class="number">0</span>&gt; create <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;cf&#x27;</span></span><br><span class="line"><span class="number">0</span> row(s) <span class="keyword">in</span> <span class="number">1.6320</span> seconds</span><br><span class="line"></span><br><span class="line">=&gt; <span class="title class_">Hbase</span><span class="symbol">:</span><span class="symbol">:Table</span> - test</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018bf5abf323~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<ol>
<li>列出关于你的表的信息,list ‘sometable’</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018bffa790cb~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<ol>
<li>查看表更为详细的信息，使用describe命令</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018c0b3e7516~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<ol>
<li>把数据放到表中</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018c14057e09~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<ol>
<li>查看表中的所有数据</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018c19b3c68f~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<ol>
<li>获取单行的数据</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018c257d6cda~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<ol>
<li>其余的命令可以自行尝试</li>
<li>退出shell，使用<code>quit</code></li>
</ol>
<p>这里演示了下单机版的hbase如何安装，了解hbase shell的基本用法，关于Hbase更深入的东西，可以了解下官方文档。</p>
<h3 id="Hbase数据模型"><a href="#Hbase数据模型" class="headerlink" title="Hbase数据模型"></a>Hbase数据模型</h3><p>在Hbase中，有一些术语需要提前了解。如下：</p>
<ul>
<li>Table：Hbase的table由多个行组成</li>
<li>Row：一个行在Hbase中由一个或多个有值的列组成。Row按照字母进行排序，因此行健的设计非常重要。这种设计方式可以让有关系的行非常的近，通常行健的设计是网站的域名反转，比如(org.apache.www, org.apache.mail, org.apache.jira)，这样的话所有的Apache的域名就很接近。</li>
<li>Column：列由列簇加上列的标识组成，一般是“列簇：列标识”，创建表的时候不用指定列标识</li>
<li>Column Family：列簇在物理上包含了许多的列与列的值，每个列簇都有一些存储的属性可配置。例如是否使用缓存，压缩类型，存储版本数等。在表中，每一行都有相同的列簇，尽管有些列簇什么东西也没有存。</li>
<li>Column Qualifier：列簇的限定词，理解为列的唯一标识。但是列标识是可以改变的，因此每一行可能有不同的列标识</li>
<li>Cell：Cell是由row，column family,column qualifier包含时间戳与值组成的，一般表达某个值的版本</li>
<li>Timestamp：时间戳一般写在value的旁边，代表某个值的版本号，默认的时间戳是你写入数据的那一刻，但是你也可以在写入数据的时候指定不同的时间戳</li>
</ul>
<p>HBase 是一个稀疏的、分布式、持久、多维、排序的映射，它以行键（row key），列键（column key）和时间戳（timestamp）为索引。</p>
<p>Hbase在存储数据的时候，有两个SortedMap，首先按照rowkey进行字典排序，然后再对Column进行字典排序。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018c2940da66~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="img"
                ></p>
<h4 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">create &#x27;user&#x27;,&#x27;info&#x27;,&#x27;ship&#x27;;</span><br><span class="line"></span><br><span class="line">put &#x27;user&#x27;, &#x27;524382618264914241&#x27;, &#x27;info:name&#x27;, &#x27;zhangsan&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;524382618264914241&#x27;, &#x27;info:age&#x27;,30</span><br><span class="line">put &#x27;user&#x27;, &#x27;524382618264914241&#x27;, &#x27;info:height&#x27;,168</span><br><span class="line">put &#x27;user&#x27;, &#x27;524382618264914241&#x27;, &#x27;info:weight&#x27;,168</span><br><span class="line">put &#x27;user&#x27;, &#x27;524382618264914241&#x27;, &#x27;info:phone&#x27;,&#x27;13212321424&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;524382618264914241&#x27;, &#x27;ship:addr&#x27;,&#x27;beijing&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;524382618264914241&#x27;, &#x27;ship:email&#x27;,&#x27;sina@sina.com&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;524382618264914241&#x27;, &#x27;ship:salary&#x27;,3000</span><br><span class="line"></span><br><span class="line">put &#x27;user&#x27;, &#x27;224382618261914241&#x27;, &#x27;info:name&#x27;, &#x27;lisi&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;224382618261914241&#x27;, &#x27;info:age&#x27;,24</span><br><span class="line">put &#x27;user&#x27;, &#x27;224382618261914241&#x27;, &#x27;info:height&#x27;,158</span><br><span class="line">put &#x27;user&#x27;, &#x27;224382618261914241&#x27;, &#x27;info:weight&#x27;,128</span><br><span class="line">put &#x27;user&#x27;, &#x27;224382618261914241&#x27;, &#x27;info:phone&#x27;,&#x27;13213921424&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;224382618261914241&#x27;, &#x27;ship:addr&#x27;,&#x27;chengdu&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;224382618261914241&#x27;, &#x27;ship:email&#x27;,&#x27;qq@sina.com&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;224382618261914241&#x27;, &#x27;ship:salary&#x27;,5000</span><br><span class="line"></span><br><span class="line">put &#x27;user&#x27;, &#x27;673782618261019142&#x27;, &#x27;info:name&#x27;, &#x27;zhaoliu&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;673782618261019142&#x27;, &#x27;info:age&#x27;,19</span><br><span class="line">put &#x27;user&#x27;, &#x27;673782618261019142&#x27;, &#x27;info:height&#x27;,178</span><br><span class="line">put &#x27;user&#x27;, &#x27;673782618261019142&#x27;, &#x27;info:weight&#x27;,188</span><br><span class="line">put &#x27;user&#x27;, &#x27;673782618261019142&#x27;, &#x27;info:phone&#x27;,&#x27;17713921424&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;673782618261019142&#x27;, &#x27;ship:addr&#x27;,&#x27;shenzhen&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;673782618261019142&#x27;, &#x27;ship:email&#x27;,&#x27;126@sina.com&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;673782618261019142&#x27;, &#x27;ship:salary&#x27;,8000</span><br><span class="line"></span><br><span class="line">put &#x27;user&#x27;, &#x27;813782218261011172&#x27;, &#x27;info:name&#x27;, &#x27;wangmazi&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;813782218261011172&#x27;, &#x27;info:age&#x27;,19</span><br><span class="line">put &#x27;user&#x27;, &#x27;813782218261011172&#x27;, &#x27;info:height&#x27;,158</span><br><span class="line">put &#x27;user&#x27;, &#x27;813782218261011172&#x27;, &#x27;info:weight&#x27;,118</span><br><span class="line">put &#x27;user&#x27;, &#x27;813782218261011172&#x27;, &#x27;info:phone&#x27;,&#x27;12713921424&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;813782218261011172&#x27;, &#x27;ship:addr&#x27;,&#x27;xian&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;813782218261011172&#x27;, &#x27;ship:email&#x27;,&#x27;139@sina.com&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;813782218261011172&#x27;, &#x27;ship:salary&#x27;,10000</span><br><span class="line"></span><br><span class="line">put &#x27;user&#x27;, &#x27;510824118261011172&#x27;, &#x27;info:name&#x27;, &#x27;yangyang&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;510824118261011172&#x27;, &#x27;info:age&#x27;,18</span><br><span class="line">put &#x27;user&#x27;, &#x27;510824118261011172&#x27;, &#x27;info:height&#x27;,188</span><br><span class="line">put &#x27;user&#x27;, &#x27;510824118261011172&#x27;, &#x27;info:weight&#x27;,138</span><br><span class="line">put &#x27;user&#x27;, &#x27;510824118261011172&#x27;, &#x27;info:phone&#x27;,&#x27;18013921626&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;510824118261011172&#x27;, &#x27;ship:addr&#x27;,&#x27;shanghai&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;510824118261011172&#x27;, &#x27;ship:email&#x27;,&#x27;199@sina.com&#x27;</span><br><span class="line">put &#x27;user&#x27;, &#x27;510824118261011172&#x27;, &#x27;ship:salary&#x27;,50000</span><br></pre></td></tr></table></figure></div>

<h3 id="Hbase表-Schema-设计要点"><a href="#Hbase表-Schema-设计要点" class="headerlink" title="Hbase表(Schema)设计要点"></a>Hbase表(Schema)设计要点</h3><p>只要是数据库都存在，模式设计的问题，关系型中有模式设计的范式，Hbase作为列式存储数据库，其模式设计也非常重要。</p>
<p>设计时需要关注的属性，如何设计这些属性等</p>
<h4 id="Hbase与关系型数据库对比"><a href="#Hbase与关系型数据库对比" class="headerlink" title="Hbase与关系型数据库对比"></a>Hbase与关系型数据库对比</h4><table>
<thead>
<tr>
<th>属性</th>
<th>Hbase</th>
<th>RDBMS</th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>只有字符串</td>
<td>丰富的数据类型</td>
</tr>
<tr>
<td>数据操作</td>
<td>增删改查，不支持join</td>
<td>各种各样的函数与表连接</td>
</tr>
<tr>
<td>存储模式</td>
<td>基于列式存储</td>
<td>基于表结构和行式存储</td>
</tr>
<tr>
<td>数据保护</td>
<td>更新后仍然保留旧版本</td>
<td>替换</td>
</tr>
<tr>
<td>可伸缩性</td>
<td>轻易增加节点</td>
<td>需要中间层，牺牲性能</td>
</tr>
</tbody></table>
<h4 id="Hbase设计时要考虑的因素"><a href="#Hbase设计时要考虑的因素" class="headerlink" title="Hbase设计时要考虑的因素"></a>Hbase设计时要考虑的因素</h4><p>Hbase关键概念：表，rowkey，列簇，时间戳</p>
<ul>
<li>这个表应该有多少列簇</li>
<li>列簇使用什么数据</li>
<li>每个列簇有有多少列</li>
<li>列名是什么，尽管列名不必在建表时定义，但读写数据是要知道的</li>
<li>单元应该存放什么数据</li>
<li>每个单元存储多少时间版本</li>
<li>行健(rowKey)结构是什么，应该包含什么信息</li>
</ul>
<h4 id="设计要点"><a href="#设计要点" class="headerlink" title="设计要点"></a>设计要点</h4><h5 id="行健设计"><a href="#行健设计" class="headerlink" title="行健设计"></a>行健设计</h5><p>关键部分，直接关系到后续服务的访问性能。如果行健设计不合理，后续查询服务效率会成倍的递减。</p>
<ul>
<li>避免单调的递增行健，因为Hbase的行健是有序排列的，这样可能导致一段时间内大部分写入集中在某一个Region上进行操作，负载都在一台节点上。可以设计成： [metric_type][event_timestamp]，不同的metric_type可以将压力分散到不同的region上</li>
<li>行健短到可读即可，因为查询短键不必长键性能好多少，所以设计时要权衡长度。</li>
<li>行健不能改变，<strong>唯一可以改变的方式是先删除后插入</strong></li>
</ul>
<h5 id="列簇设计"><a href="#列簇设计" class="headerlink" title="列簇设计"></a>列簇设计</h5><p>列簇是一些列的集合，一个列簇的成员有相同的前缀，以冒号(:)作为分隔符。</p>
<ul>
<li>现在Hbase不能很好处理2~3个以上的列簇，所以尽可能让列簇少一些，如果表有多个列簇，列簇A有100万行数据，列簇B有10亿行，那么列簇A会分散到很多的Region导致扫描列簇A的时候效率底下。</li>
<li>列簇名的长度要尽量小，一个为了节省空间，另外加快效率，比如d表示data，v表示value</li>
</ul>
<h5 id="列簇属性配置"><a href="#列簇属性配置" class="headerlink" title="列簇属性配置"></a>列簇属性配置</h5><ul>
<li>HFile数据块，默认是64KB，数据库的大小影响数据块索引的大小。数据块大的话一次加载进内存的数据越多，扫描查询效果越好。但是数据块小的话，随机查询性能更好</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; create <span class="string">&#x27;mytable&#x27;</span>,&#123;<span class="function"><span class="params">NAME</span> =&gt;</span> <span class="string">&#x27;cf1&#x27;</span>, <span class="function"><span class="params">BLOCKSIZE</span> =&gt;</span> <span class="string">&#x27;65536&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>数据块缓存，数据块缓存默认是打开的，如果一些比较少访问的数据可以选择关闭缓存</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; create <span class="string">&#x27;mytable&#x27;</span>,&#123;<span class="function"><span class="params">NAME</span> =&gt;</span> <span class="string">&#x27;cf1&#x27;</span>, <span class="function"><span class="params">BLOCKCACHE</span> =&gt;</span> <span class="string">&#x27;FALSE&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>数据压缩，压缩会提高磁盘利用率，但是会增加CPU的负载，看情况进行控制</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; create <span class="string">&#x27;mytable&#x27;</span>,&#123;<span class="function"><span class="params">NAME</span> =&gt;</span> <span class="string">&#x27;cf1&#x27;</span>, <span class="function"><span class="params">COMPRESSION</span> =&gt;</span> <span class="string">&#x27;SNAPPY&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></div>

<p>Hbase表设计是和需求相关的，但是遵守表设计的一些硬性指标对性能的提升还是很有帮助的，这里整理了一些设计时用到的要点。</p>
<h3 id="Java-API操作"><a href="#Java-API操作" class="headerlink" title="Java API操作"></a>Java API操作</h3><p>Hbase有多种不同的客户端，如REST客户端，Thift客户端，ORM框架Kundera等等。 Hbase也提供了Java的API来操作表与列簇等信息，它的shell就是对Java的API做了一层封装。</p>
<p>Hbase的Java API提供了很多高级的特性：</p>
<ul>
<li>元数据管理，列簇的数据压缩，region分隔</li>
<li>创建，删除，更新，读取 rowkey</li>
</ul>
<p>我们还是直接看代码这样理解的更容易</p>
<h4 id="环境-1"><a href="#环境-1" class="headerlink" title="环境"></a>环境</h4><ul>
<li>Hbase 0.98</li>
<li>Java 1.8</li>
<li>Zookeeper 3.4.6</li>
<li>Mac OS</li>
</ul>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>Hbase的客户端版本不一致实验结果很容易出现问题，尽量采用同样的版本。因为服务端实验的是Hbase0.98，客户端也用0.98，另外由于Hadoop 2.x的版本现对于1.x做了很大的提升，建议采用Hbase-hadoop 2.x的客户端。</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.98.24-hadoop2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h5 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h5><ol>
<li>直接新建HTable(“tableName”)，但是这种每次创建表的时候因为都要查询.meta表，来判断表是不是存在，导致创建表的过程会有点慢，所以不建议每个请求都创建一个Htable</li>
<li>使用HTablePool，它和HTable的创建方式很像，但是如果采用连接池的话，它就不会给每个请求都单独创建一个Htable了。</li>
</ol>
<p>在创建Htable或者HtablePool的时候都可以指定更详细的配置信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018c3035163d~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018c39b2b2ee~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">java复制代码<span class="type">HTablePool</span> <span class="variable">hTablePool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTablePool</span>();</span><br><span class="line">hTablePool.getTable(<span class="string">&quot;user&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h5 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h5><p>rowkey是代表Hbase中表的唯一一个行，同时像列簇 ，时间戳等用来定位表中的部分数据，Java的API对Hbas的CURD提供了如下的类：</p>
<ul>
<li>Put</li>
<li>Get</li>
<li>Delete</li>
<li>Scan</li>
<li>Increment</li>
</ul>
<p>我们详细的讨论几个类，剩余的可以举一反三。</p>
<h5 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h5><p>当写请求收到的时候，默认数据同步的写到Hlog中和MemStore，同时在两个地方写是为了保证数据的持久性，Memstore最终会持久化到磁盘中的Hfile中。每次MemStore进行Flush的时候，就会创建一个新的Hfile。</p>
<p>Put类用于向Hbase的表中存储数据，存储数据时，Put的实例必须要指定Rowkey <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018c43a23ac3~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<p>创建完Put实例后，再向其中添加数据 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018c503fc8bc~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="comment">// 获取默认的配置</span></span><br><span class="line">       <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> HBaseConfiguration.create();</span><br><span class="line">       <span class="comment">// 获取Table实例 </span></span><br><span class="line">       <span class="type">HTable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTable</span>(conf, <span class="string">&quot;tab1&quot;</span>);</span><br><span class="line">       <span class="comment">// 创建Put实例，并且指定rowKey </span></span><br><span class="line">       <span class="type">Put</span> <span class="variable">put</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Put</span>(Bytes.toBytes(<span class="string">&quot;row-1&quot;</span>));</span><br><span class="line">       <span class="comment">// 添加一个 column，值为 &quot;Hello&quot;，在 &quot;cf1:greet&quot; 列中</span></span><br><span class="line">       put.add(Bytes.toBytes(<span class="string">&quot;cf1&quot;</span>), Bytes.toBytes(<span class="string">&quot;greet&quot;</span>), Bytes.toBytes(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">       <span class="comment">// 添加一个 column，值为 &quot;John&quot;，在 &quot;cf1:person&quot; 列中</span></span><br><span class="line">       put.add(Bytes.toBytes(<span class="string">&quot;cf1&quot;</span>), Bytes.toBytes(<span class="string">&quot;person&quot;</span>), Bytes.toBytes(<span class="string">&quot;John&quot;</span>));</span><br><span class="line">       table.put(put); </span><br><span class="line">       table.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>数据也可以批量的进行插入：</p>
<p>&#x2F;&#x2F; table对象可以传入List参数 table.put(final List puts)</p>
<p>执行结果： <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018c4d2cf191~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<h5 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h5><p>Hbase使用LRU缓存读取数据。Htable对象使用下面的方法读取数据</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018c5b2df959~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<p>而Get实例的构造方法和Put很像，构造方法要指定一个rowkey。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018c6a57d0a5~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<p>如果要查找特定的cell，就是特定列的数据，可以采用额外的方法进行更加精细的调控。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018c6be5baca~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<p>看一下如下的案例代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取默认的配置</span></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> HBaseConfiguration.create();</span><br><span class="line">        <span class="comment">// 获取Table实例</span></span><br><span class="line">        <span class="type">HTable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTable</span>(conf, <span class="string">&quot;tab1&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建Put实例，并且指定rowKey</span></span><br><span class="line">        <span class="type">Get</span> <span class="variable">get</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Get</span>(Bytes.toBytes(<span class="string">&quot;row-1&quot;</span>));</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        get.addColumn(Bytes.toBytes(<span class="string">&quot;cf1&quot;</span>), Bytes.toBytes(<span class="string">&quot;greet&quot;</span>));</span><br><span class="line">        <span class="comment">// 添加一个 column，值为 &quot;John&quot;，在 &quot;cf1:person&quot; 列中</span></span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> table.get(get);</span><br><span class="line">        <span class="type">byte</span>[] value = result.getValue(Bytes.toBytes(<span class="string">&quot;cf1&quot;</span>), Bytes.toBytes(<span class="string">&quot;greet&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;获取到的值&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(value));</span><br><span class="line">        table.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>执行结果 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018c6e7fcd00~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<h5 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h5><p>更新数据与写数据基本一致，只是在Put实例赋值的时候，在相同的列上设置不同的值，操作的时候就会更新为新的值。</p>
<p>代码如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> HBaseConfiguration.create();</span><br><span class="line">        <span class="comment">// 获取Table实例</span></span><br><span class="line">        <span class="type">HTable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTable</span>(conf, <span class="string">&quot;tab1&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建Put实例，并且指定rowKey</span></span><br><span class="line">        <span class="type">Put</span> <span class="variable">put</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Put</span>(Bytes.toBytes(<span class="string">&quot;row-1&quot;</span>));</span><br><span class="line">        <span class="comment">// 添加一个 column，值为 &quot;Hello&quot;，在 &quot;cf1:greet&quot; 列中</span></span><br><span class="line">        put.add(Bytes.toBytes(<span class="string">&quot;cf1&quot;</span>), Bytes.toBytes(<span class="string">&quot;greet&quot;</span>), Bytes.toBytes(<span class="string">&quot;Good Morning&quot;</span>));</span><br><span class="line">        <span class="comment">// 添加一个 column，值为 &quot;John&quot;，在 &quot;cf1:person&quot; 列中</span></span><br><span class="line"><span class="comment">//        put.add(Bytes.toBytes(&quot;cf1&quot;), Bytes.toBytes(&quot;person&quot;), Bytes.toBytes(&quot;John&quot;));</span></span><br><span class="line">        table.put(put);</span><br><span class="line">        table.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>执行结果： <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018c7c284dfe~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<h5 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h5><p>Delete命令只是标记当前的数据为删除状态，而不是立刻的删除，也就是先进行逻辑删除。实际上的删除是在Hfile进行压缩的时候，这些被标记的记录就会被删除掉。</p>
<p>Delete对象与Put和Get也很像</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018c84f8c844~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<p>构造Delete实例 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018c8502485a~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<p>如果想要进行更加详细的指定，可以再指定具体的列等信息 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018ca0a3cc71~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<p>看下面的案例代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> HBaseConfiguration.create();</span><br><span class="line">        <span class="comment">// 获取Table实例</span></span><br><span class="line">        <span class="type">HTable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTable</span>(conf, <span class="string">&quot;tab1&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建Delete实例，并且指定rowKey</span></span><br><span class="line">        <span class="type">Delete</span> <span class="variable">delete</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Delete</span>(Bytes.toBytes(<span class="string">&quot;row-1&quot;</span>));</span><br><span class="line">        <span class="comment">// 删除 column &quot;cf1:greet&quot; </span></span><br><span class="line">        delete.deleteColumn(Bytes.toBytes(<span class="string">&quot;cf1&quot;</span>), Bytes.toBytes(<span class="string">&quot;greet&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        table.delete(delete);</span><br><span class="line">        table.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>执行结果:连续执行两次删除</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018ca09dbb19~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<h3 id="操作优化"><a href="#操作优化" class="headerlink" title="操作优化"></a>操作优化</h3><p>一个系统上线之后，开发和调优将一直贯穿系统的生命周期中，HBase也不列外。这里主要说一些Hbase的调优</p>
<h4 id="Hbase查询优化"><a href="#Hbase查询优化" class="headerlink" title="Hbase查询优化"></a>Hbase查询优化</h4><p>作为NoSQL数据库，增删改查是其最基本的功能，其中查询是最常用的一项。</p>
<h5 id="设置Scan缓存"><a href="#设置Scan缓存" class="headerlink" title="设置Scan缓存"></a>设置Scan缓存</h5><p>HBase中Scan查询可以设置缓存，方法是setCaching()，这样可以有效的减少服务端与客户端的交互，更有效的提升扫描查询的性能。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the number of rows for caching that will be passed to scanners.</span></span><br><span class="line"><span class="comment"> * If not set, the default setting from &#123;<span class="doctag">@link</span> HTable#getScannerCaching()&#125; will apply.</span></span><br><span class="line"><span class="comment"> * Higher caching values will enable faster scanners but will use more memory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> caching the number of rows for caching</span></span><br><span class="line"><span class="comment"> * 设置scanners缓存的行数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCaching</span><span class="params">(<span class="type">int</span> caching)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.caching = caching;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="显示的指定列"><a href="#显示的指定列" class="headerlink" title="显示的指定列"></a>显示的指定列</h5><p>当使用Scan或者GET获取大量的行时，最好指定所需要的列，因为服务端通过网络传输到客户端，数据量太大可能是瓶颈。如果能有效过滤部分数据，能很大程度的减少网络I&#x2F;O的花费。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get all columns from the specified family.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * Overrides previous calls to addColumn for this family.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> family family name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">   * 获取指定列簇的所有列</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> Scan <span class="title function_">addFamily</span><span class="params">(<span class="type">byte</span> [] family)</span> &#123;</span><br><span class="line">    familyMap.remove(family);</span><br><span class="line">    familyMap.put(family, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the column from the specified family with the specified qualifier.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * Overrides previous calls to addFamily for this family.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> family family name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> qualifier column qualifier</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">   * 获取指定列簇的特定列</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> Scan <span class="title function_">addColumn</span><span class="params">(<span class="type">byte</span> [] family, <span class="type">byte</span> [] qualifier)</span> &#123;</span><br><span class="line">    NavigableSet&lt;<span class="type">byte</span> []&gt; set = familyMap.get(family);</span><br><span class="line">    <span class="keyword">if</span>(set == <span class="literal">null</span>) &#123;</span><br><span class="line">      set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;<span class="type">byte</span> []&gt;(Bytes.BYTES_COMPARATOR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (qualifier == <span class="literal">null</span>) &#123;</span><br><span class="line">      qualifier = HConstants.EMPTY_BYTE_ARRAY;</span><br><span class="line">    &#125;</span><br><span class="line">    set.add(qualifier);</span><br><span class="line">    familyMap.put(family, set);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>一般用: scan.addColumn(…)</p>
<h5 id="关闭ResultScanner"><a href="#关闭ResultScanner" class="headerlink" title="关闭ResultScanner"></a>关闭ResultScanner</h5><p>如果在使用table.getScanner之后，忘记关闭该类，它会一直和服务端保持连接，资源无法释放，从而导致服务端的某些资源不可用。</p>
<p>所以在用完之后，需要执行关闭操作，这点与JDBS操作MySQL类似</p>
<p>scanner.close()</p>
<h5 id="禁用块缓存"><a href="#禁用块缓存" class="headerlink" title="禁用块缓存"></a>禁用块缓存</h5><p>如果批量进行全表扫描，默认是有缓存的，如果此时有缓存，会降低扫描的效率。</p>
<p>scan.setCacheBlocks(true|false);</p>
<p>对于经常读到的数据，建议使用默认值，开启块缓存</p>
<h5 id="缓存查询结果"><a href="#缓存查询结果" class="headerlink" title="缓存查询结果"></a>缓存查询结果</h5><p>对于频繁查询HBase的应用场景，可以考虑在应用程序和Hbase之间做一层缓存系统，新的查询先去缓存查，缓存没有再去查Hbase。</p>
<h4 id="写入优化"><a href="#写入优化" class="headerlink" title="写入优化"></a>写入优化</h4><p>写也是Hbase常有的操作之一，并且Hbase在写入操作上有着其他NoSQL无法比拟的优势，下面讲如何优化写入操作</p>
<h5 id="关闭写WAL日志"><a href="#关闭写WAL日志" class="headerlink" title="关闭写WAL日志"></a>关闭写WAL日志</h5><p>一般为了保证系统的高可用性，WAL日志默认是开启状态，WAL主要用于灾难恢复的，如果应用可以容忍一定的数据丢失风险，可以在写数据的时候，关闭写WAL。</p>
<p><strong>风险：</strong> 当RegionServer宕机时，写入的数据出现丢失，且无法恢复</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018ca5ae2d21~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image.png"
                ></p>
<h5 id="设置AutoFlush"><a href="#设置AutoFlush" class="headerlink" title="设置AutoFlush"></a>设置AutoFlush</h5><p>Htable有一个属性是AutoFlush，该属性用于支持客户端的批量更新，默认是true，当客户端每收到一条数据，立刻发送到服务端，如果设置为false，当客户端提交put请求时候，先将该请求在客户端缓存，到达阈值的时候或者执行hbase.flushcommits()，才向RegionServer提交请求。</p>
<p><strong>风险</strong> 在请求未发送到RegionServer之前客户端崩溃，数据也会丢失</p>
<div class="highlight-container" data-rel="Lua"><figure class="iseeu highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">table</span>.setAutoFlush(<span class="literal">false</span>);</span><br><span class="line">      <span class="built_in">table</span>.setWriteBufferSize( <span class="number">12</span> * <span class="number">1024</span> * <span class="number">1024</span> );</span><br></pre></td></tr></table></figure></div>

<h5 id="预创建Region"><a href="#预创建Region" class="headerlink" title="预创建Region"></a>预创建Region</h5><p>一般表刚开始只有一个Region，插入该表的数据都会保存在此Region中，插入该表的所有塑化剂都会保存在该Region中，当到达一定的阈值时，才发生分裂。 这样开始时刻针对该表的写操作都集中在某台服务器上，造成这台服务器的压力很紧张，同时对整个集群资源的浪费</p>
<p>建议刚开始的时候预创建Region，可以使用Hbase自带的RegionSplitter</p>
<h5 id="延迟日志flush"><a href="#延迟日志flush" class="headerlink" title="延迟日志flush"></a>延迟日志flush</h5><p>默认写入操作，首先写入WAL，并且在1S内写入HDFS，这个时间默认是1S，可以通过参数配置</p>
<p>hbase.regionserver.optionallogflushinterval</p>
<p>可以配置大一点的值，比如5s，这段时间数据会保留在内存中，直到RegionServer周期性的执行flush操作。</p>
<h3 id="Scan的重要参数"><a href="#Scan的重要参数" class="headerlink" title="Scan的重要参数"></a>Scan的重要参数</h3><p>Scan是操作Hbase中非常常用的一个操作，虽然前面的Hbase API操作简单的介绍了Scan的操作，但不够详细，由于Scan非常常用，关于其详细的整理也是很有必要的。</p>
<h5 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h5><p>HBase中的数据表通过划分成一个个的Region来实现数据的分片，每一个Region关联一个RowKey的范围区间，而每一个Region中的数据，按RowKey的字典顺序进行组织。</p>
<p>正是基于这种设计，使得HBase能够轻松应对这类查询：”指定一个RowKey的范围区间，获取该区间的所有记录”， 这类查询在HBase被称之为Scan。</p>
<p>1 . 构建Scan，指定startRow与stopRow，如果未指定的话会进行全表扫描 2 . 获取ResultScanner 3 . 遍历查询结果 4 . 关闭ResultScanner</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stringFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> HBaseConfiguration.create();</span><br><span class="line">        <span class="comment">// 获取Table实例</span></span><br><span class="line">        <span class="type">HTable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTable</span>(conf, <span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建Scan</span></span><br><span class="line">        <span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">        scan = scan.setStartRow(Bytes.toBytes(<span class="string">&quot;startRowxxx&quot;</span>)).setStopRow(Bytes.toBytes(<span class="string">&quot;StopRowxxx&quot;</span>));</span><br><span class="line">        <span class="type">RowFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowFilter</span>(</span><br><span class="line">                CompareFilter.CompareOp.EQUAL,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BinaryComparator</span>(Bytes.toBytes(<span class="string">&quot;224382618261914241&quot;</span>))</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        scan.setFilter(filter);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取resultScanner</span></span><br><span class="line">        <span class="type">ResultScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> table.getScanner(scan);</span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理结果</span></span><br><span class="line">        <span class="keyword">while</span> ((result = scanner.next()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">byte</span>[] value = result.getValue(Bytes.toBytes(<span class="string">&quot;ship&quot;</span>), Bytes.toBytes(<span class="string">&quot;addr&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">null</span> || value.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">String</span>(value)</span><br><span class="line">            );</span><br><span class="line">            System.out.println(<span class="string">&quot;hello World&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 关闭ResultScanner</span></span><br><span class="line">        scanner.close();</span><br><span class="line">        table.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>其它的设置参数</p>
<h5 id="Caching-设置一次RPC请求批量读取的Results数量"><a href="#Caching-设置一次RPC请求批量读取的Results数量" class="headerlink" title="Caching: 设置一次RPC请求批量读取的Results数量"></a>Caching: 设置一次RPC请求批量读取的Results数量</h5><p>下面的示例代码设定了一次读取回来的Results数量为100：</p>
<div class="highlight-container" data-rel="Ini"><figure class="iseeu highlight ini"><table><tr><td class="code"><pre><span class="line">scan.setCaching(100)<span class="comment">;</span></span><br></pre></td></tr></table></figure></div>

<p>Client每一次往RegionServer发送scan请求，都会批量拿回一批数据(由Caching决定过了每一次拿回的Results数量)，然后放到本次的Result Cache中：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/15/168f018ca777e151~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"
                      alt="image"
                ></p>
<p>应用每一次读取数据时，都是从本地的Result Cache中获取的。如果Result Cache中的数据读完了，则Client会再次往RegionServer发送scan请求获取更多的数据。</p>
<h5 id="Batch-设置每一个Result中的列的数量"><a href="#Batch-设置每一个Result中的列的数量" class="headerlink" title="Batch: 设置每一个Result中的列的数量"></a>Batch: 设置每一个Result中的列的数量</h5><p>下面的示例代码设定了每一个Result中的列的数量的限制值为3：</p>
<div class="highlight-container" data-rel="Ini"><figure class="iseeu highlight ini"><table><tr><td class="code"><pre><span class="line">scan.setBatch(3)<span class="comment">;</span></span><br></pre></td></tr></table></figure></div>

<p>该参数适用于一行数据过大的场景，这样，一行数据被请求的列会被拆成多个Results返回给Client。</p>
<p>举例说明如下：</p>
<p>假设一行数据中共有十个列： {Col01，Col02，Col03，Col04，Col05，Col06，Col07，Col08，Col09, Col10} 假设Scan中设置的Batch为3，那么，这一行数据将会被拆成4个Results返回：</p>
<div class="highlight-container" data-rel="Rust"><figure class="iseeu highlight rust"><table><tr><td class="code"><pre><span class="line">Result1 <span class="punctuation">-&gt;</span> &#123;Col01，Col02，Col03&#125;</span><br><span class="line">Result2 <span class="punctuation">-&gt;</span> &#123;Col04，Col05，Col06&#125;</span><br><span class="line">Result3 <span class="punctuation">-&gt;</span> &#123;Col07，Col08，Col09&#125;</span><br><span class="line">Result4 <span class="punctuation">-&gt;</span> &#123;Col10&#125;</span><br></pre></td></tr></table></figure></div>

<p>关于Caching参数，我们说明了是Client每一次从RegionServer侧获取到的Results的数量，上例中，一行数据被拆成了4个Results，这将会导致Caching中的计数器被减了4次。结合Caching与Batch，我们再列举一个稍复杂的例子：</p>
<p>假设，Scan的参数设置如下：</p>
<p>final byte[] start &#x3D; Bytes.toBytes(“Row1”); final byte[] stop &#x3D; Bytes.toBytes(“Row5”); Scan scan &#x3D; new Scan(); scan.withStartRow(start).withStopRow(stop); scan.setCaching(10); scan.setBatch(3);</p>
<p>待读取的数据RowKey与所关联的列集如下所示：</p>
<p>Row1:  {Col01，Col02，Col03，Col04，Col05，Col06，Col07，Col08，Col09，Col10}<br> Row2:  {Col01，Col02，Col03，Col04，Col05，Col06，Col07，Col08，Col09，Col10，Col11}<br> Row3:  {Col01，Col02，Col03，Col04，Col05，Col06，Col07，Col08，Col09，Col10}</p>
<p>再回顾一下Caching与Batch的定义：</p>
<p>Caching:  影响一次读取返回的Results数量。</p>
<p>Batch:  限定了一个Result中所包含的列的数量，如果一行数据被请求的列的数量超出Batch限制，那么这行数据会被拆成多个Results。</p>
<p>那么， Client往RegionServer第一次请求所返回的结果集如下所示：</p>
<p>Result1   -&gt;   Row1:  {Col01，Col02，Col03} Result2   -&gt;   Row1:  {Col04，Col05，Col06} Result3   -&gt;   Row1:  {Col07，Col08，Col09} Result4   -&gt;   Row1:  {Col10} Result5   -&gt;   Row2:  {Col01，Col02，Col03} Result6   -&gt;   Row2:  {Col04，Col05，Col06} Result7   -&gt;   Row2:  {Col07，Col08，Col09} Result8   -&gt;   Row2:  {Col10，Col11} Result9   -&gt;   Row3:  {Col01，Col02，Col03} Result10  -&gt;   Row3:  {Col04，Col05，Col06}</p>
<h5 id="Limit-限制一次Scan操作所获取的行的数量"><a href="#Limit-限制一次Scan操作所获取的行的数量" class="headerlink" title="Limit: 限制一次Scan操作所获取的行的数量"></a>Limit: 限制一次Scan操作所获取的行的数量</h5><p>同SQL语法中的limit子句，限制一次Scan操作所获取的行的总量：</p>
<p>scan.setLimit(10000);</p>
<p>注意：Limit参数是在2.0版本中新引入的。但在2.0.0版本中，当Batch与Limit同时设置时，似乎还存在一个BUG，初步分析问题原因应该与BatchScanResultCache中的numberOfCompletedRows计数器逻辑处理有关。因此，暂时不建议同时设置这两个参数。</p>
<h5 id="CacheBlock-RegionServer侧是否要缓存本次Scan所涉及的HFileBlocks"><a href="#CacheBlock-RegionServer侧是否要缓存本次Scan所涉及的HFileBlocks" class="headerlink" title="CacheBlock: RegionServer侧是否要缓存本次Scan所涉及的HFileBlocks"></a>CacheBlock: RegionServer侧是否要缓存本次Scan所涉及的HFileBlocks</h5><p>scan.setCacheBlocks(true);</p>
<p>e) Raw Scan:  是否可以读取到删除标识以及被删除但尚未被清理的数据</p>
<p>scan.setRaw(true);</p>
<h5 id="MaxResultSize-从内存占用量的维度限制一次Scan的返回结果集"><a href="#MaxResultSize-从内存占用量的维度限制一次Scan的返回结果集" class="headerlink" title="MaxResultSize:  从内存占用量的维度限制一次Scan的返回结果集"></a>MaxResultSize:  从内存占用量的维度限制一次Scan的返回结果集</h5><p>下面的示例代码将返回结果集的最大值设置为5MB：</p>
<p>scan.setMaxResultSize(5 * 1024 * 1024);</p>
<h5 id="Reversed-Scan-反向扫描"><a href="#Reversed-Scan-反向扫描" class="headerlink" title="Reversed Scan: 反向扫描"></a>Reversed Scan: 反向扫描</h5><p>普通的Scan操作是按照字典顺序从小到大的顺序读取的，而Reversed Scan则恰好相反：</p>
<p>scan.setReversed(true);</p>
<h5 id="带Filter的Scan"><a href="#带Filter的Scan" class="headerlink" title="带Filter的Scan"></a>带Filter的Scan</h5><p>Filter可以在Scan的结果集基础之上，对返回的记录设置更多条件值，这些条件可以与RowKey有关，可以与列名有关，也可以与列值有关，还可以将多个Filter条件组合在一起，等等。</p>
<p>最常用的Filter是SingleColumnValueFilter，基于它，可以实现如下类似的查询：</p>
<p>“返回满足条件{列I:D的值大于等于10}的所有行”</p>
<p>示例代码如下：</p>
<p>Filter丰富了HBase的查询能力，但使用Filter之前，需要注意一点：Filter可能会导致查询响应时延变的不可控制。因为我们无法预测，为了找到一条符合条件的记录，背后需要扫描多少数据量，如果在有效限制了Scan范围区间(通过设置StartRow与StopRow限制)的前提下，该问题能够得到有效的控制。这些信息都要求使用Filter之前应该详细调研自己的业务数据模型。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>本文有点长，作为参考吧</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>鲁迅杂文片段一</title>
    <url>/2024/04/01/%E9%B2%81%E8%BF%85%E6%9D%82%E6%96%87%E7%89%87%E6%AE%B5%E4%B8%80/</url>
    <content><![CDATA[<p>​	“中国现在的人心中，不平和愤恨的分子太多了。不平还是改造的引线，但必须先改造了自己，再改造社会，改造世界；万万不可单是不平，至于愤恨，却几乎全无用处。”“我们不要借了 ‘天下无公理，无人道’ 这些话，遮盖自暴自弃的行为，自称恨人。”  “父子之间没有什么恩，这一断语，实是招致圣人之徒面红耳赤的一大原因。他们的误点，便在长者本位与利己思想，权利思想很重，义务思想和责任心却轻。“本位应在幼者，却反在长者；置重应在将来，却反在过去。”</p>
<p>​	“穷人的孩子蓬头垢面的在街上转，阔人的孩子妖形妖势娇声娇气的在家里转。转得了，都混天黑地的在社会上转，同他们的父辈一样，或者还不如。虽然人口众多这一句化很多人可以闭了眼睛自负，然而这许多人口便只在尘土中辗转，小的时候，不把人当人，大了以后，也做不了人。”</p>
<p>​	“的确的，谁也没有发见过苍蝇们的缺点和创伤。然而，有缺点的战士终竟是战士，完美的苍蝇也终究不过是苍蝇。”</p>
]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
        <tag>鲁迅</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/06/06/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%88%91%E5%9C%A8%E5%AD%A6Sqoop-%E8%AF%A6%E8%A7%A3%E7%89%88/</url>
    <content><![CDATA[<p>一、Sqoop 基本命令</p>
<h3 id="1-查看所有命令"><a href="#1-查看所有命令" class="headerlink" title="1. 查看所有命令"></a>1. 查看所有命令</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># sqoop help</span><br></pre></td></tr></table></figure></div>



<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/21/16d52d65ecf4149b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="https://github.com/heibaiying"></p>
<h3 id="2-查看某条命令的具体使用方法"><a href="#2-查看某条命令的具体使用方法" class="headerlink" title="2. 查看某条命令的具体使用方法"></a>2. 查看某条命令的具体使用方法</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># sqoop help 命令名</span><br></pre></td></tr></table></figure></div>

<h2 id="二、Sqoop-与-MySQL"><a href="#二、Sqoop-与-MySQL" class="headerlink" title="二、Sqoop 与 MySQL"></a>二、Sqoop 与 MySQL</h2><h3 id="1-查询MySQL所有数据库"><a href="#1-查询MySQL所有数据库" class="headerlink" title="1. 查询MySQL所有数据库"></a>1. 查询MySQL所有数据库</h3><p>通常用于 Sqoop 与 MySQL 连通测试：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop list-databases \</span><br><span class="line">--connect jdbc:mysql://hadoop001:3306/ \</span><br><span class="line">--username root \</span><br><span class="line">--password root</span><br></pre></td></tr></table></figure></div>



<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/21/16d52d65e8345f6d~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="https://github.com/heibaiying"></p>
<h3 id="2-查询指定数据库中所有数据表"><a href="#2-查询指定数据库中所有数据表" class="headerlink" title="2. 查询指定数据库中所有数据表"></a>2. 查询指定数据库中所有数据表</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">sqoop list<span class="operator">-</span>tables \</span><br><span class="line"><span class="comment">--connect jdbc:mysql://hadoop001:3306/mysql \</span></span><br><span class="line"><span class="comment">--username root \</span></span><br><span class="line"><span class="comment">--password root</span></span><br></pre></td></tr></table></figure></div>

<h2 id="三、Sqoop-与-HDFS"><a href="#三、Sqoop-与-HDFS" class="headerlink" title="三、Sqoop 与 HDFS"></a>三、Sqoop 与 HDFS</h2><h3 id="3-1-MySQL数据导入到HDFS"><a href="#3-1-MySQL数据导入到HDFS" class="headerlink" title="3.1 MySQL数据导入到HDFS"></a>3.1 MySQL数据导入到HDFS</h3><h4 id="1-导入命令"><a href="#1-导入命令" class="headerlink" title="1. 导入命令"></a>1. 导入命令</h4><p>示例：导出 MySQL 数据库中的 <code>help_keyword</code> 表到 HDFS 的 <code>/sqoop</code> 目录下，如果导入目录存在则先删除再导入，使用 3 个 <code>map tasks</code> 并行导入。</p>
<blockquote>
<p>注：help_keyword 是 MySQL 内置的一张字典表，之后的示例均使用这张表。</p>
</blockquote>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop import \</span><br><span class="line">--connect jdbc:mysql://hadoop001:3306/mysql \     </span><br><span class="line">--username root \</span><br><span class="line">--password root \</span><br><span class="line">--table help_keyword \           # 待导入的表</span><br><span class="line">--delete-target-dir \            # 目标目录存在则先删除</span><br><span class="line">--target-dir /sqoop \            # 导入的目标目录</span><br><span class="line">--fields-terminated-by &#x27;\t&#x27;  \   # 指定导出数据的分隔符</span><br><span class="line">-m 3                             # 指定并行执行的 map tasks 数量</span><br></pre></td></tr></table></figure></div>

<p>日志输出如下，可以看到输入数据被平均 <code>split</code> 为三份，分别由三个 <code>map task</code> 进行处理。数据默认以表的主键列作为拆分依据，如果你的表没有主键，有以下两种方案：</p>
<ul>
<li>添加 <code>-- autoreset-to-one-mapper</code> 参数，代表只启动一个 <code>map task</code>，即不并行执行；</li>
<li>若仍希望并行执行，则可以使用 <code>--split-by &lt;column-name&gt;</code> 指明拆分数据的参考列。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/21/16d52d65ef75514b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="https://github.com/heibaiying"></p>
<h4 id="2-导入验证"><a href="#2-导入验证" class="headerlink" title="2. 导入验证"></a>2. 导入验证</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看导入后的目录</span><br><span class="line">hadoop fs -ls  -R /sqoop</span><br><span class="line"># 查看导入内容</span><br><span class="line">hadoop fs -text  /sqoop/part-m-00000</span><br></pre></td></tr></table></figure></div>

<p>查看 HDFS 导入目录,可以看到表中数据被分为 3 部分进行存储，这是由指定的并行度决定的。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/21/16d52d65f080c11e~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="https://github.com/heibaiying"></p>
<h3 id="3-2-HDFS数据导出到MySQL"><a href="#3-2-HDFS数据导出到MySQL" class="headerlink" title="3.2 HDFS数据导出到MySQL"></a>3.2 HDFS数据导出到MySQL</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop export  \</span><br><span class="line">    --connect jdbc:mysql://hadoop001:3306/mysql \</span><br><span class="line">    --username root \</span><br><span class="line">    --password root \</span><br><span class="line">    --table help_keyword_from_hdfs \        # 导出数据存储在 MySQL 的 help_keyword_from_hdf 的表中</span><br><span class="line">    --export-dir /sqoop  \</span><br><span class="line">    --input-fields-terminated-by &#x27;\t&#x27;\</span><br><span class="line">    --m 3 </span><br></pre></td></tr></table></figure></div>

<p>表必须预先创建，建表语句如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE help_keyword_from_hdfs LIKE help_keyword ;</span><br></pre></td></tr></table></figure></div>

<h2 id="四、Sqoop-与-Hive"><a href="#四、Sqoop-与-Hive" class="headerlink" title="四、Sqoop 与 Hive"></a>四、Sqoop 与 Hive</h2><h3 id="4-1-MySQL数据导入到Hive"><a href="#4-1-MySQL数据导入到Hive" class="headerlink" title="4.1 MySQL数据导入到Hive"></a>4.1 MySQL数据导入到Hive</h3><p>Sqoop 导入数据到 Hive 是通过先将数据导入到 HDFS 上的临时目录，然后再将数据从 HDFS 上 <code>Load</code> 到 Hive 中，最后将临时目录删除。可以使用 <code>target-dir</code> 来指定临时目录。</p>
<h4 id="1-导入命令-1"><a href="#1-导入命令-1" class="headerlink" title="1. 导入命令"></a>1. 导入命令</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop import \</span><br><span class="line">  --connect jdbc:mysql://hadoop001:3306/mysql \</span><br><span class="line">  --username root \</span><br><span class="line">  --password root \</span><br><span class="line">  --table help_keyword \        # 待导入的表     </span><br><span class="line">  --delete-target-dir \         # 如果临时目录存在删除</span><br><span class="line">  --target-dir /sqoop_hive  \   # 临时目录位置</span><br><span class="line">  --hive-database sqoop_test \  # 导入到 Hive 的 sqoop_test 数据库，数据库需要预先创建。不指定则默认为 default 库</span><br><span class="line">  --hive-import \               # 导入到 Hive</span><br><span class="line">  --hive-overwrite \            # 如果 Hive 表中有数据则覆盖，这会清除表中原有的数据，然后再写入</span><br><span class="line">  -m 3                          # 并行度</span><br></pre></td></tr></table></figure></div>

<p>导入到 Hive 中的 <code>sqoop_test</code> 数据库需要预先创建，不指定则默认使用 Hive 中的 <code>default</code> 库。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看 hive 中的所有数据库</span><br><span class="line">hive&gt;  SHOW DATABASES;</span><br><span class="line"># 创建 sqoop_test 数据库</span><br><span class="line">hive&gt;  CREATE DATABASE sqoop_test;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-导入验证-1"><a href="#2-导入验证-1" class="headerlink" title="2. 导入验证"></a>2. 导入验证</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看 sqoop_test 数据库的所有表</span><br><span class="line"> hive&gt;  SHOW  TABLES  IN  sqoop_test;</span><br><span class="line"># 查看表中数据</span><br><span class="line"> hive&gt; SELECT * FROM sqoop_test.help_keyword;</span><br></pre></td></tr></table></figure></div>



<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/21/16d52d7fe4d515fb~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="https://github.com/heibaiying"></p>
<h4 id="3-可能出现的问题"><a href="#3-可能出现的问题" class="headerlink" title="3. 可能出现的问题"></a>3. 可能出现的问题</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/21/16d52d6ea9d46b79~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="https://github.com/heibaiying"></p>
<p>如果执行报错 <code>java.io.IOException: java.lang.ClassNotFoundException: org.apache.hadoop.hive.conf.HiveConf</code>，则需将 Hive 安装目录下 <code>lib</code> 下的 <code>hive-exec-**.jar</code> 放到 sqoop 的 <code>lib</code> 。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@hadoop001 lib]# ll hive-exec-*</span><br><span class="line">-rw-r--r--. 1 1106 4001 19632031 11 月 13 21:45 hive-exec-1.1.0-cdh5.15.2.jar</span><br><span class="line">[root@hadoop001 lib]# cp hive-exec-1.1.0-cdh5.15.2.jar  $&#123;SQOOP_HOME&#125;/lib</span><br></pre></td></tr></table></figure></div>



<h3 id="4-2-Hive-导出数据到MySQL"><a href="#4-2-Hive-导出数据到MySQL" class="headerlink" title="4.2 Hive 导出数据到MySQL"></a>4.2 Hive 导出数据到MySQL</h3><p>由于 Hive 的数据是存储在 HDFS 上的，所以 Hive 导入数据到 MySQL，实际上就是 HDFS 导入数据到 MySQL。</p>
<h4 id="1-查看Hive表在HDFS的存储位置"><a href="#1-查看Hive表在HDFS的存储位置" class="headerlink" title="1. 查看Hive表在HDFS的存储位置"></a>1. 查看Hive表在HDFS的存储位置</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入对应的数据库</span><br><span class="line">hive&gt; use sqoop_test;</span><br><span class="line"># 查看表信息</span><br><span class="line">hive&gt; desc formatted help_keyword;</span><br></pre></td></tr></table></figure></div>

<p><code>Location</code> 属性为其存储位置：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/21/16d52d66bf0fb5ff~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="https://github.com/heibaiying"></p>
<p>这里可以查看一下这个目录，文件结构如下：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/21/16d52d671112a263~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="https://github.com/heibaiying"></p>
<h4 id="3-2-执行导出命令"><a href="#3-2-执行导出命令" class="headerlink" title="3.2 执行导出命令"></a>3.2 执行导出命令</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop export  \</span><br><span class="line">    --connect jdbc:mysql://hadoop001:3306/mysql \</span><br><span class="line">    --username root \</span><br><span class="line">    --password root \</span><br><span class="line">    --table help_keyword_from_hive \</span><br><span class="line">    --export-dir /user/hive/warehouse/sqoop_test.db/help_keyword  \</span><br><span class="line">    -input-fields-terminated-by &#x27;\001&#x27; \             # 需要注意的是 hive 中默认的分隔符为 \001</span><br><span class="line">    --m 3 </span><br></pre></td></tr></table></figure></div>

<p>MySQL 中的表需要预先创建：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE help_keyword_from_hive LIKE help_keyword ;</span><br></pre></td></tr></table></figure></div>

<h2 id="五、Sqoop-与-HBase"><a href="#五、Sqoop-与-HBase" class="headerlink" title="五、Sqoop 与 HBase"></a>五、Sqoop 与 HBase</h2><blockquote>
<p>本小节只讲解从 RDBMS 导入数据到 HBase，因为暂时没有命令能够从 HBase 直接导出数据到 RDBMS。</p>
</blockquote>
<h3 id="5-1-MySQL导入数据到HBase"><a href="#5-1-MySQL导入数据到HBase" class="headerlink" title="5.1 MySQL导入数据到HBase"></a>5.1 MySQL导入数据到HBase</h3><h4 id="1-导入数据"><a href="#1-导入数据" class="headerlink" title="1. 导入数据"></a>1. 导入数据</h4><p>将 <code>help_keyword</code> 表中数据导入到 HBase 上的 <code>help_keyword_hbase</code> 表中，使用原表的主键 <code>help_keyword_id</code> 作为 <code>RowKey</code>，原表的所有列都会在 <code>keywordInfo</code> 列族下，目前只支持全部导入到一个列族下，不支持分别指定列族。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop import \</span><br><span class="line">    --connect jdbc:mysql://hadoop001:3306/mysql \</span><br><span class="line">    --username root \</span><br><span class="line">    --password root \</span><br><span class="line">    --table help_keyword \              # 待导入的表</span><br><span class="line">    --hbase-table help_keyword_hbase \  # hbase 表名称，表需要预先创建</span><br><span class="line">    --column-family keywordInfo \       # 所有列导入到 keywordInfo 列族下 </span><br><span class="line">    --hbase-row-key help_keyword_id     # 使用原表的 help_keyword_id 作为 RowKey</span><br></pre></td></tr></table></figure></div>

<p>导入的 HBase 表需要预先创建：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看所有表</span><br><span class="line">hbase&gt; list</span><br><span class="line"># 创建表</span><br><span class="line">hbase&gt; create &#x27;help_keyword_hbase&#x27;, &#x27;keywordInfo&#x27;</span><br><span class="line"># 查看表信息</span><br><span class="line">hbase&gt; desc &#x27;help_keyword_hbase&#x27;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-导入验证-2"><a href="#2-导入验证-2" class="headerlink" title="2. 导入验证"></a>2. 导入验证</h4><p>使用 <code>scan</code> 查看表数据：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/21/16d52d67852063a6~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="https://github.com/heibaiying"></p>
<h2 id="六、全库导出"><a href="#六、全库导出" class="headerlink" title="六、全库导出"></a>六、全库导出</h2><p>Sqoop 支持通过 <code>import-all-tables</code> 命令进行全库导出到 HDFS&#x2F;Hive，但需要注意有以下两个限制：</p>
<ul>
<li>所有表必须有主键；或者使用 <code>--autoreset-to-one-mapper</code>，代表只启动一个 <code>map task</code>;</li>
<li>你不能使用非默认的分割列，也不能通过 WHERE 子句添加任何限制。</li>
</ul>
<blockquote>
<p>第二点解释得比较拗口，这里列出官方原本的说明：</p>
<ul>
<li>You must not intend to use non-default splitting column, nor impose any conditions via a <code>WHERE</code> clause.</li>
</ul>
</blockquote>
<p>全库导出到 HDFS：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop import-all-tables \</span><br><span class="line">    --connect jdbc:mysql://hadoop001:3306/数据库名 \</span><br><span class="line">    --username root \</span><br><span class="line">    --password root \</span><br><span class="line">    --warehouse-dir  /sqoop_all \     # 每个表会单独导出到一个目录，需要用此参数指明所有目录的父目录</span><br><span class="line">    --fields-terminated-by &#x27;\t&#x27;  \</span><br><span class="line">    -m 3</span><br></pre></td></tr></table></figure></div>

<p>全库导出到 Hive：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop import-all-tables -Dorg.apache.sqoop.splitter.allow_text_splitter=true \</span><br><span class="line">  --connect jdbc:mysql://hadoop001:3306/数据库名 \</span><br><span class="line">  --username root \</span><br><span class="line">  --password root \</span><br><span class="line">  --hive-database sqoop_test \         # 导出到 Hive 对应的库   </span><br><span class="line">  --hive-import \</span><br><span class="line">  --hive-overwrite \</span><br><span class="line">  -m 3</span><br></pre></td></tr></table></figure></div>

<h2 id="七、Sqoop-数据过滤"><a href="#七、Sqoop-数据过滤" class="headerlink" title="七、Sqoop 数据过滤"></a>七、Sqoop 数据过滤</h2><h3 id="7-1-query参数"><a href="#7-1-query参数" class="headerlink" title="7.1 query参数"></a>7.1 query参数</h3><p>Sqoop 支持使用 <code>query</code> 参数定义查询 SQL，从而可以导出任何想要的结果集。使用示例如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop import \</span><br><span class="line">  --connect jdbc:mysql://hadoop001:3306/mysql \</span><br><span class="line">  --username root \</span><br><span class="line">  --password root \</span><br><span class="line">  --query &#x27;select * from help_keyword where  $CONDITIONS and  help_keyword_id &lt; 50&#x27; \  </span><br><span class="line">  --delete-target-dir \            </span><br><span class="line">  --target-dir /sqoop_hive  \ </span><br><span class="line">  --hive-database sqoop_test \           # 指定导入目标数据库 不指定则默认使用 Hive 中的 default 库</span><br><span class="line">  --hive-table filter_help_keyword \     # 指定导入目标表</span><br><span class="line">  --split-by help_keyword_id \           # 指定用于 split 的列      </span><br><span class="line">  --hive-import \                        # 导入到 Hive</span><br><span class="line">  --hive-overwrite \                     、</span><br><span class="line">  -m 3                                  </span><br></pre></td></tr></table></figure></div>

<p>在使用 <code>query</code> 进行数据过滤时，需要注意以下三点：</p>
<ul>
<li>必须用 <code>--hive-table</code> 指明目标表；</li>
<li>如果并行度 <code>-m</code> 不为 1 或者没有指定 <code>--autoreset-to-one-mapper</code>，则需要用 <code>--split-by</code> 指明参考列；</li>
<li>SQL 的 <code>where</code> 字句必须包含 <code>$CONDITIONS</code>，这是固定写法，作用是动态替换。</li>
</ul>
<h3 id="7-2-增量导入"><a href="#7-2-增量导入" class="headerlink" title="7.2 增量导入"></a>7.2 增量导入</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop import \</span><br><span class="line">    --connect jdbc:mysql://hadoop001:3306/mysql \</span><br><span class="line">    --username root \</span><br><span class="line">    --password root \</span><br><span class="line">    --table help_keyword \</span><br><span class="line">    --target-dir /sqoop_hive  \</span><br><span class="line">    --hive-database sqoop_test \         </span><br><span class="line">    --incremental  append  \             # 指明模式</span><br><span class="line">    --check-column  help_keyword_id \    # 指明用于增量导入的参考列</span><br><span class="line">    --last-value 300  \                  # 指定参考列上次导入的最大值</span><br><span class="line">    --hive-import \   </span><br><span class="line">    -m 3  </span><br></pre></td></tr></table></figure></div>

<p><code>incremental</code> 参数有以下两个可选的选项：</p>
<ul>
<li><strong>append</strong>：要求参考列的值必须是递增的，所有大于 <code>last-value</code> 的值都会被导入；</li>
<li><strong>lastmodified</strong>：要求参考列的值必须是 <code>timestamp</code> 类型，且插入数据时候要在参考列插入当前时间戳，更新数据时也要更新参考列的时间戳，所有时间晚于 <code>last-value</code> 的数据都会被导入。</li>
</ul>
<p>通过上面的解释我们可以看出来，其实 Sqoop 的增量导入并没有太多神器的地方，就是依靠维护的参考列来判断哪些是增量数据。当然我们也可以使用上面介绍的 <code>query</code> 参数来进行手动的增量导出，这样反而更加灵活。</p>
<h2 id="八、类型支持"><a href="#八、类型支持" class="headerlink" title="八、类型支持"></a>八、类型支持</h2><p>Sqoop 默认支持数据库的大多数字段类型，但是某些特殊类型是不支持的。遇到不支持的类型，程序会抛出异常 <code>Hive does not support the SQL type for column xxx</code> 异常，此时可以通过下面两个参数进行强制类型转换：</p>
<ul>
<li><strong>–map-column-java<mapping></strong>   ：重写 SQL 到 Java 类型的映射；</li>
<li><strong>–map-column-hive <mapping></strong> ： 重写 Hive 到 Java 类型的映射。</li>
</ul>
<p>示例如下，将原先 <code>id</code> 字段强制转为 String 类型，<code>value</code> 字段强制转为 Integer 类型：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sqoop import ... --map-column-java id=String,value=Integer</span><br></pre></td></tr></table></figure></div>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a class="link"   href="https://link.juejin.cn/?target=http://sqoop.apache.org/docs/1.4.7/SqoopUserGuide.html" >Sqoop User Guide (v1.4.7) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
</search>
